<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105F24" />
  <title>HW4CSE105F24: Homework assignment 4</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW4CSE105F24: Homework assignment 4</h1>
<p class="author">CSE105F24</p>
<p class="date">Due: November 12, 2024 at 5pm, via Gradescope</p>
</header>
<p><span><strong>In this assignment,</strong></span></p>
<p>You will work with context-free languages and their representations.
You will also practice analyzing, designing, and working with Turing
machines. You will use general constructions and specific machines to
explore the classes of recognizable and decidable languages.</p>
<p><span><strong>Resources</strong></span>: To review the topics for
this assignment, see the class material from Weeks 4, 5, and 6. We will
post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><span><strong>Reading and extra practice problems</strong></span>:
Sipser Chapters 2 and 3. Chapter 2 exercises 2.1, 2.2, 2.3, 2.4, 2.5,
2.6, 2.7, 2.9, 2.10, 2.11, 2.12, 2.13, 2.16, 2.17. Chapter 3 exercises
3.1, 3.2, 3.5, 3.8.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. For “graded for correctness”
questions: collaboration is allowed only with CSE 105 students in your
group; if your group has questions about a problem, you may ask in
drop-in help hours or post a private post (visible only to the
Instructors) on Piazza. For “graded for completeness” questions:
collaboration is allowed with any CSE 105 students this quarter; if your
group has questions about a problem, you may ask in drop-in help hours
or post a public post on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines,you
can (1) use the LaTex tikzpicture environment (see templates in the
class notes), or (2)) use the software tools Flap.js or JFLAP described
in the class syllabus (and include a screenshot in your PDF), or (3) you
can carefully and clearly hand-draw the diagram and take a picture and
include it in your PDF. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework questions graded for
correctness with anyone other than your group members. You may ask
questions about the homework in office hours (of the instructor, TAs,
and/or tutors) and on Piazza (as private notes viewable only to the
Instructors). You <em>cannot</em> use any online resources about the
course content other than the class material from this quarter – this is
primarily to ensure that we all use consistent notation and definitions
(aligned with the textbook) and also to protect the learning experience
you will have when the ‘aha’ moments of solving the problem
authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw4CSE105F24”.</p>
<p><span><strong>Assigned questions</strong></span></p>
<ol>
<li><p><strong>Push-down automata (PDA) and context-free grammars
(CFG)</strong> (8 points): On page 14 of the week 3 notes, we have the
following list of languages over the alphabet <span
class="math inline">\(\{a,b\}\)</span></p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{a^nb^n
\mid 0  \leq n  \leq 5 \}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{b^n a^n
\mid  n  \geq 2\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  0 \leq m\leq n\}\)</span></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  m \geq n+3,  n \geq 0\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{b^m a^n
\mid  m \geq 1, n \geq  3\}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{ w  \in
\{a,b\}^* \mid w = w^\mathcal{R} \}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{
ww^\mathcal{R} \mid w\in \{a,b\}^* \}\)</span></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Pick one of the regular languages and design a regular expression that
describes it. Briefly justify your regular expression by connecting the
subexpressions of it to the intended language and referencing relevant
definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Pick another one
of the regular languages and design a deterministic finite automaton
(DFA) that recognizes it. Draw the state diagram of your DFA. Briefly
justify your design by explaining the role each state plays in the
machine, as well as a brief justification about how the strings accepted
and rejected by the machine connect to the specified language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Pick one of the
nonregular languages and design a PDA that recognizes it. Draw the state
diagram of your PDA. Briefly justify your design by explaining the role
each state plays in the machine, as well as a brief justification about
how the strings accepted and rejected by the machine connect to the
specified language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Pick one of the
nonregular languages and write a CFG that generates it. Briefly justify
your design by demonstrating how derivations in the grammar relate to
the intended language.</p></li>
</ol></li>
<li><p><strong>General constructions for context-free languages</strong>
(21 points):</p>
<p>In class in weeks 4 and 5, we described several general constructions
with PDAs and CFGs, leaving their details to homework. In this question,
we’ll fill in these details. The first constructions help us prove that
the class of regular languages is a subset of the class of context-free
languages. The other construction allows us to make simplifying
assumptions about PDAs recognizing languages.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
When we first introduced PDAs we observed that any NFA can be
transformed to a PDA by not using the stack of the PDA at all. Suppose a
friend gives you the following construction to formalize this
transformation:</p>
<blockquote>
<p>Given a NFA <span class="math inline">\(N = (Q, \Sigma, \delta_N,
q_0, F)\)</span> we define a PDA <span class="math inline">\(M\)</span>
with <span class="math inline">\(L(M) = L(N)\)</span> by letting <span
class="math inline">\(M = ( Q, \Sigma, \Sigma, \delta, q_0, F)\)</span>
where <span class="math inline">\(\delta(~(q,a,b)~) =
\delta_N(~(q,a)~)\)</span> for each <span class="math inline">\(q \in
Q\)</span>, <span class="math inline">\(a \in
\Sigma_{\varepsilon}\)</span> and <span class="math inline">\(b \in
\Sigma_{\varepsilon}\)</span>.</p>
</blockquote>
<p>For each of the six defining parameters for the PDA, explain whether
it’s defined correctly or not. If it is not defined correctly, explain
why not and give a new definition for this parameter that corrects the
mistake.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) In the book on
page 107, the top paragraph describes a procedure for converting DFAs to
CFGs:</p>
<blockquote>
<p>You can convert any DFA into an equivalent CFG as follows. Make a
variable <span class="math inline">\(R_i\)</span> for each state <span
class="math inline">\(q_i\)</span> of the DFA. Add the rule <span
class="math inline">\(R_i \to aR_j\)</span> to the CFG if <span
class="math inline">\(\delta(q_i,a) =q_j\)</span> is a transition in the
DFA. Add the rule <span class="math inline">\(R_i\to
\varepsilon\)</span> if <span class="math inline">\(q_i\)</span> is an
accept state of the DFA. Make <span class="math inline">\(R_0\)</span>
the start variable ofthe grammar, where <span
class="math inline">\(q_0\)</span> is the start state of the machine.
Verify on your own that the resulting CFG generates the same language
that the DFA recognizes.</p>
</blockquote>
<p>Use this construction to get a context-free grammar generating the
language <span class="math display">\[\{ w \in \{0,1\}^* \mid w \text{
does not end in  $101$}\}\]</span> by (1) designing a DFA that
recognizes this language and then (2) applying the construction from the
book to convert the DFA to an equivalent CFG. A complete and correct
submission will include the state diagram of the DFA, a brief
justification of why it recognizes the language, and then the complete
and precise definition of the CFG that results from applying the
construction from the book to this DFA. <span><em>Ungraded bonus: take a
sample string in the language and see how the computation of the DFA on
this string translates to a derivation in your
grammar.</em></span></p></li>
<li><p>Let <span class="math inline">\(M_1 = (Q_1, \Sigma, \Gamma_1,
\delta_1, q_1, F_1)\)</span> be a PDA and let <span
class="math inline">\(q_{new}, r_{new}, s_{new}\)</span> be three fresh
state labels (i.e. <span class="math inline">\(Q_1 \cap \{q_{new},
r_{new}, s_{new}\} = \emptyset\)</span>) and let <span
class="math inline">\(\#\)</span> be a fresh stack symbol (i.e. <span
class="math inline">\(\# \notin \Gamma_1\)</span>). We define the PDA
<span class="math inline">\(M_2\)</span> as <span
class="math display">\[(Q_2, \Sigma, \Gamma_2, \delta_2, q_{new},
\{s_{new}\})\]</span> with <span class="math inline">\(Q_2 = Q_1 \cup
\{q_{new}, r_{new}, s_{new}\}\)</span> and <span
class="math inline">\(\Gamma_2 = \Gamma_1 \cup \{\#\}\)</span> and <span
class="math inline">\(\delta_2 : Q_2 \times \Sigma_\varepsilon \times
{\Gamma_2}_\varepsilon \to
\mathcal{P}(Q_2 \times {\Gamma_2}_\varepsilon)\)</span> given by <span
class="math display">\[\delta_2 ( ~(q,a,b)~) =
\begin{cases}
\{(q_1, \#)\} &amp;\text{if } q = q_{new}, a = \varepsilon, b =
\varepsilon\\
\delta_1( ~(q,a,b)~) &amp;\text{if } q\in Q_1 \setminus F_1, a \in
\Sigma_{\varepsilon}, b \in {\Gamma_1}_\varepsilon \\
\delta_1( ~(q,a,b)~) &amp;\text{if } q\in F_1, a \in \Sigma, b \in
{\Gamma_1}_\varepsilon \\
\delta_1( ~(q,a,b)~) &amp;\text{if } q\in F_1, a =\varepsilon, b \in
{\Gamma_1} \\
\delta_1( ~(q,a,b)~) \cup \{(r_{new}, \varepsilon)\} &amp;\text{if }
q\in F_1, a =\varepsilon, b =\varepsilon \\
\{(r_{new}, \varepsilon)\} &amp;\text{if } q = r_{new}, a =\varepsilon,
b \in \Gamma_{1} \\
\{(s_{new}, \varepsilon)\} &amp;\text{if } q= r_{new}, a = \varepsilon,
b = \#\\
\emptyset &amp; \text{otherwise}
\end{cases}\]</span> for each <span class="math inline">\(q \in
Q_2\)</span>, <span class="math inline">\(a \in
\Sigma_{\varepsilon}\)</span>, and <span class="math inline">\(b \in
{\Gamma_2}_\varepsilon\)</span>.</p>
<p>In this question, we’ll apply this construction for a specific PDA
and use this example to extrapolate the effect of this construction.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Consider the PDA
<span class="math inline">\(M_1\)</span> with input alphabet <span
class="math inline">\(\{0,1\}\)</span> and stack alphabet <span
class="math inline">\(\{0,1\}\)</span> whose state diagram is</p>
<div class="center">

</div>
<p>Draw the state diagram for the PDA <span
class="math inline">\(M_2\)</span> that results from applying the
construction to <span class="math inline">\(M_1\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Compare <span
class="math inline">\(L(M_1)\)</span> and <span
class="math inline">\(L(M_2)\)</span>. Are these sets equal? Does your
answer depend on the specific choice of <span
class="math inline">\(M_1\)</span>? Why or why not?</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Consider the PDA
<span class="math inline">\(N\)</span> with input alphabet <span
class="math inline">\(\{0,1\}\)</span> and stack alphabet <span
class="math inline">\(\{0,1\}\)</span> whose state diagram is</p>
<div class="center">

</div>
<p>Remember that the definition of set-wise concatenation is: for
languages <span class="math inline">\(L_1, L_2\)</span> over the
alphabet <span class="math inline">\(\Sigma\)</span>, we have the
associated set of strings <span class="math display">\[L_1 \circ L_2 =
\{ w \in \Sigma^* ~|~ w = uv \text{ for some strings } u \in L_1 \text{
and } v \in L_2 \}\]</span> In class, we discussed how extrapolating the
construction that we used to prove that the class of regular languages
is closed under set-wise concategation by drawing spontaneous
transitions from the accepting states in the first machine to the start
state of the second machine doesn’t work. Use the example of <span
class="math inline">\(M_1\)</span> and <span
class="math inline">\(N_1\)</span> to prove this by showing that <span
class="math display">\[L(M_1) \circ L(N)\]</span> is
<span><strong>not</strong></span> the language recognized by the machine
results from taking the two machines <span
class="math inline">\(M_1\)</span> and <span
class="math inline">\(N\)</span>, setting the start state of <span
class="math inline">\(M_1\)</span> to be the start state of the new
machine, setting the set of accepting states of <span
class="math inline">\(N\)</span> to be the set of accepting states of
the new machine, and drawing spontaneous arrows from the accepting
states of <span class="math inline">\(M_1\)</span> to the start state of
<span class="math inline">\(N\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Describe the
language recognized by the machine that results from taking the two
machines <span class="math inline">\(M_2\)</span> and <span
class="math inline">\(N\)</span>, setting the start state of <span
class="math inline">\(M_2\)</span> to be the start state of the new
machine, setting the set of accepting states of <span
class="math inline">\(N\)</span> to be the set of accepting states of
the new machine, and drawing spontaneous arrows from the accepting
states of <span class="math inline">\(M_2\)</span> to the start state of
<span class="math inline">\(N\)</span>. Use this description to explain
why we used the construction of <span class="math inline">\(M_2\)</span>
from <span class="math inline">\(M_1\)</span> and how this construction
could be used in a proof of the closure of the class of context-free
languages under set-wise concatenation.</p></li>
</ol></li>
</ol></li>
<li><p><strong>Turing machines</strong> (12 points):</p>
<p>Consider the Turing machine <span class="math inline">\(T\)</span>
over the input alphabet <span class="math inline">\(\Sigma =
\{0,1\}\)</span> with the state diagram below (the tape alphabet is
<span class="math inline">\(\Gamma = \{ 0,1,X,\square\}\)</span>).
Convention: we do not include the node for the reject state <span
class="math inline">\(qrej\)</span> and any missing transitions in the
state diagram have value <span
class="math inline">\((qrej,\square,R)\)</span></p>
<div class="center">

</div>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Specify an example
string <span class="math inline">\(w_1\)</span> of length <span
class="math inline">\(4\)</span> over <span
class="math inline">\(\Sigma\)</span> that is
<span><strong>accepted</strong></span> by this Turing machine, or
explain why there is no such example. A complete solution will include
either (1) a precise and clear description of your example string and a
precise and clear description of the accepting computation of the Turing
machine on this string or (2) a sufficiently general and correct
argument why there is no such example, referring back to the relevant
definitions.</p>
<p>To describe a computation of a Turing machine, include the contents
of the tape, the state of the machine, and the location of the
read/write head at each step in the computation.</p>
<p><span><em>Hint:</em></span> In class we’ve drawn pictures to
represent the configuration of the machine at each step in a
computation. You may do so or you may choose to describe these
configurations in words.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Specify an example
string <span class="math inline">\(w_2\)</span> of length <span
class="math inline">\(3\)</span> over <span
class="math inline">\(\Sigma\)</span> that is
<span><strong>rejected</strong></span> by this Turing machine or explain
why there is no such example. A complete solution will include either
(1) a precise and clear description of your example string and a precise
and clear description of the rejecting computation of the Turing machine
on this string or (2) a sufficiently general and correct argument why
there is no such example, referring back to the relevant
definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Specify an example
string <span class="math inline">\(w_3\)</span> of length <span
class="math inline">\(2\)</span> over <span
class="math inline">\(\Sigma\)</span> on which the computation of this
Turing machine is <span><strong>never halts</strong></span> or explain
why there is no such example. A complete solution will include either
(1) a precise and clear description of your example string and a precise
and clear description of the looping (non-halting) computation of the
Turing machine on this string or (2) a sufficiently general and correct
argument why there is no such example, referring back to the relevant
definitions.</p>
<p><span><em>Note</em></span>: when a Turing machine does not halt on a
given input string, we say that it <span><strong>loops</strong></span>
on that string.</p></li>
</ol></li>
<li><p><strong>Implementation-level descriptions of deciders and
recognizers</strong> (9 points):</p>
<p>For this question, consider the alphabet <span
class="math inline">\(\Sigma = \{a,b,c\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Give an example of
an infinite language over <span class="math inline">\(\Sigma\)</span>
(that is not <span class="math inline">\(\Sigma^*\)</span>) and give two
different Turing machines that recognize it: one that is a decider and
one that is not. A complete solution will include a precise definition
for your example language, along with <span><strong>both</strong></span>
a state diagram and an implementation-level description of each Turing
machines, along with a brief explanation of why each of them recognizes
the language and why one is a decider and there other is not.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) True or false:
There is a Turing machine that is not a decider that recognizes the
empty set. A complete solution will include a witness Turing machine
(given by state diagram or implementation-level description or
high-level description) and a justification for why it’s not a decider
and why it does not accept any strings, or a complete and correct
justification for why there is no such Turing machine.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) True or false:
There is a Turing machine that is not a decider that recognizes the set
of all string <span class="math inline">\(\Sigma^*\)</span>. A complete
solution will include a witness Turing machine (given by state diagram
or implementation-level description or high-level description) and a
justification for why it’s not a decider and why it accept each string
over <span class="math inline">\(\{a,b,c\}\)</span>, or a complete and
correct justification for why there is no such Turing machine.</p></li>
</ol></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we expect you to include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
