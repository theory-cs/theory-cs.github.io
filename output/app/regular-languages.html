<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>regular-languages</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="week5-friday">Week5 friday</h1>
<p>A set <span class="math inline">\(X\)</span> is said to be
<span><strong>closed</strong></span> under an operation <span
class="math inline">\(OP\)</span> if, for any elements in <span
class="math inline">\(X\)</span>, applying <span
class="math inline">\(OP\)</span> to them gives an element in <span
class="math inline">\(X\)</span>.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">True/False</th>
<th style="text-align: left;">Closure claim</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">True</td>
<td style="text-align: left;">The set of integers is closed under
multiplication.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(\forall x
\forall y \left( ~(x \in \mathbb{Z} \wedge y \in \mathbb{Z})\to xy \in
\mathbb{Z}~\right)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">True</td>
<td style="text-align: left;">For each set <span
class="math inline">\(A\)</span>, the power set of <span
class="math inline">\(A\)</span> is closed under intersection.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(\forall A_1
\forall A_2 \left( ~(A_1 \in \mathcal{P}(A) \wedge A_2 \in
\mathcal{P}(A) \in \mathbb{Z}) \to A_1 \cap A_2 \in
\mathcal{P}(A)~\right)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of regular languages over <span
class="math inline">\(\Sigma\)</span> is closed under
complementation.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of regular languages over <span
class="math inline">\(\Sigma\)</span> is closed under union.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of regular languages over <span
class="math inline">\(\Sigma\)</span> is closed under intersection.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of regular languages over <span
class="math inline">\(\Sigma\)</span> is closed under
concatenation.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of regular languages over <span
class="math inline">\(\Sigma\)</span> is closed under Kleene star.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of context-free languages over
<span class="math inline">\(\Sigma\)</span> is closed under
complementation.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of context-free languages over
<span class="math inline">\(\Sigma\)</span> is closed under union.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of context-free languages over
<span class="math inline">\(\Sigma\)</span> is closed under
intersection.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of context-free languages over
<span class="math inline">\(\Sigma\)</span> is closed under
concatenation.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;">The class of context-free languages over
<span class="math inline">\(\Sigma\)</span> is closed under Kleene
star.</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p>Assume <span class="math inline">\(\Sigma  = \{0,1, \#\}\)</span></p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\Sigma^*\)</span></td>
<td style="text-align: center;">Regular   /   nonregular and
context-free   /  not context-free</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\{0^i\# 1^j
\mid i \geq  0, j  \geq 0\}\)</span></td>
<td style="text-align: center;">Regular   /   nonregular and
context-free   /  not context-free</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{0^i1^j\#
1^j0^i \mid i \geq  0, j  \geq 0\}\)</span></td>
<td style="text-align: center;">Regular   /   nonregular and
context-free   /  not context-free</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\{0^i1^j\#
0^i 1^j \mid i \geq  0, j  \geq 0\}\)</span></td>
<td style="text-align: center;">Regular   /   nonregular and
context-free   /  not context-free</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Turing machines</strong></span>: unlimited read + write
memory, unlimited time (computation can proceed without “consuming”
input and can re-read symbols of input)</p>
<ul>
<li><p>Division betweeen program (CPU, state diagram) and data</p></li>
<li><p>Unbounded memory gives theoretical limit to what modern
computation (including PCs, supercomputers, quantum computers) can
achieve</p></li>
<li><p>State diagram formulation is simple enough to reason about (and
diagonalize against) while expressive enough to capture modern
computation</p></li>
</ul>
<p>For Turing machine <span class="math inline">\(M= (Q, \Sigma, \Gamma,
\delta, q_0, q_{accept}, q_{reject})\)</span> the
<span><strong>computation</strong></span> of <span
class="math inline">\(M\)</span> on a string <span
class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> is:</p>
<ul>
<li><p>Read/write head starts at leftmost position on tape.</p></li>
<li><p>Input string is written on <span
class="math inline">\(|w|\)</span>-many leftmost cells of tape, rest of
the tape cells have the blank symbol. <span><strong>Tape
alphabet</strong></span> is <span class="math inline">\(\Gamma\)</span>
with <span class="math inline">\(\textvisiblespace\in \Gamma\)</span>
and <span class="math inline">\(\Sigma \subseteq \Gamma\)</span>. The
blank symbol <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>.</p></li>
<li><p>Given current state of machine and current symbol being read at
the tape head, the machine transitions to next state, writes a symbol to
the current position of the tape head (overwriting existing symbol), and
moves the tape head L or R (if possible). Formally,
<span><strong>transition function</strong></span> is <span
class="math display">\[\delta: Q\times \Gamma \to Q \times \Gamma \times
\{L, R\}\]</span></p></li>
<li><p>Computation ends if and when machine enters either the accept or
the reject state. This is called <span><strong>halting</strong></span>.
Note: <span class="math inline">\(q_{accept} \neq
q_{reject}\)</span>.</p></li>
</ul>
<p>The <span><strong>language recognized by the Turing
machine</strong></span> <span class="math inline">\(M\)</span>, is <span
class="math display">\[\{ w \in \Sigma^* \mid \textrm{computation of $M$
on $w$ halts after entering the accept state}\} = \{ w \in \Sigma^* \mid
w \textrm{ is accepted by } M\}\]</span></p>
<p>An example Turing machine: <span class="math inline">\(\Sigma =
\phantom{\hspace{1in}}, \Gamma = \phantom{\hspace{1in}}\)</span> <span
class="math display">\[\delta ( ( q0, 0)  ) =\]</span></p>
<p><img src="../../resources/machines/Lect13TM1.png" style="width:2.5in"
alt="image" /></p>
<p>Formal definition:</p>
<p>Sample computation:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(q0\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>The language recognized by this machine is …</p>
<p><span><em>Extra practice:</em></span></p>
<p><img src="../../resources/machines/Lect13TM2.png" style="width:2in"
alt="image" /></p>
<p>Formal definition:</p>
<p>Sample computation:</p>
<p><span><em>Sipser Figure 3.10</em></span></p>
<p><span><strong>Conventions in state diagram of TM</strong></span>:
<span class="math inline">\(b \to R\)</span> label means <span
class="math inline">\(b \to b, R\)</span> and all arrows missing from
diagram represent transitions with output <span
class="math inline">\((q_{reject}, \textvisiblespace , R)\)</span></p>
<div class="multicols">
<p><span>2</span></p>
<div class="center">
<p><img src="../../resources/machines/Lect13TM3.png" style="width:4in"
alt="image" /></p>
</div>
<p>Implementation level description of this machine:</p>
<blockquote>
<p>Zig-zag across tape to corresponding positions on either side of
<span class="math inline">\(\#\)</span> to check whether the characters
in these positions agree. If they do not, or if there is no <span
class="math inline">\(\#\)</span>, reject. If they do, cross them
off.</p>
<p>Once all symbols to the left of the <span
class="math inline">\(\#\)</span> are crossed off, check for any
un-crossed-off symbols to the right of <span
class="math inline">\(\#\)</span>; if there are any, reject; if there
aren’t, accept.</p>
</blockquote>
<p>Computation on input string <span
class="math inline">\(01\#01\)</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(q_1
\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\#\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The language recognized by this machine is <span
class="math display">\[\{ w \# w \mid w \in \{0,1\}^* \}\]</span></p>
<p><span><em>Extra practice</em></span></p>
<p>Computation on input string <span
class="math inline">\(01\#1\)</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(q_1\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\#\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 class="unnumbered" id="week4-monday">Week4 monday</h1>
<p>Recap so far: In DFA, the only memory available is in the states.
Automata can only “remember” finitely far in the past and finitely much
information, because they can have only finitely many states. If a
computation path of a DFA visits the same state more than once, the
machine can’t tell the difference between the first time and future
times it visits this state. Thus, if a DFA accepts one long string, then
it must accept (infinitely) many similar strings.</p>
<p><span><strong>Definition</strong></span> A positive integer <span
class="math inline">\(p\)</span> is a <span><strong>pumping
length</strong></span> of a language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> means that, for each string <span
class="math inline">\(s  \in  \Sigma^*\)</span>, if <span
class="math inline">\(|s| \geq p\)</span> and <span
class="math inline">\(s \in L\)</span>, then there are strings <span
class="math inline">\(x,y,z\)</span> such that <span
class="math display">\[s = xyz\]</span> and <span
class="math display">\[|y| &gt; 0,  \qquad \qquad
\text{ for each $i \geq 0$, $xy^i z \in L$}, \qquad \text{and}
\qquad  \qquad
|xy| \leq p.\]</span></p>
<p><span><strong>Negation</strong></span>: A positive integer <span
class="math inline">\(p\)</span> is <span><strong>not a pumping
length</strong></span> of a language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> iff <span
class="math display">\[\exists s \left(~  |s| \geq  p \wedge s \in L
\wedge \forall x \forall y \forall z  \left( ~\left( s = xyz \wedge
|y| &gt; 0 \wedge |xy| \leq p~ \right) \to \exists i  (  i \geq
0  \wedge xy^iz  \notin L ) \right) ~\right)\]</span>
<span><em>Informally:</em> </span></p>
<p>Restating <span><strong>Pumping Lemma</strong></span>: If <span
class="math inline">\(L\)</span> is a regular language, then it has a
pumping length.</p>
<p><span><strong>Contrapositive</strong></span>: If <span
class="math inline">\(L\)</span> has no pumping length, then it is
nonregular.</p>
<p><span>The Pumping Lemma <span><em>cannot</em></span> be used to prove
that a language <span><em>is</em></span> regular.</span></p>
<p><span>The Pumping Lemma <span><strong>can</strong></span> be used to
prove that a language <span><em>is not</em></span> regular.</span></p>
<p><span><em>Extra practice</em></span>: Exercise 1.49 in the book.</p>
<p><span><strong>Proof strategy</strong></span>: To prove that a
language <span class="math inline">\(L\)</span> is
<span><strong>not</strong></span> regular,</p>
<ul>
<li><p>Consider an arbitrary positive integer <span
class="math inline">\(p\)</span></p></li>
<li><p>Prove that <span class="math inline">\(p\)</span> is not a
pumping length for <span class="math inline">\(L\)</span></p></li>
<li><p>Conclude that <span class="math inline">\(L\)</span> does not
have <span><em>any</em></span> pumping length, and therefore it is not
regular.</p></li>
</ul>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{ 0^n 1^n \mid n  \geq 0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{w w^{\mathcal{R}} \mid w \in
\{0,1\}^*\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{0^j1^k  \mid j \geq k  \geq
0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{0^n1^m0^n  \mid m,n  \geq 0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<h1 class="unnumbered" id="week4-wednesday">Week4 wednesday</h1>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Language</th>
<th style="text-align: center;"><span class="math inline">\(s \in
L\)</span></th>
<th style="text-align: center;"><span class="math inline">\(s \notin
L\)</span></th>
<th style="text-align: center;">Is the language regular or
nonregular?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{a^nb^n
\mid 0  \leq n  \leq 5 \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{b^n a^n
\mid  n  \geq 2\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  0 \leq m\leq n\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  m \geq n+3,  n \geq 0\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{b^m a^n
\mid  m \geq 1, n \geq  3\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{ w  \in
\{a,b\}^* \mid w = w^\mathcal{R} \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{
ww^\mathcal{R} \mid w\in \{a,b\}^* \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Regular sets are not the end of the story</p>
<ul>
<li><p>Many nice / simple / important sets are not regular</p></li>
<li><p>Limitation of the finite-state automaton model: Can’t "count",
Can only remember finitely far into the past, Can’t backtrack, Must make
decisions in "real-time"</p></li>
<li><p>We know actual computers are more powerful than this
model...</p></li>
</ul>
<p>The <span><strong>next</strong></span> model of computation. Idea:
allow some memory of unbounded size. How?</p>
<ul>
<li><p>To generalize regular expressions: <span><strong>context-free
grammars</strong></span><br />
</p></li>
<li><p>To generalize NFA: <span><strong>Pushdown
automata</strong></span>, which is like an NFA with access to a stack:
Number of states is fixed, number of entries in stack is unbounded. At
each step (1) Transition to new state based on current state, letter
read, and top letter of stack, then (2) (Possibly) push or pop a letter
to (or from) top of stack. Accept a string iff there is some sequence of
states and some sequence of stack contents which helps the PDA processes
the entire input string and ends in an accepting state.</p></li>
</ul>
<p><img src="../../resources/machines/Lect9PDA.png" style="width:4in"
alt="image" /></p>
<p>Trace the computation of this PDA on the input string <span
class="math inline">\(01\)</span>.</p>
<p>Trace the computation of this PDA on the input string <span
class="math inline">\(011\)</span>.</p>
<h1 class="unnumbered" id="week4-friday">Week4 friday</h1>
<p><span><strong>Definition</strong></span> A <span><strong>pushdown
automaton</strong></span> (PDA) is specified by a <span
class="math inline">\(6\)</span>-tuple <span class="math inline">\((Q,
\Sigma, \Gamma, \delta, q_0, F)\)</span> where <span
class="math inline">\(Q\)</span> is the finite set of states, <span
class="math inline">\(\Sigma\)</span> is the input alphabet, <span
class="math inline">\(\Gamma\)</span> is the stack alphabet, <span
class="math display">\[\delta: Q \times
\Sigma_\varepsilon  \times  \Gamma_\varepsilon \to \mathcal{P}( Q \times
\Gamma_\varepsilon)\]</span> is the transition function, <span
class="math inline">\(q_0 \in Q\)</span> is the start state, <span
class="math inline">\(F \subseteq  Q\)</span> is the set of accept
states.</p>
<div class="multicols">
<p><span>2</span> <span><em>Formal definition</em></span></p>
<p>Draw the state diagram of a PDA with <span
class="math inline">\(\Sigma = \Gamma\)</span>.</p>
<p><img src="../../resources/machines/Lect9PDA.png"
style="height:1.38889in" alt="image" /></p>
<p>Draw the state diagram of a PDA with <span
class="math inline">\(\Sigma \cap \Gamma = \emptyset\)</span>.</p>
</div>
<p>A PDA recognizing the set <span class="math inline">\(\{ \hspace{1.5
in} \}\)</span> can be informally described as:</p>
<blockquote>
<p>Read symbols from the input. As each 0 is read, push it onto the
stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If
the stack becomes empty and there is exactly one 1 left to read, read
that 1 and accept the input. If the stack becomes empty and there are
either zero or more than one 1s left to read, or if the 1s are finished
while the stack still contains 0s, or if any 0s appear in the input
following 1s, reject the input.</p>
</blockquote>
<p>State diagram for this PDA:</p>
<p>Consider the state diagram of a PDA with input alphabet <span
class="math inline">\(\Sigma\)</span> and stack alphabet <span
class="math inline">\(\Gamma\)</span>.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Label</th>
<th style="text-align: center;">means</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(a, b ;
c\)</span> when <span class="math inline">\(a \in \Sigma\)</span>, <span
class="math inline">\(b\in \Gamma\)</span>, <span
class="math inline">\(c \in \Gamma\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(a,
\varepsilon ; c\)</span> when <span class="math inline">\(a \in
\Sigma\)</span>, <span class="math inline">\(c \in \Gamma\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(a, b ;
\varepsilon\)</span> when <span class="math inline">\(a \in
\Sigma\)</span>, <span class="math inline">\(b\in \Gamma\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(a,
\varepsilon ; \varepsilon\)</span> when <span class="math inline">\(a
\in \Sigma\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>How does the meaning change if <span class="math inline">\(a\)</span>
is replaced by <span class="math inline">\(\varepsilon\)</span>?</p>
<p><span><em>Note: alternate notation is to replace <span
class="math inline">\(;\)</span> with <span
class="math inline">\(\to\)</span></em></span></p>
<p>For the PDA state diagrams below, <span class="math inline">\(\Sigma
= \{0,1\}\)</span>.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Mathematical description of
language</th>
<th style="text-align: center;">State diagram of PDA recognizing
language</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect10PDA1.png" style="width:3.5in"
alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect10PDA2.png" style="width:3.5in"
alt="image" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\{ 0^i 1^j
0^k \mid i,j,k \geq 0 \}\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week3-monday">Week3 monday</h1>
<p>The state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span> is below. The formal definition
of this NFA is:</p>
<p><img src="../../resources/machines/Lect5NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>The language recognized by this NFA is:</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N_1\)</span> such that <span
class="math inline">\(L(N_1) = A_1\)</span> and NFA <span
class="math inline">\(N_2\)</span> such that <span
class="math inline">\(L(N_2) = A_2\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Use nondeterminism to
choose which of <span class="math inline">\(N_1\)</span>, <span
class="math inline">\(N_2\)</span> to run.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\)</span>
and <span class="math inline">\(N_2 = (Q_2, \Sigma, \delta_2,q_2,
F_2)\)</span> and assume <span class="math inline">\(Q_1 \cap Q_2 =
\emptyset\)</span> and that <span class="math inline">\(q_0 \notin Q_1
\cup Q_2\)</span>. Construct <span class="math inline">\(N = (Q, \Sigma,
\delta, q_0, F_1 \cup F_2)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q =\)</span></p></li>
<li><p><span class="math inline">\(\delta: Q \times \Sigma_\varepsilon
\to \mathcal{P}(Q)\)</span> is defined by, for <span
class="math inline">\(q \in Q\)</span> and <span class="math inline">\(a
\in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\phantom{\delta((q,a))=\begin{cases}  \delta_1
((q,a)) &amp;\qquad\text{if } q\in Q_1 \\ \delta_2 ((q,a))
&amp;\qquad\text{if } q\in Q_2 \\ \{q1,q2\} &amp;\qquad\text{if } q =
q_0, a = \varepsilon \\ \emptyset\text{if } q= q_0, a \neq \varepsilon
\end{cases}}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span> by considering an
arbitrary string accepted by <span class="math inline">\(N\)</span>,
tracing an accepting computation of <span
class="math inline">\(N\)</span> on it, and using that trace to prove
the string is in at least one of <span
class="math inline">\(A_1\)</span>, <span
class="math inline">\(A_2\)</span>; then, taking an arbitrary string in
<span class="math inline">\(A_1 \cup A_2\)</span> and proving that it is
accepted by <span class="math inline">\(N\)</span>. Details left for
extra practice.</em></span></p>
<p>Over the alphabet <span class="math inline">\(\{a,b\}\)</span>, the
language <span class="math inline">\(L\)</span> described by the regular
expression <span class="math inline">\(\Sigma^* a \Sigma^*
b\)</span></p>
<p>includes the strings and excludes the strings</p>
<p>The state diagram of a NFA recognizing <span
class="math inline">\(L\)</span> is:</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N_1\)</span> such that <span
class="math inline">\(L(N_1) = A_1\)</span> and NFA <span
class="math inline">\(N_2\)</span> such that <span
class="math inline">\(L(N_2) = A_2\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A_1 \circ A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Allow computation to move
between <span class="math inline">\(N_1\)</span> and <span
class="math inline">\(N_2\)</span> “spontaneously" when reach an
accepting state of <span class="math inline">\(N_1\)</span>, guessing
that we’ve reached the point where the two parts of the string in the
set-wise concatenation are glued together.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\)</span>
and <span class="math inline">\(N_2 = (Q_2, \Sigma, \delta_2,q_2,
F_2)\)</span> and assume <span class="math inline">\(Q_1 \cap Q_2 =
\emptyset\)</span>. Construct <span class="math inline">\(N = (Q,
\Sigma, \delta, q_0, F)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q =\)</span></p></li>
<li><p><span class="math inline">\(q_0 =\)</span></p></li>
<li><p><span class="math inline">\(F =\)</span></p></li>
<li><p><span class="math inline">\(\delta: Q \times \Sigma_\varepsilon
\to \mathcal{P}(Q)\)</span> is defined by, for <span
class="math inline">\(q \in Q\)</span> and <span class="math inline">\(a
\in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\delta((q,a))=\begin{cases}  
                \delta_1 ((q,a)) &amp;\qquad\text{if } q\in Q_1 \textrm{
and } q \notin F_1\\
                \delta_1 ((q,a)) &amp;\qquad\text{if } q\in F_1 \textrm{
and } a \in \Sigma\\
                \delta_1 ((q,a)) \cup \{q_2\} &amp;\qquad\text{if } q\in
F_1 \textrm{ and } a = \varepsilon\\
                \delta_2 ((q,a)) &amp;\qquad\text{if } q\in Q_2
            \end{cases}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N) = A_1 \circ A_2\)</span> by considering an
arbitrary string accepted by <span class="math inline">\(N\)</span>,
tracing an accepting computation of <span
class="math inline">\(N\)</span> on it, and using that trace to prove
the string can be written as the result of concatenating two strings,
the first in <span class="math inline">\(A_1\)</span> and the second in
<span class="math inline">\(A_2\)</span>; then, taking an arbitrary
string in <span class="math inline">\(A_1 \circ A_2\)</span> and proving
that it is accepted by <span class="math inline">\(N\)</span>. Details
left for extra practice.</em></span></p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N\)</span> such that <span
class="math inline">\(L(N) = A\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N&#39;\)</span>, such that
<span class="math inline">\(L(N&#39;) = A^*\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Add a fresh start state,
which is an accept state. Add spontaneous moves from each (old) accept
state to the old start state.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N = (Q, \Sigma, \delta, q_1, F)\)</span> and
assume <span class="math inline">\(q_0 \notin Q\)</span>. Construct
<span class="math inline">\(N&#39; = (Q&#39;, \Sigma, \delta&#39;, q_0,
F&#39;)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q&#39; = Q \cup
\{q_0\}\)</span></p></li>
<li><p><span class="math inline">\(F&#39; = F \cup
\{q_0\}\)</span></p></li>
<li><p><span class="math inline">\(\delta&#39;: Q&#39; \times
\Sigma_\varepsilon \to \mathcal{P}(Q&#39;)\)</span> is defined by, for
<span class="math inline">\(q \in Q&#39;\)</span> and <span
class="math inline">\(a \in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\delta&#39;((q,a))=\begin{cases}  
                \delta ((q,a)) &amp;\qquad\text{if } q\in Q \textrm{ and
} q \notin F\\
                \delta ((q,a)) &amp;\qquad\text{if } q\in F \textrm{ and
} a \in \Sigma\\
                \delta ((q,a)) \cup \{q_1\} &amp;\qquad\text{if } q\in F
\textrm{ and } a = \varepsilon\\
                \{q_1\} &amp;\qquad\text{if } q = q_0 \textrm{ and } a =
\varepsilon \\
                \emptyset &amp;\qquad\text{if } q = q_0 \textrm { and }
a \in \Sigma
            \end{cases}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N&#39;) = A^*\)</span> by considering an
arbitrary string accepted by <span
class="math inline">\(N&#39;\)</span>, tracing an accepting computation
of <span class="math inline">\(N&#39;\)</span> on it, and using that
trace to prove the string can be written as the result of concatenating
some number of strings, each of which is in <span
class="math inline">\(A\)</span>; then, taking an arbitrary string in
<span class="math inline">\(A^*\)</span> and proving that it is accepted
by <span class="math inline">\(N&#39;\)</span>. Details left for extra
practice.</em></span></p>
<p><span><strong>Application</strong></span>: A state diagram for a NFA
over <span class="math inline">\(\Sigma = \{a,b\}\)</span> that
recognizes <span class="math inline">\(L (( \Sigma^* b)^*
)\)</span>:</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The state diagram of any DFA is
also the state diagram of a NFA.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The state diagram of any NFA is
also the state diagram of a DFA.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The formal definition <span
class="math inline">\((Q, \Sigma, \delta, q_0, F)\)</span> of any DFA is
also the formal definition of a NFA.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The formal definition <span
class="math inline">\((Q, \Sigma, \delta, q_0, F)\)</span> of any NFA is
also the formal definition of a DFA.</p>
<h1 class="unnumbered" id="week3-wednesday">Week3 wednesday</h1>
<p>Consider the state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span>:</p>
<p><img src="../../resources/machines/Lect6NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>The language recognized by this NFA is</p>
<p>The state diagram of a DFA recognizing this same language is:</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N\)</span> such that <span
class="math inline">\(L(N) = A\)</span> then there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: States in <span
class="math inline">\(M\)</span> are “macro-states" – collections of
states from <span class="math inline">\(N\)</span> – that represent the
set of possible states a computation of <span
class="math inline">\(N\)</span> might be in.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N = (Q, \Sigma, \delta, q_0, F)\)</span>. Define
<span class="math display">\[M = (~ \mathcal{P}(Q), \Sigma, \delta&#39;,
q&#39;,  \{ X \subseteq Q \mid X \cap F \neq \emptyset \}~ )\]</span>
where <span class="math inline">\(q&#39; = \{ q \in Q \mid \text{$q =
q_0$ or is accessible from $q_0$ by spontaneous moves in $N$}
\}\)</span> and <span class="math display">\[\delta&#39; (~(X, x)~) = \{
q \in Q \mid q \in \delta( ~(r,x)~) ~\text{for some $r \in X$ or is
accessible
from such an $r$ by spontaneous moves in $N$} \}\]</span></p>
<p>Consider the state diagram of an NFA over <span
class="math inline">\(\{0,1\}\)</span>. Use the “macro-state”
construction to find an equivalent DFA.</p>
<p><img src="../../resources/machines/Lect6NFA2.png" style="width:1.8in"
alt="image" /></p>
<p>Prune this diagram to get an equivalent DFA with only the
“macro-states" reachable from the start state.</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a regular expression
<span class="math inline">\(R\)</span> such that <span
class="math inline">\(L(R) = A\)</span>, then there is a NFA, let’s call
it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A\)</span>.</p>
<p><span><strong>Structural induction</strong></span>: Regular
expression is built from basis regular expressions using inductive steps
(union, concatenation, Kleene star symbols). Use constructions to mirror
these in NFAs.</p>
<p><span><strong>Application</strong></span>: A state diagram for a NFA
over <span class="math inline">\(\{a,b\}\)</span> that recognizes <span
class="math inline">\(L(a^* (ab)^*)\)</span>:</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span>, then there is a regular
expression, let’s call it <span class="math inline">\(R\)</span>, such
that <span class="math inline">\(L(R) = A\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Trace all possible paths
from start state to accept state. Express labels of these paths as
regular expressions, and union them all.</p>
<ol>
<li><p>Add new start state with <span
class="math inline">\(\varepsilon\)</span> arrow to old start
state.</p></li>
<li><p>Add new accept state with <span
class="math inline">\(\varepsilon\)</span> arrow from old accept states.
Make old accept states non-accept.</p></li>
<li><p>Remove one (of the old) states at a time: modify regular
expressions on arrows that went through removed state to restore
language recognized by machine.</p></li>
</ol>
<p><span><strong>Application</strong></span>: Find a regular expression
describing the language recognized by the DFA with state diagram</p>
<p><img src="../../resources/machines/Lect6NFA3.png" style="width:2.5in"
alt="image" /></p>
<p><span><strong>Conclusion</strong></span>: For each language <span
class="math inline">\(L\)</span>,</p>
<div class="center">
<p><span><strong>There is a DFA that recognizes <span
class="math inline">\(L\)</span> <span class="math inline">\(\exists M
~(M \textrm{ is a DFA and } L(M) = A)\)</span></strong></span><br />
<span><strong>if and only if</strong></span><br />
<span><strong>There is a NFA that recognizes <span
class="math inline">\(L\)</span> <span class="math inline">\(\exists N
~(N \textrm{ is a NFA and } L(N) = A)\)</span></strong></span><br />
<span><strong>if and only if</strong></span><br />
<span><strong>There is a regular expression that describes <span
class="math inline">\(L\)</span> <span class="math inline">\(\exists R
~(R \textrm{ is a regular expression and } L(R) =
A)\)</span></strong></span><br />
</p>
</div>
<p>A language is called <span><strong>regular</strong></span> when any
(hence all) of the above three conditions are met.</p>
<h1 class="unnumbered" id="week3-friday">Week3 friday</h1>
<p><span><strong>Theorem</strong></span>: For an alphabet <span
class="math inline">\(\Sigma\)</span>, For each language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span>,</p>
<div class="center">
<p><span class="math inline">\(L\)</span> is recognized by some
DFA<br />
iff<br />
<span class="math inline">\(L\)</span> is recognized by some NFA<br />
iff<br />
<span class="math inline">\(L\)</span> is described by some regular
expression</p>
</div>
<p>If (any, hence all) these conditions apply, <span
class="math inline">\(L\)</span> is called
<span><strong>regular</strong></span>.</p>
<p><span><strong>Prove or Disprove</strong></span>: There is some
alphabet <span class="math inline">\(\Sigma\)</span> for which there is
some language recognized by an NFA but not by any DFA.</p>
<p><span><strong>Prove or Disprove</strong></span>: There is some
alphabet <span class="math inline">\(\Sigma\)</span> for which there is
some finite language not described by any regular expression over <span
class="math inline">\(\Sigma\)</span>.</p>
<p><span><strong>Prove or Disprove</strong></span>: If a language is
recognized by an NFA then the complement of this language is not
recognized by any DFA.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Set</th>
<th style="text-align: center;">Cardinality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\{0,1\}^*\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\mathcal{P}(
\{0,1\})\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">The set of all languages over <span
class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">The set of all regular expressions over
<span class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">The set of all regular languages over
<span class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Pumping Lemma</strong></span> (Sipser Theorem 1.70): If
<span class="math inline">\(A\)</span> is a regular language, then there
is a number <span class="math inline">\(p\)</span> (a <span><em>pumping
length</em></span>) where, if <span class="math inline">\(s\)</span> is
any string in <span class="math inline">\(A\)</span> of length at least
<span class="math inline">\(p\)</span>, then <span
class="math inline">\(s\)</span> may be divided into three pieces, <span
class="math inline">\(s = xyz\)</span> such that</p>
<ul>
<li><p><span class="math inline">\(|y| &gt; 0\)</span></p></li>
<li><p>for each <span class="math inline">\(i \geq 0\)</span>, <span
class="math inline">\(xy^i z \in A\)</span></p></li>
<li><p><span class="math inline">\(|xy| \leq p\)</span>.</p></li>
</ul>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{ 0,1 \}^*\)</span> is <span
class="math inline">\(p = 5\)</span>.</p>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{1, 01, 001, 0001, 00001 \}\)</span> is
<span class="math inline">\(p = 4\)</span>.</p>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{0^j 1 \mid  j \geq 0 \}\)</span> is
<span class="math inline">\(p = 3\)</span>.</p>
<p><span><strong>True or False</strong></span>: For any language <span
class="math inline">\(A\)</span>, if <span
class="math inline">\(p\)</span> is a pumping length for <span
class="math inline">\(A\)</span> and <span class="math inline">\(p&#39;
&gt; p\)</span>, then <span class="math inline">\(p&#39;\)</span> is
also a pumping length for <span class="math inline">\(A\)</span>.</p>
<h1 class="unnumbered" id="week2-monday">Week2 monday</h1>
<p><span><strong>Review</strong></span>: Formal definition of DFA: <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span></p>
<div class="center">
<div class="multicols">
<p><span>2</span></p>
<ul>
<li><p>Finite set of states <span
class="math inline">\(Q\)</span></p></li>
<li><p>Alphabet <span class="math inline">\(\Sigma\)</span></p></li>
<li><p>Transition function <span
class="math inline">\(\delta\)</span></p></li>
<li><p>Start state <span class="math inline">\(q_0\)</span></p></li>
<li><p>Accept (final) states <span
class="math inline">\(F\)</span></p></li>
</ul>
</div>
</div>
<p>In the state diagram of <span class="math inline">\(M\)</span>, how
many outgoing arrows are there from each state?</p>
<p><span class="math inline">\(M = ( \{ q, r, s\}, \{a,b\}, \delta, q,
\{s\} )\)</span> where <span class="math inline">\(\delta\)</span> is
(rows labelled by states and columns labelled by symbols):</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(\delta\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(a\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(b\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The state diagram for <span class="math inline">\(M\)</span> is</p>
<p>Give two examples of strings that are accepted by <span
class="math inline">\(M\)</span> and two examples of strings that are
rejected by <span class="math inline">\(M\)</span>:</p>
<p>Add “labels" for states in the state diagram, e.g. “have not seen any
of desired pattern yet” or “sink state”.</p>
<p>We can use the analysis of the roles of the states in the state
diagram to describe the language recognized by the DFA.</p>
<p><span class="math inline">\(L(M) =\)</span></p>
<p>A regular expression describing <span
class="math inline">\(L(M)\)</span> is</p>
<p>Let the alphabet be <span class="math inline">\(\Sigma_1 =
\{0,1\}\)</span>.</p>
<p>A state diagram for a DFA that recognizes <span
class="math inline">\(\{w \mid w~\text{contains at most two $1$&#39;s}
\}\)</span> is</p>
<p>A state diagram for a DFA that recognizes <span
class="math inline">\(\{w \mid w~\text{contains more than two $1$&#39;s}
\}\)</span> is</p>
<p><span><em>Extra example:</em></span> A state diagram for DFA
recognizing <span class="math display">\[\{w \mid w~\text{is a string
over $\{0,1\}$ whose length is not a multiple of $3$} \}\]</span></p>
<p>Let <span class="math inline">\(n\)</span> be an arbitrary positive
integer. What is a formal definition for a DFA recognizing <span
class="math display">\[\{w \mid w~\text{is a string over $\{0,1\}$ whose
length is not a multiple of $n$} \}?\]</span></p>
<h1 class="unnumbered" id="week2-wednesday">Week2 wednesday</h1>
<p>Suppose A is a language over an alphabet <span
class="math inline">\(\Sigma\)</span>. By definition, this means A is a
subset of <span class="math inline">\(\Sigma^*\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span> then there is another DFA, let’s
call it <span class="math inline">\(M&#39;\)</span>, such that <span
class="math inline">\(L(M&#39;) = \overline{A}\)</span>, the complement
of <span class="math inline">\(A\)</span>, defined as <span
class="math inline">\(\{ w \in \Sigma^* \mid w \notin A \}\)</span>.</p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Proof</strong></span>:</p>
<p>A useful (optional) bit of terminology: the <span><strong>iterated
transition function</strong></span> of a DFA <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> is
defined recursively by <span class="math display">\[\delta^* (~(q,w)~)
=\begin{cases}
q  \qquad &amp;\text{if $q \in Q, w = \varepsilon$} \\
\delta( ~(q,a)~) \qquad &amp;\text{if $q \in Q$, $w = a \in \Sigma$ } \\
\delta(~(\delta^*(q,u), a) ~) \qquad &amp;\text{if $q \in Q$, $w = ua$
where $u \in  \Sigma^*$ and $a \in \Sigma$}
\end{cases}\]</span></p>
<p>Using this terminology, <span class="math inline">\(M\)</span>
accepts a string <span class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> if and only if <span
class="math inline">\(\delta^*( ~(q_0,w)~) \in F\)</span>.</p>
<p>Fix <span class="math inline">\(\Sigma = \{a,b\}\)</span>. A state
diagram for a DFA that recognizes <span class="math inline">\(\{w \mid
w~\text{has $ab$ as a substring and is of even length} \}\)</span>:</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cap A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
<p><span><strong>Application</strong></span>: When <span
class="math inline">\(A_1 = \{w \mid w~\text{has $ab$ as a substring}
\}\)</span> and <span class="math inline">\(A_2 = \{ w \mid w~\text{is
of even length} \}\)</span>.</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cup A_2\)</span>. <span><em>Sipser
Theorem 1.25, page 45</em></span></p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
<p><span><strong>Application</strong></span>: A state diagram for a DFA
that recognizes <span class="math inline">\(\{w \mid w~\text{has $ab$ as
a substring or is of even length} \}\)</span>:</p>
<h1 class="unnumbered" id="week2-friday">Week2 friday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td colspan="2" style="text-align: left;"><span><strong>Nondeterministic
finite automaton</strong></span> <span class="math inline">\(M = (Q,
\Sigma, \delta, q_0, F)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Finite set of states <span
class="math inline">\(Q\)</span></td>
<td style="text-align: left;">Can be labelled by any collection of
distinct names. Default: <span class="math inline">\(q0, q1,
\ldots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Alphabet <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">Each input to the automaton is a string
over <span class="math inline">\(\Sigma\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Arrow labels <span
class="math inline">\(\Sigma_\varepsilon\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\Sigma_\varepsilon = \Sigma \cup \{
\varepsilon\}\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Arrows in the state diagram are labelled
either by symbols from <span class="math inline">\(\Sigma\)</span> or by
<span class="math inline">\(\varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Transition function <span
class="math inline">\(\delta\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\delta: Q
\times \Sigma_{\varepsilon} \to \mathcal{P}(Q)\)</span> gives the
<span><strong>set of possible next states</strong></span> for a
transition</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">from the current state upon reading a
symbol or spontaneously moving.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Start state <span
class="math inline">\(q_0\)</span></td>
<td style="text-align: left;">Element of <span
class="math inline">\(Q\)</span>. Each computation of the machine starts
at the start state.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Accept (final) states <span
class="math inline">\(F\)</span></td>
<td style="text-align: left;"><span class="math inline">\(F
\subseteq  Q\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(M\)</span>
accepts the input string</td>
<td style="text-align: left;">if and only if <span><strong>there
is</strong></span> a computation of <span
class="math inline">\(M\)</span> on the input string</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">that processes the whole string and ends
in an accept state.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><em>Page 53</em></span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p>The formal definition of the NFA over <span
class="math inline">\(\{0,1\}\)</span> given by this state diagram
is:</p>
<p><img src="../../resources/machines/Lect4NFA1.png" style="width:2in"
alt="image" /></p>
<p>The language over <span class="math inline">\(\{0,1\}\)</span>
recognized by this NFA is:</p>
<p>Change the transition function to get a different NFA which accepts
the empty string.</p>
<p>The state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span> is below. The formal definition
of this NFA is:</p>
<p><img src="../../resources/machines/Lect5NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>The language recognized by this NFA is:</p>
<h1 class="unnumbered" id="week1-monday">Week1 monday</h1>
<p>We will use vocabulary that should be familiar from your discrete
math and introduction to proofs classes. Some of the notation
conventions may be a bit different: we will use the notation from this
class’ textbook<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>Write out in words the meaning of the symbols below: <span
class="math display">\[\{ a,b, c\}\]</span></p>
<p><span class="math display">\[| \{a, b, a \} | = 2\]</span></p>
<p><span class="math display">\[| aba | = 3\]</span></p>
<p><span class="math display">\[(a, 3, 2, b, b)\]</span></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Term</th>
<th style="text-align: center;">Typical symbol</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Alphabet</td>
<td style="text-align: center;"><span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\Gamma\)</span></td>
<td style="text-align: left;">A non-empty finite set</td>
</tr>
<tr class="even">
<td style="text-align: left;">Symbol over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\sigma\)</span>, <span
class="math inline">\(b\)</span>, <span
class="math inline">\(x\)</span></td>
<td style="text-align: left;">An element of the alphabet <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">String over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(u\)</span>,
<span class="math inline">\(v\)</span>, <span
class="math inline">\(w\)</span></td>
<td style="text-align: left;">A finite list of symbols from <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">The set of all strings over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\Sigma^*\)</span></td>
<td style="text-align: left;">The collection of all possible strings
formed from symbols from <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">(Some) language over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(L\)</span></td>
<td style="text-align: left;">(Some) set of strings over <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Empty string</td>
<td style="text-align: center;"><span
class="math inline">\(\varepsilon\)</span></td>
<td style="text-align: left;">The string of length <span
class="math inline">\(0\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Empty set</td>
<td style="text-align: center;"><span
class="math inline">\(\emptyset\)</span></td>
<td style="text-align: left;">The empty language</td>
</tr>
<tr class="even">
<td style="text-align: left;">Natural numbers</td>
<td style="text-align: center;"><span
class="math inline">\(\mathcal{N}\)</span></td>
<td style="text-align: left;">The set of positive integers</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Finite set</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">The empty set or a set whose distinct
elements can be counted by a natural number</td>
</tr>
<tr class="even">
<td style="text-align: left;">Infinite set</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">A set that is not finite.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><em>Pages 3, 4, 13, 14</em>
</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Term</th>
<th style="text-align: center;">Notation</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Reverse of a string <span
class="math inline">\(w\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(w^\mathcal{R}\)</span></td>
<td style="text-align: left;">write <span
class="math inline">\(w\)</span> in the opposite order, if <span
class="math inline">\(w = w_1 \cdots  w_n\)</span> then <span
class="math inline">\(w^\mathcal{R} = w_n \cdots  w_1\)</span>. Note:
<span class="math inline">\(\varepsilon^\mathcal{R} =
\varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Concatenating strings <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(xy\)</span></td>
<td style="text-align: left;">take <span class="math inline">\(x = x_1
\cdots x_m\)</span>, <span class="math inline">\(y=y_1 \cdots
y_n\)</span> and form <span class="math inline">\(xy = x_1 \cdots x_m
y_1 \cdots y_n\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">String <span
class="math inline">\(z\)</span> is a substring of string <span
class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">there are strings <span
class="math inline">\(u,v\)</span> such that <span
class="math inline">\(w = uzv\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">String <span
class="math inline">\(x\)</span> is a prefix of string <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">there is a string <span
class="math inline">\(z\)</span> such that <span class="math inline">\(y
= xz\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">String <span
class="math inline">\(x\)</span> is a proper prefix of string <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(x\)</span> is
a prefix of <span class="math inline">\(y\)</span> and <span
class="math inline">\(x \neq y\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Shortlex order, also known as string order
over alphabet <span class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Order strings over <span
class="math inline">\(\Sigma\)</span> first by length and then according
to the dictionary order, assuming symbols in <span
class="math inline">\(\Sigma\)</span> have an ordering.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><em>Pages 13, 14</em></span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><em>Circle the correct choice</em></span>:</p>
<p>A <span><strong>string</strong></span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is <u>  an element of <span
class="math inline">\(\Sigma^*\)</span>    OR    a subset of <span
class="math inline">\(\Sigma^*\)</span></u>.</p>
<p>A <span><strong>language</strong></span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is <u>  an element of <span
class="math inline">\(\Sigma^*\)</span>    OR    a subset of <span
class="math inline">\(\Sigma^*\)</span></u>.</p>
<p><span><em>Extra examples for practice:</em></span></p>
<p>With <span class="math inline">\(\Sigma_1 = \{0,1\}\)</span> and
<span class="math inline">\(\Sigma_2 =
\{a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\}\)</span> and
<span class="math inline">\(\Gamma = \{0,1,x,y,z\}\)</span></p>
<p>An example of a string of length 3 over <span
class="math inline">\(\Sigma_1\)</span> is <u> </u></p>
<p>An example of a string of length 1 over <span
class="math inline">\(\Sigma_2\)</span> is <u> </u></p>
<p>The number of distinct strings of length 2 over <span
class="math inline">\(\Gamma\)</span> is <u> </u></p>
<p>An example of a language over <span
class="math inline">\(\Sigma_1\)</span> of size <span
class="math inline">\(1\)</span> is <u> </u></p>
<p>An example of an infinite language over <span
class="math inline">\(\Sigma_1\)</span> is <u> </u></p>
<p>An example of a finite language over <span
class="math inline">\(\Gamma\)</span> is <u> </u></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon \in \Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a string over <span
class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a language over <span
class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a prefix of some string
over <span class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: There is a string over <span
class="math inline">\(\Sigma_1\)</span> that is a proper prefix of <span
class="math inline">\(\varepsilon\)</span></p>
<p>The first five strings over <span
class="math inline">\(\Sigma_1\)</span> in string order, using the
ordering <span class="math inline">\(0 &lt;  1\)</span>:</p>
<p>The first five strings over <span
class="math inline">\(\Sigma_2\)</span> in string order, using the usual
alphabetical ordering for single letters:</p>
<h1 class="unnumbered" id="week1-wednesday">Week1 wednesday</h1>
<p>Our motivation in studying sets of strings is that they encode
problems.</p>
<p>We need to describe the collection of all strings that match the
pattern or property of a problem.</p>
<p>Let’s start by thinking about how we can describe a language (a set
of strings from a given alphabet).</p>
<p><span><strong>Definition 1.52</strong></span>: A
<span><strong>regular expression</strong></span> over alphabet <span
class="math inline">\(\Sigma\)</span> is a syntactic expression that can
describe a language over <span class="math inline">\(\Sigma\)</span>.
The collection of all regular expressions is defined recursively:</p>
<ul>
<li><p><span><em>Basis steps of recursive definition</em></span></p>
<blockquote>
<p><span class="math inline">\(a\)</span> is a regular expression, for
<span class="math inline">\(a \in \Sigma\)</span></p>
<p><span class="math inline">\(\varepsilon\)</span> is a regular
expression</p>
<p><span class="math inline">\(\emptyset\)</span> is a regular
expression</p>
</blockquote></li>
<li><p><span><em>Recursive steps of recursive definition</em></span></p>
<blockquote>
<p><span class="math inline">\((R_1 \cup R_2)\)</span> is a regular
expression when <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions</p>
<p><span class="math inline">\((R_1 \circ R_2)\)</span> is a regular
expression when <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions</p>
<p><span class="math inline">\((R_1^*)\)</span> is a regular expression
when <span class="math inline">\(R_1\)</span> is a regular
expression</p>
</blockquote></li>
</ul>
<p>The <span><em>semantics</em></span> (or meaning) of the syntactic
regular expression is the <span><strong>language described by the
regular expression</strong></span>. The function that assigns a language
to a regular expression over <span class="math inline">\(\Sigma\)</span>
is defined recursively, using familiar set operations:</p>
<ul>
<li><p><span><em>Basis steps of recursive definition</em></span></p>
<blockquote>
<p>The language described by <span class="math inline">\(a\)</span>, for
<span class="math inline">\(a \in \Sigma\)</span>, is <span
class="math inline">\(\{a\}\)</span> and we write <span
class="math inline">\(L(a) = \{a\}\)</span></p>
<p>The language described by <span
class="math inline">\(\varepsilon\)</span> is <span
class="math inline">\(\{\varepsilon\}\)</span> and we write <span
class="math inline">\(L(\varepsilon) = \{ \varepsilon\}\)</span></p>
<p>The language described by <span
class="math inline">\(\emptyset\)</span> is <span
class="math inline">\(\{\}\)</span> and we write <span
class="math inline">\(L(\emptyset) = \emptyset\)</span>.</p>
</blockquote></li>
<li><p><span><em>Recursive steps of recursive definition</em></span></p>
<blockquote>
<p>When <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions, the language
described by the regular expression <span class="math inline">\((R_1
\cup R_2)\)</span> is the union of the languages described by <span
class="math inline">\(R_1\)</span> and <span
class="math inline">\(R_2\)</span>, and we write <span
class="math display">\[L(~(R_1 \cup R_2)~) = L(R_1) \cup L(R_2) = \{ w
\mid w \in L(R_1) \lor w \in L(R_2)\}\]</span></p>
<p>When <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions, the language
described by the regular expression <span class="math inline">\((R_1
\circ R_2)\)</span> is the concatenation of the languages described by
<span class="math inline">\(R_1\)</span> and <span
class="math inline">\(R_2\)</span>, and we write <span
class="math display">\[L(~(R_1 \circ R_2)~) = L(R_1) \circ L(R_2) = \{
uv \mid u \in L(R_1) \land v \in L(R_2)\}\]</span></p>
<p>When <span class="math inline">\(R_1\)</span> is a regular
expression, the language described by the regular expression <span
class="math inline">\((R_1^*)\)</span> is the <span><strong>Kleene
star</strong></span> of the language described by <span
class="math inline">\(R_1\)</span> and we write <span
class="math display">\[L(~(R_1^*)~) = (~L(R_1)~)^* = \{ w_1 \cdots w_k
\mid k \geq 0 \textrm{ and each } w_i \in L(R_1)\}\]</span></p>
</blockquote></li>
</ul>
<p>For the following examples assume the alphabet is <span
class="math inline">\(\Sigma_1 =  \{0,1\}\)</span>:</p>
<p>The language described by the regular expression <span
class="math inline">\(0\)</span> is <span class="math inline">\(L(0) =
\{ 0 \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(1\)</span> is <span class="math inline">\(L(1)  =
\{ 1 \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(\varepsilon\)</span> is <span
class="math inline">\(L(\varepsilon) = \{ \varepsilon  \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(\emptyset\)</span> is <span
class="math inline">\(L(\emptyset) = \emptyset\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(((0 \cup 1) \cup 1)\)</span> is <span
class="math inline">\(L(~((0 \cup 1) \cup 1)~) =\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(1^+\)</span> is <span
class="math inline">\(L(~(1)^+~) =\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(\Sigma_1^* 1\)</span> is <span
class="math inline">\(L(~\Sigma_1^* 1~) =\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\((\Sigma_1 \Sigma_1 \Sigma_1 \Sigma_1
\Sigma_1)^*\)</span> is <span class="math inline">\(L(~(\Sigma_1
\Sigma_1 \Sigma_1 \Sigma_1 \Sigma_1)^*~) =\)</span></p>
<p>A regular expression that describes the language <span
class="math inline">\(\{00, 01, 10, 11\}\)</span> is</p>
<p>A regular expression that describes the language <span
class="math inline">\(\{ 0^n1 \mid n~\text{is even} \}\)</span> is</p>
<p><span><em>Shorthand and conventions</em></span></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th colspan="2" style="text-align: left;">Assuming <span
class="math inline">\(\Sigma\)</span> is the alphabet, we use the
following conventions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">regular expression describing language
consisting of all strings of length <span
class="math inline">\(1\)</span> over <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(*\)</span>
then <span class="math inline">\(\circ\)</span> then <span
class="math inline">\(\cup\)</span></td>
<td style="text-align: left;">precedence order, unless parentheses are
used to change it</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span
class="math inline">\(R_1R_2\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R_1  \circ R_2\)</span> (concatenation symbol is
implicit)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span
class="math inline">\(R^+\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R^* \circ R\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span
class="math inline">\(R^k\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R\)</span> concatenated with itself <span
class="math inline">\(k\)</span> times, where <span
class="math inline">\(k\)</span> is a natural number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><em>Pages 63 - 65</em> </span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Caution: many programming languages that support
regular expressions build in functionality that is more powerful than
the “pure” definition of regular expressions given here.</strong>
</span></p>
<p>Regular expressions are everywhere (once you start looking for
them).</p>
<p>Software tools and languages often have built-in support for regular
expressions to describe <span><strong>patterns</strong></span> that we
want to match (e.g. Excel/ Sheets, grep, Perl, python, Java, Ruby).</p>
<p>Under the hood, the first phase of
<span><strong>compilers</strong></span> is to transform the strings we
write in code to tokens (keywords, operators, identifiers, literals).
Compilers use regular expressions to describe the sets of strings that
can be used for each token type.</p>
<p>Next time: we’ll start to see how to build machines that decide
whether strings match the pattern described by a regular expression.</p>
<p><span><em>Extra examples for practice:</em></span></p>
<p>Which regular expression(s) below describe a language that includes
the string <span class="math inline">\(a\)</span> as an element?</p>
<p><span class="math inline">\(a^* b^*\)</span></p>
<p><span class="math inline">\(a(ba)^* b\)</span></p>
<p><span class="math inline">\(a^* \cup b^*\)</span></p>
<p><span class="math inline">\((aaa)^*\)</span></p>
<p><span class="math inline">\((\varepsilon \cup a) b\)</span></p>
<h1 class="unnumbered" id="week1-friday">Week1 friday</h1>
<p><span><strong>Review</strong></span>: Determine whether each
statement below about regular expressions over the alphabet <span
class="math inline">\(\{a,b,c\}\)</span> is true or false:</p>
<p>True or False: <span class="math inline">\(a  \in L(~(a \cup b )~\cup
c)\)</span></p>
<p>True or False: <span class="math inline">\(ab  \in L(~ (a \cup
b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(ba \in L( ~ a^* b^*
~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(a \cup
b \cup c)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(~ (a
\cup b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon \in L( ~ a^*
b^* ~)\)</span></p>
<p><span><strong>From the pre-class reading, pages
34-36</strong></span>: A deterministic finite automaton (DFA) is
specified by <span class="math inline">\(M = (Q, \Sigma, \delta, q_0,
F)\)</span>. This <span class="math inline">\(5\)</span>-tuple is called
the <span><strong>formal definition</strong></span> of the DFA. The DFA
can also be represented by its state diagram: with nodes for the state,
labelled edges specifying the transition function, and decorations on
nodes denoting the start and accept states.</p>
<blockquote>
<p>Finite set of states <span class="math inline">\(Q\)</span> can be
labelled by any collection of distinct names. Often we use default state
labels <span class="math inline">\(q0, q1, \ldots\)</span></p>
</blockquote>
<blockquote>
<p>The alphabet <span class="math inline">\(\Sigma\)</span> determines
the possible inputs to the automaton. Each input to the automaton is a
string over <span class="math inline">\(\Sigma\)</span>, and the
automaton “processes” the input one symbol (or character) at a time.</p>
</blockquote>
<blockquote>
<p>The transition function <span class="math inline">\(\delta\)</span>
gives the next state of the DFA based on the current state of the
machine and on the next input symbol.</p>
</blockquote>
<blockquote>
<p>The start state <span class="math inline">\(q_0\)</span> is an
element of <span class="math inline">\(Q\)</span>. Each computation of
the machine starts at the start state.</p>
</blockquote>
<blockquote>
<p>The accept (final) states <span class="math inline">\(F\)</span> form
a subset of the states of the DFA, <span class="math inline">\(F
\subseteq  Q\)</span>. These states are used to flag if the machine
accepts or rejects an input string.</p>
</blockquote>
<blockquote>
<p>The computation of a machine on an input string is a sequence of
states in the machine, starting with the start state, determined by
transitions of the machine as it reads successive input symbols.</p>
</blockquote>
<blockquote>
<p>The DFA <span class="math inline">\(M\)</span> accepts the given
input string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in an accept
state. <span class="math inline">\(M\)</span> rejects the given input
string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in a nonaccept
state, that is, a state that is not in <span
class="math inline">\(F\)</span>.</p>
</blockquote>
<blockquote>
<p>The language of <span class="math inline">\(M\)</span>, <span
class="math inline">\(L(M)\)</span>, is defined as the set of all
strings that are each accepted by the machine <span
class="math inline">\(M\)</span>. Each string that is rejected by <span
class="math inline">\(M\)</span> is not in <span
class="math inline">\(L(M)\)</span>. The language of <span
class="math inline">\(M\)</span> is also called the language recognized
by <span class="math inline">\(M\)</span>.</p>
</blockquote>
<p>What is <span><strong>finite</strong></span> about all deterministic
finite automata? (Select all that apply)</p>
<ul>
<li><p>The size of the machine (number of states, number of
arrows)</p></li>
<li><p>The number of strings that are accepted by the machine</p></li>
<li><p>The length of each computation of the machine</p></li>
</ul>
<figure>
<img src="../../resources/machines/Lect2DFA1.png" style="width:3in" />
</figure>
<p>The formal definition of this DFA is</p>
<p>Classify each string <span class="math inline">\(a, aa, ab, ba, bb,
\varepsilon\)</span> as accepted by the DFA or rejected by the DFA.</p>
<p><span><em>Why are these the only two options?</em></span></p>
<p>The language recognized by this DFA is</p>
<figure>
<img src="../../resources/machines/Lect2DFA2.png" style="width:3in" />
</figure>
<p>The language recognized by this DFA is</p>
<figure>
<img src="../../resources/machines/Lect2DFA3.png" style="width:3in" />
</figure>
<p>The language recognized by this DFA is</p>
<h1 class="unnumbered" id="week10-friday">Week10 friday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Model of
Computation</strong></span></td>
<td style="text-align: left;"><span><strong>Class of
Languages</strong></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Deterministic finite
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Nondeterministic finite automata</strong></span>: formal
definition, how to design for a given language, how to describe language
of a machine? <span><strong>Regular expressions</strong></span>: formal
definition, how to design for a given language, how to describe language
of expression? <span><em>Also</em></span>: converting between different
models.</td>
<td style="text-align: left;"><span><strong>Class of regular
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using <span><strong>pumping
lemma</strong></span> to prove nonregularity.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Push-down
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Context-free grammars</strong></span>: formal definition,
how to design for a given language, how to describe language of a
grammar?</td>
<td style="text-align: left;"><span><strong>Class of context-free
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Turing machines that always halt in
polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Nondeterministic Turing machines that
always halt in polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(NP\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Deciders</strong></span>
(Turing machines that always halt): formal definition, how to design for
a given language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of decidable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using diagonalization and
mapping reduction to show undecidability</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Turing
machines</strong></span> formal definition, how to design for a given
language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of recognizable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using closure and mapping
reduction to show unrecognizability</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Given a language, prove it is
regular</strong></span></p>
<p><span><em>Strategy 1</em></span>: construct DFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 2</em></span>: construct NFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 3</em></span>: construct regular expression
recognizing the language and prove it works.</p>
<p><span><em>“Prove it works” means …</em></span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(L  = \{ w \in \{0,1\}^* \mid \textrm{$w$ has odd
number of $1$s or starts with $0$}\}\)</span></p>
<p>Using NFA</p>
<p>Using regular expressions</p>
<p><span><strong>Example</strong></span>: Select all and only the
options that result in a true statement: “To show a language <span
class="math inline">\(A\)</span> is not regular, we can…”</p>
<ol>
<li><p>Show <span class="math inline">\(A\)</span> is finite</p></li>
<li><p>Show there is a CFG generating <span
class="math inline">\(A\)</span></p></li>
<li><p>Show <span class="math inline">\(A\)</span> has no pumping
length</p></li>
<li><p>Show <span class="math inline">\(A\)</span> is
undecidable</p></li>
</ol>
<p><span><strong>Example</strong></span>: What is the language generated
by the CFG with rules <span class="math display">\[\begin{aligned}
    S &amp;\to aSb \mid bY \mid Ya \\
    Y &amp;\to bY \mid Ya \mid \varepsilon
\end{aligned}\]</span></p>
<p><span><strong>Example</strong></span>: Prove that the language <span
class="math inline">\(T = \{ \langle M \rangle \mid \textrm{$M$ is a
Turing machine and $L(M)$ is infinite}\}\)</span> is undecidable.</p>
<p><span><strong>Example</strong></span>: Prove that the class of
decidable languages is closed under concatenation.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Page references are to the 3rd edition (International)
of Siper’s Introduction to the Theory of Computation, available at the
campus bookstore for under $20. Copies of the book are also available
for those who can’t access the book to borrow from the course
instructor, while supplies last (minnes@eng.ucsd.edu)<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
