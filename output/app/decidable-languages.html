<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>decidable-languages</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="week9-monday">Week9 monday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>We will define a computable function that witnesses the mapping
reduction <span class="math inline">\(A_{TM} \leq_m
HALT_{TM}\)</span>.</p>
<p>Using Theorem 5.23, we can then conclude that <span
class="math inline">\(HALT_{TM}\)</span> is undecidable.</p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  \includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;\)</span> is a Turing machine that computes
like <span class="math inline">\(M\)</span> except, if the computation
ever were to go to a reject state, <span
class="math inline">\(M&#39;\)</span> loops instead.</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  001  \rangle)\)</span> =</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=2.5in]{../../resources/machines/Lect22TM2.png}
,  1  \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
<p>True or False: <span class="math inline">\(\overline{A_{TM}} \leq_m
\overline{HALT_{TM}}\)</span></p>
<p>True or False: <span class="math inline">\(HALT_{TM} \leq_m
A_{TM}\)</span>.</p>
<h1 class="unnumbered" id="week9-wednesday">Week9 wednesday</h1>
<p>Recall: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_m B\)</span>, means there is a computable function <span
class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.28): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is recognizable, then <span
class="math inline">\(A\)</span> is recognizable.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Corollary</strong></span>: If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable.</p>
<p><span><em>Strategy</em></span>:</p>
<p>(i) To prove that a recognizable language <span
class="math inline">\(R\)</span> is undecidable, prove that <span
class="math inline">\(A_{TM} \leq_m R\)</span>.</p>
<p>(ii) To prove that a co-recognizable language <span
class="math inline">\(U\)</span> is undecidable, prove that <span
class="math inline">\(\overline{A_{TM}} \leq_m U\)</span>, i.e. that
<span class="math inline">\(A_{TM} \leq_m \overline{U}\)</span>.</p>
<p><span class="math display">\[E_{TM} = \{ \langle M \rangle \mid
\text{$M$ is a Turing machine and $L(M) = \emptyset$} \}\]</span></p>
<p>Example string in <span class="math inline">\(E_{TM}\)</span> is
<u></u> . Example string not in <span
class="math inline">\(E_{TM}\)</span> is <u></u> .</p>
<p><span class="math inline">\(E_{TM}\)</span> is   decidable /
undecidable   and   recognizable / unrecognizable  .</p>
<p><span class="math inline">\(\overline{E_{TM}}\)</span> is   decidable
/ undecidable   and   recognizable / unrecognizable  .</p>
<p><span><strong>Claim</strong></span>: <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
\overline{E_{TM}}\)</span>.</p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in A_{TM}\)</span> iff <span
class="math inline">\(F(x)  \notin  E_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output</p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x
\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \in
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \notin
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span class="math display">\[EQ_{TM} = \{ \langle M, M&#39; \rangle
\mid \text{$M$ and $M&#39;$ are both Turing machines and $L(M)
=L(M&#39;)$} \}\]</span></p>
<p>Example string in <span class="math inline">\(EQ_{TM}\)</span> is
<u></u> . Example string not in <span
class="math inline">\(EQ_{TM}\)</span> is <u></u> .</p>
<p><span class="math inline">\(EQ_{TM}\)</span> is   decidable /
undecidable   and   recognizable / unrecognizable  .</p>
<p><span class="math inline">\(\overline{EQ_{TM}}\)</span> is
  decidable / undecidable   and   recognizable / unrecognizable  .</p>
<p>To prove, show that <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
EQ_{TM}\)</span> and that <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
\overline{EQ_{TM}}\)</span>.</p>
<p>Verifying correctness:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week9-friday">Week9 friday</h1>
<p>In practice, computers (and Turing machines) don’t have infinite
tape, and we can’t afford to wait unboundedly long for an answer.
“Decidable" isn’t good enough - we want “Efficiently decidable".</p>
<p>For a given algorithm working on a given input, how long do we need
to wait for an answer? How does the running time depend on the input in
the worst-case? average-case? We expect to have to spend more time on
computations with larger inputs.</p>
<p>A language is <span><strong>recognizable</strong></span> if
<u></u></p>
<p>A language is <span><strong>decidable</strong></span> if <u></u></p>
<p>A language is <span><strong>efficiently decidable</strong></span> if
<u></u></p>
<p>A function is <span><strong>computable</strong></span> if <u></u></p>
<p>A function is <span><strong>efficiently computable</strong></span> if
<u></u><br />
</p>
<p>Definition (Sipser 7.1): For <span class="math inline">\(M\)</span> a
deterministic decider, its <span><strong>running time</strong></span> is
the function <span class="math inline">\(f: \mathbb{N} \to
\mathbb{N}\)</span> given by <span class="math display">\[f(n)
=  \text{max number of  steps $M$ takes before halting, over all
inputs  of length $n$}\]</span></p>
<p>Definition (Sipser 7.7): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>time complexity
class</strong></span> <span class="math inline">\(TIME(t(n))\)</span>,
is defined by <span class="math display">\[TIME( t(n)) = \{ L \mid
\text{$L$ is decidable by  a Turing machine with running time
in  $O(t(n))$} \}\]</span></p>
<p>An example of an element of <span
class="math inline">\(TIME(  1  )\)</span> is</p>
<p>An example of an element of <span
class="math inline">\(TIME(  n  )\)</span> is</p>
<p>Note: <span class="math inline">\(TIME( 1) \subseteq TIME
(n)  \subseteq TIME(n^2)\)</span></p>
<p>Definition (Sipser 7.12) : <span class="math inline">\(P\)</span> is
the class of languages that are decidable in polynomial time on a
deterministic 1-tape Turing machine <span
class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p><span><em>Compare to exponential time: brute-force
search.</em></span></p>
<p>Theorem (Sipser 7.8): Let <span class="math inline">\(t(n)\)</span>
be a function with <span class="math inline">\(t(n)  \geq n\)</span>.
Then every <span class="math inline">\(t(n)\)</span> time deterministic
multitape Turing machine has an equivalent <span
class="math inline">\(O(t^2(n))\)</span> time deterministic 1-tape
Turing machine.</p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq DTIME(n^2)\)</span></p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[HAMPATH = \{\langle G,s,t \rangle \mid
\textrm{$G$ is digraph with $n$ nodes, there is path
from $s$ to $t$ that goes through every node exactly once}\}\]</span>
<span class="math display">\[VERTEX-COVER = \{ \langle G,k\rangle \mid
\textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<h1 class="unnumbered" id="week8-monday">Week8 monday</h1>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is not Turing-decidable.</p>
<p><span><strong>Proof</strong></span>: Suppose <span><strong>towards a
contradiction</strong></span> that there is a Turing machine that
decides <span class="math inline">\(A_{TM}\)</span>. We call this
presumed machine <span class="math inline">\(M_{ATM}\)</span>.</p>
<p>By assumption, for every Turing machine <span
class="math inline">\(M\)</span> and every string <span
class="math inline">\(w\)</span></p>
<ul>
<li><p>If <span class="math inline">\(w \in L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
<li><p>If <span class="math inline">\(w \notin L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
</ul>
<p>Define a <span><strong>new</strong></span> Turing machine using the
high-level description:</p>
<blockquote>
<p><span class="math inline">\(D =\)</span>“ On input <span
class="math inline">\(\langle M \rangle\)</span>, where <span
class="math inline">\(M\)</span> is a Turing machine:</p>
<ul>
<li><p>Run <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M, \langle M
\rangle  \rangle\)</span>.</p></li>
<li><p>If <span class="math inline">\(M_{ATM}\)</span> accepts, reject;
if <span class="math inline">\(M_{ATM}\)</span> rejects,
accept."</p></li>
</ul>
</blockquote>
<p>Is <span class="math inline">\(D\)</span> a Turing machine?</p>
<p>Is <span class="math inline">\(D\)</span> a decider?</p>
<p>What is the result of the computation of <span
class="math inline">\(D\)</span> on <span class="math inline">\(\langle
D \rangle\)</span>?</p>
<p><span><strong>Theorem</strong></span> (Sipser Theorem 4.22): A
language is Turing-decidable if and only if both it and its complement
are Turing-recognizable.</p>
<p><span><strong>Proof, first direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-decidable. WTS
that both it and its complement are Turing-recognizable.</p>
<p><span><strong>Proof, second direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-recognizable,
and so is its complement. WTS that <span
class="math inline">\(L\)</span> is Turing-decidable.</p>
<p>Give an example of a <span><strong>decidable</strong></span> set:</p>
<p>Give an example of a <span><strong>recognizable
undecidable</strong></span> set:</p>
<p>Give an example of an <span><strong>unrecognizable</strong></span>
set:</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The class of Turing-decidable
languages is closed under complementation?</p>
<p>Definition: A language <span class="math inline">\(L\)</span> over an
alphabet <span class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</p>
<p>Notation: The complement of a set <span
class="math inline">\(X\)</span> is denoted with a superscript <span
class="math inline">\(c\)</span>, <span
class="math inline">\(X^c\)</span>, or an overline, <span
class="math inline">\(\overline{X}\)</span>.</p>
<h1 class="unnumbered" id="week8-wednesday">Week8 wednesday</h1>
<p><span><strong>Mapping reduction</strong></span></p>
<p>Motivation: Proving that <span class="math inline">\(A_{TM}\)</span>
is undecidable was hard. How can we leverage that work? Can we relate
the decidability / undecidability of one problem to another?</p>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(Y\)</span> is easy,</p>
<p>…then <span class="math inline">\(X\)</span> must be easy too.</p>
</blockquote>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(X\)</span> is hard,</p>
<p>…then <span class="math inline">\(Y\)</span> must be hard too.</p>
</blockquote>
<p>“Problem <span class="math inline">\(X\)</span> is no harder than
problem <span class="math inline">\(Y\)</span>” means “Can answer
questions about membership in <span class="math inline">\(X\)</span> by
converting them to questions about membership in <span
class="math inline">\(Y\)</span>”.</p>
<p>Definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Computable functions</strong></span></p>
<p>Definition: A function <span class="math inline">\(f: \Sigma^* \to
\Sigma^*\)</span> is a <span><strong>computable function</strong></span>
means there is some Turing machine such that, for each <span
class="math inline">\(x\)</span>, on input <span
class="math inline">\(x\)</span> the Turing machine halts with exactly
<span class="math inline">\(f(x)\)</span> followed by all blanks on the
tape</p>
<p><span><em>Examples of computable functions</em></span>:</p>
<p>The function that maps a string to a string which is one character
longer and whose value, when interpreted as a fixed-width binary
representation of a nonnegative integer is twice the value of the input
string (when interpreted as a fixed-width binary representation of a
non-negative integer) <span class="math display">\[f_1: \Sigma^* \to
\Sigma^* \qquad  f_1(x)  = x0\]</span></p>
<p>To prove <span class="math inline">\(f_1\)</span> is computable
function, we define a Turing machine computing it.</p>
<p><span><em>High-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Append <span class="math inline">\(0\)</span> to <span
class="math inline">\(w\)</span>.</p>
<p>2. Halt.”</p>
</blockquote>
<p><span><em>Implementation-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Sweep read-write head to the right until find first blank
cell.</p>
<p>2. Write 0.</p>
<p>3. Halt.”</p>
</blockquote>
<p><span><em>Formal definition</em></span> <span
class="math inline">\((\{q0, qacc, qrej\}, \{0,1\},
\{0,1,\textvisiblespace\},\delta, q0, qacc, qrej)\)</span> where <span
class="math inline">\(\delta\)</span> is specified by the state
diagram:</p>
<p>The function that maps a string to the result of repeating the string
twice. <span class="math display">\[f_2: \Sigma^* \to \Sigma^* \qquad
f_2( x )  =  xx\]</span></p>
<p>The function that maps strings that are not the codes of Turing
machines to the empty string and that maps strings that code Turing
machines to the code of the related Turing machine that acts like the
Turing machine coded by the input, except that if this Turing machine
coded by the input tries to reject, the new machine will go into a loop.
<span class="math display">\[f_3: \Sigma^* \to \Sigma^*  \qquad f_3( x
)  =   \begin{cases}  \varepsilon \qquad&amp;\text{if $x$ is not the
code of  a TM} \\
\langle (Q \cup \{q_{trap} \}, \Sigma, \Gamma, \delta&#39;, q_0,
q_{acc}, q_{rej} ) \rangle \qquad&amp;\text{if $x = \langle (Q, \Sigma,
\Gamma, \delta, q_0, q_{acc}, q_{rej} )\rangle$}\end{cases}\]</span>
where <span class="math inline">\(q_{trap} \notin Q\)</span> and <span
class="math display">\[\delta&#39;( (q,x) ) = \begin{cases}
(r,y,d) &amp;\text{if $q \in Q$, $x \in \Gamma$, $\delta ((q,x)) =
(r,y,d)$, and  $r \neq  q_{rej}$} \\
(q_{trap}, \textvisiblespace, R) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>The function that maps strings that are not the codes of CFGs to the
empty string and that maps strings that code CFGs to the code of a PDA
that recognizes the language generated by the CFG.</p>
<p><span><em>Other examples?</em></span></p>
<h1 class="unnumbered" id="week8-friday">Week8 friday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{TM}
\leq_m A_{TM}\)</span></p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{DFA}
\leq_m \{ ww \mid  w \in \{0,1\}^* \}\)</span></p>
<p><span><em>Example</em></span>: <span class="math inline">\(\{
0^i  1^j \mid i  \geq 0, j \geq 0 \} \leq_m A_{TM}\)</span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.22): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is decidable, then <span
class="math inline">\(A\)</span> is decidable.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  \includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;\)</span> is a Turing machine that computes
like <span class="math inline">\(M\)</span> except, if the computation
ever were to go to a reject state, <span
class="math inline">\(M&#39;\)</span> loops instead.</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  001  \rangle)\)</span> =</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=2.5in]{../../resources/machines/Lect22TM2.png}
,  1  \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
<h1 class="unnumbered" id="week6-monday">Week6 monday</h1>
<p>For Turing machine <span class="math inline">\(M= (Q, \Sigma, \Gamma,
\delta, q_0, q_{accept}, q_{reject})\)</span> the
<span><strong>computation</strong></span> of <span
class="math inline">\(M\)</span> on a string <span
class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> is:</p>
<ul>
<li><p>Read/write head starts at leftmost position on tape.</p></li>
<li><p>Input string is written on <span
class="math inline">\(|w|\)</span>-many leftmost cells of tape, rest of
the tape cells have the blank symbol. <span><strong>Tape
alphabet</strong></span> is <span class="math inline">\(\Gamma\)</span>
with <span class="math inline">\(\textvisiblespace\in \Gamma\)</span>
and <span class="math inline">\(\Sigma \subseteq \Gamma\)</span>. The
blank symbol <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>.</p></li>
<li><p>Given current state of machine and current symbol being read at
the tape head, the machine transitions to next state, writes a symbol to
the current position of the tape head (overwriting existing symbol), and
moves the tape head L or R (if possible). Formally,
<span><strong>transition function</strong></span> is <span
class="math display">\[\delta: Q\times \Gamma \to Q \times \Gamma \times
\{L, R\}\]</span></p></li>
<li><p>Computation ends if and when machine enters either the accept or
the reject state. This is called <span><strong>halting</strong></span>.
Note: <span class="math inline">\(q_{accept} \neq
q_{reject}\)</span>.</p></li>
</ul>
<p>The <span><strong>language recognized by the Turing
machine</strong></span> <span class="math inline">\(M\)</span>, is <span
class="math display">\[\{ w \in \Sigma^* \mid \textrm{computation of $M$
on $w$ halts after entering the accept state}\} = \{ w \in \Sigma^* \mid
w \textrm{ is accepted by } M\}\]</span></p>
<p>To define a Turing machine, we could give a</p>
<ul>
<li><p><span><strong>Formal definition</strong></span>, namely the <span
class="math inline">\(7\)</span>-tuple of parameters including set of
states, input alphabet, tape alphabet, transition function, start state,
accept state, and reject state; or,</p></li>
<li><p><span><strong>Implementation-level definition</strong></span>:
English prose that describes the Turing machine head movements relative
to contents of tape, and conditions for accepting / rejecting based on
those contents.</p></li>
</ul>
<p>Conventions for drawing state diagrams of Turing machines: (1) omit
the reject state from the diagram (unless it’s the start state), (2) any
missing transitions in the state diagram have value <span
class="math inline">\((q_{reject}, ~\textvisiblespace~ ,
R)\)</span>.</p>
<p><span><em>Sipser Figure 3.10</em></span></p>
<div class="multicols">
<p><span>2</span></p>
<div class="center">
<p><img src="../../resources/machines/Lect13TM3.png" style="width:4in"
alt="image" /></p>
</div>
<p>Implementation level description of this machine:</p>
<blockquote>
<p>Zig-zag across tape to corresponding positions on either side of
<span class="math inline">\(\#\)</span> to check whether the characters
in these positions agree. If they do not, or if there is no <span
class="math inline">\(\#\)</span>, reject. If they do, cross them
off.</p>
<p>Once all symbols to the left of the <span
class="math inline">\(\#\)</span> are crossed off, check for any
un-crossed-off symbols to the right of <span
class="math inline">\(\#\)</span>; if there are any, reject; if there
aren’t, accept.</p>
</blockquote>
<p>Computation on input string <span
class="math inline">\(01\#01\)</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(q_1
\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\#\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The language recognized by this machine is <span
class="math display">\[\{ w \# w \mid w \in \{0,1\}^* \}\]</span></p>
<p>A language <span class="math inline">\(L\)</span> is
<span><strong>recognized by</strong></span> a Turing machine <span
class="math inline">\(M\)</span> means</p>
<p>A Turing machine <span class="math inline">\(M\)</span>
<span><strong>recognizes</strong></span> a language <span
class="math inline">\(L\)</span> if means</p>
<p>A Turing machine <span class="math inline">\(M\)</span> is a
<span><strong>decider</strong></span> means</p>
<p>A language <span class="math inline">\(L\)</span> is
<span><strong>decided by</strong></span> a Turing machine <span
class="math inline">\(M\)</span> means</p>
<p>A Turing machine <span class="math inline">\(M\)</span>
<span><strong>decides</strong></span> a language <span
class="math inline">\(L\)</span> means</p>
<p>Fix <span class="math inline">\(\Sigma = \{0,1\}\)</span>, <span
class="math inline">\(\Gamma = \{ 0, 1, \textvisiblespace\}\)</span> for
the Turing machines with the following state diagrams:</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM1.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM2.png" style="width:2in"
alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;">Implementation level description:</td>
<td style="text-align: center;">Implementation level description:</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Example of string accepted:</td>
<td style="text-align: center;">Example of string accepted:</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Example of string rejected:</td>
<td style="text-align: center;">Example of string rejected:</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Decider? Yes   /    No</td>
<td style="text-align: center;">Decider? Yes   /    No</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM3.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM4.png" style="width:2in"
alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;">Implementation level description:</td>
<td style="text-align: center;">Implementation level description:</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Example of string accepted:</td>
<td style="text-align: center;">Example of string accepted:</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Example of string rejected:</td>
<td style="text-align: center;">Example of string rejected:</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Decider? Yes   /    No</td>
<td style="text-align: center;">Decider? Yes   /    No</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week6-wednesday">Week6 wednesday</h1>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p>True / False: NFAs and PDAs are equally expressive.</p>
<p>True / False: Regular expressions and CFGs are equally
expressive.</p>
<div class="center">
<p><span><em>Some examples of models that are <span><strong>equally
expressive</strong></span> with deterministic Turing machines:</em>
</span></p>
</div>
<p>The May-stay machine model is the same as the usual Turing machine
model, except that on each transition, the tape head may move L, move R,
or Stay.</p>
<p>Formally: <span class="math inline">\((Q, \Sigma, \Gamma, \delta,
q_0, q_{accept}, q_{reject})\)</span> where <span
class="math display">\[\delta: Q \times \Gamma \to Q \times \Gamma
\times \{L, R, S\}\]</span></p>
<p><span><strong>Claim</strong></span>: Turing machines and May-stay
machines are equally expressive. <span><em>To prove …</em></span></p>
<p>To translate a standard TM to a may-stay machine:</p>
<p>To translate one of the may-stay machines to standard TM: any time TM
would Stay, move right then left.</p>
<p>Formally: suppose <span class="math inline">\(M_S =  (Q, \Sigma,
\Gamma, \delta, q_0, q_{acc}, q_{rej})\)</span> has <span
class="math inline">\(\delta: Q \times \Gamma \to Q \times \Gamma \times
\{L, R, S\}\)</span>. Define the Turing-machine <span
class="math display">\[M_{new}
=  (\phantom{\hspace{2.5in}})\]</span></p>
<p>A multitape Turing macihne with <span
class="math inline">\(k\)</span> tapes can be formally representated as
<span class="math inline">\((Q, \Sigma,  \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math inline">\(Q\)</span> is the
finite set of states, <span class="math inline">\(\Sigma\)</span> is the
input alphabet with <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet with <span class="math inline">\(\Sigma \subsetneq
\Gamma\)</span> , <span class="math inline">\(\delta: Q\times
\Gamma^k\to Q \times \Gamma^k \times \{L,R\}^k\)</span> (where <span
class="math inline">\(k\)</span> is the number of states)</p>
<p>If <span class="math inline">\(M\)</span> is a standard TM, it is a
<span class="math inline">\(1\)</span>-tape machine.</p>
<p>To translate a <span class="math inline">\(k\)</span>-tape machine to
a standard TM: Use a new symbol to separate the contents of each tape
and keep track of location of head with special version of each tape
symbol. <span>Sipser Theorem 3.13</span></p>
<p><img src="../../resources/images/Figure314.png" style="width:2.5in"
alt="image" /></p>
<p><span><em>Extra practice:</em></span> Define a machine <span
class="math inline">\((Q, \Gamma, b, \Sigma,  q_0, F, \delta)\)</span>
where <span class="math inline">\(Q\)</span> is the finite set of states
<span class="math inline">\(\Gamma\)</span> is the tape alphabet, <span
class="math inline">\(b \in \Gamma\)</span> is the blank symbol, <span
class="math inline">\(\Sigma \subsetneq \Gamma\)</span> is the input
alphabet, <span class="math inline">\(q_0 \in  Q\)</span> is the start
state, <span class="math inline">\(F \subseteq Q\)</span> is the set of
accept states, <span class="math inline">\(\delta: (Q \setminus
F)  \times  \Gamma \not\to Q \times  \Gamma  \times \{L, R\}\)</span> is
a partial transition function If computation enters a state in <span
class="math inline">\(F\)</span>, it accepts If computation enters a
configuration where <span class="math inline">\(\delta\)</span> is not
defined, it rejects . <span>Hopcroft and Ullman, cited by
Wikipedia</span></p>
<p>Enumerators give a different model of computation where a language is
<span><strong>produced, one string at a time</strong></span>, rather
than recognized by accepting (or not) individual strings.</p>
<p>Each enumerator machine has finite state control, unlimited work
tape, and a printer. The computation proceeds according to transition
function; at any point machine may “send” a string to the printer. <span
class="math display">\[E  = (Q, \Sigma, \Gamma, \delta, q_0,
q_{print})\]</span> <span class="math inline">\(Q\)</span> is the finite
set of states, <span class="math inline">\(\Sigma\)</span> is the output
alphabet, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet (<span class="math inline">\(\Sigma  \subsetneq\Gamma,
\textvisiblespace \in \Gamma \setminus \Sigma\)</span>), <span
class="math display">\[\delta:  Q  \times  \Gamma \times \Gamma \to  Q
\times  \Gamma \times  \Gamma \times \{L, R\} \times  \{L, R\}\]</span>
where in state <span class="math inline">\(q\)</span>, when the working
tape is scanning character <span class="math inline">\(x\)</span> and
the printer tape is scanning character <span
class="math inline">\(y\)</span>, <span class="math inline">\(\delta(
(q,x,y) ) = (q&#39;, x&#39;, y&#39;, d_w, d_p)\)</span> means transition
to control state <span class="math inline">\(q&#39;\)</span>, write
<span class="math inline">\(x&#39;\)</span> on the working tape, write
<span class="math inline">\(y&#39;\)</span> on the printer tape, move in
direction <span class="math inline">\(d_w\)</span> on the working tape,
and move in direction <span class="math inline">\(d_p\)</span> on the
printer tape. The computation starts in <span
class="math inline">\(q_0\)</span> and each time the computation enters
<span class="math inline">\(q_{print}\)</span> the string from the
leftmost edge of the printer tape to the first blank cell is considered
to be printed.</p>
<p>The language <span><strong>enumerated</strong></span> by <span
class="math inline">\(E\)</span>, <span
class="math inline">\(L(E)\)</span>, is <span class="math inline">\(\{ w
\in \Sigma^* \mid \text{$E$ eventually, at finite  time,
prints $w$} \}\)</span>.</p>
<div class="center">
<div class="tabular">
<p><span>cc</span> <img
src="../../resources/machines/Lec15enumerator.png" style="width:3.5in"
alt="image" /> &amp;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(q0\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace ~*\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace  ~*\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr class="odd">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span><strong>Theorem 3.21</strong></span> A language is
Turing-recognizable iff some enumerator enumerates it. <span><em>Proof
next time …</em></span></p>
<h1 class="unnumbered" id="week6-friday">Week6 friday</h1>
<p>To define a Turing machine, we could give a</p>
<ul>
<li><p><span><strong>Formal definition</strong></span>: the <span
class="math inline">\(7\)</span>-tuple of parameters including set of
states, input alphabet, tape alphabet, transition function, start state,
accept state, and reject state; or,</p></li>
<li><p><span><strong>Implementation-level definition</strong></span>:
English prose that describes the Turing machine head movements relative
to contents of tape, and conditions for accepting / rejecting based on
those contents.</p></li>
<li><p><span><strong>High-level description</strong></span>: description
of algorithm (precise sequence of instructions), without implementation
details of machine. As part of this description, can “call" and run
another TM as a subroutine.</p></li>
</ul>
<p><span><strong>Theorem 3.21</strong></span> A language is
Turing-recognizable iff some enumerator enumerates it.</p>
<p><span><strong>Proof</strong></span>:</p>
<p>Assume <span class="math inline">\(L\)</span> is enumerated by some
enumerator, <span class="math inline">\(E\)</span>, so <span
class="math inline">\(L = L(E)\)</span>. We’ll use <span
class="math inline">\(E\)</span> in a subroutine within a high-level
description of a new Turing machine that we will build to recognize
<span class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build Turing machine <span
class="math inline">\(M_E\)</span> with <span
class="math inline">\(L(M_E) = L(E)\)</span>.</p>
<p>Define <span class="math inline">\(M_E\)</span> as follows: <span
class="math inline">\(M_E =\)</span> “On input <span
class="math inline">\(w\)</span>,</p>
<ol>
<li><p>Run <span class="math inline">\(E\)</span>. For each string <span
class="math inline">\(x\)</span> printed by <span
class="math inline">\(E\)</span>.</p></li>
<li><p>Check if <span class="math inline">\(x = w\)</span>. If so,
accept (and halt); otherwise, continue."</p></li>
</ol>
<p>Assume <span class="math inline">\(L\)</span> is Turing-recognizable
and there is a Turing machine <span class="math inline">\(M\)</span>
with <span class="math inline">\(L = L(M)\)</span>. We’ll use <span
class="math inline">\(M\)</span> in a subroutine within a high-level
description of an enumerator that we will build to enumerate <span
class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build enumerator <span
class="math inline">\(E_M\)</span> with <span
class="math inline">\(L(E_M) = L(M)\)</span>.</p>
<p><span><strong>Idea</strong></span>: check each string in turn to see
if it is in <span class="math inline">\(L\)</span>.</p>
<p><span><em>How?</em></span> Run computation of <span
class="math inline">\(M\)</span> on each string.
<span><em>But</em></span>: need to be careful about computations that
don’t halt.</p>
<p><span><em>Recall</em></span> String order for <span
class="math inline">\(\Sigma = \{0,1\}\)</span>: <span
class="math inline">\(s_1 = \varepsilon\)</span>, <span
class="math inline">\(s_2 = 0\)</span>, <span class="math inline">\(s_3
= 1\)</span>, <span class="math inline">\(s_4 = 00\)</span>, <span
class="math inline">\(s_5 = 01\)</span>, <span
class="math inline">\(s_6  = 10\)</span>, <span
class="math inline">\(s_7  =  11\)</span>, <span
class="math inline">\(s_8 = 000\)</span>, …</p>
<p>Define <span class="math inline">\(E_M\)</span> as follows: <span
class="math inline">\(E_{M} =\)</span> “ <span><em>ignore any
input.</em></span> Repeat the following for <span
class="math inline">\(i=1, 2, 3, \ldots\)</span></p>
<ol>
<li><p>Run the computations of <span class="math inline">\(M\)</span> on
<span class="math inline">\(s_1\)</span>, <span
class="math inline">\(s_2\)</span>, …, <span
class="math inline">\(s_i\)</span> for (at most) <span
class="math inline">\(i\)</span> steps each</p></li>
<li><p>For each of these <span class="math inline">\(i\)</span>
computations that accept during the (at most) <span
class="math inline">\(i\)</span> steps, print out the accepted
string."</p></li>
</ol>
<p><span><strong>Nondeterministic Turing machine</strong></span></p>
<p>At any point in the computation, the nondeterministic machine may
proceed according to several possibilities: <span
class="math inline">\((Q, \Sigma, \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math display">\[\delta: Q \times
\Gamma \to \mathcal{P}(Q \times \Gamma \times \{L, R\})\]</span> The
computation of a nondeterministic Turing machine is a tree with
branching when the next step of the computation has multiple
possibilities. A nondeterministic Turing machine accepts a string
exactly when some branch of the computation tree enters the accept
state.</p>
<p>Given a nondeterministic machine, we can use a <span
class="math inline">\(3\)</span>-tape Turing machine to simulate it by
doing a breadth-first search of computation tree: one tape is
“read-only” input tape, one tape simulates the tape of the
nondeterministic computation, and one tape tracks nondeterministic
branching. <span>Sipser page 178</span></p>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p><span><strong>Church-Turing Thesis</strong></span> (Sipser p. 183):
The informal notion of algorithm is formalized completely and correctly
by the formal definition of a Turing machine. In other words: all
reasonably expressive models of computation are equally expressive with
the standard Turing machine.</p>
<p><span><strong>Claim</strong></span>: If two languages (over a fixed
alphabet <span class="math inline">\(\Sigma\)</span>) are
Turing-recognizable, then their union is as well.</p>
<p><span><strong>Proof using Turing machines</strong></span>:</p>
<p><span><strong>Proof using nondeterministic Turing
machines</strong></span>:</p>
<p><span><strong>Proof using enumerators</strong></span>:</p>
<h1 class="unnumbered" id="week7-monday">Week7 monday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Suppose <span
class="math inline">\(M\)</span> is a TM</td>
<td style="text-align: left;">Suppose <span
class="math inline">\(D\)</span> is a TM</td>
<td style="text-align: left;">Suppose <span
class="math inline">\(E\)</span> is an enumerator</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">that recognizes <span
class="math inline">\(L\)</span></td>
<td style="text-align: left;">that decides <span
class="math inline">\(L\)</span></td>
<td style="text-align: left;">that enumerates <span
class="math inline">\(L\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">If string <span
class="math inline">\(w\)</span> is in <span
class="math inline">\(L\)</span> then …</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">If string <span
class="math inline">\(w\)</span> is not in <span
class="math inline">\(L\)</span> then …</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Describing Turing machines</strong></span> (Sipser p.
185)</p>
<p>The Church-Turing thesis posits that each algorithm can be
implemented by some Turing machine</p>
<p>High-level descriptions of Turing machine algorithms are written as
indented text within quotation marks.</p>
<p>Stages of the algorithm are typically numbered consecutively.</p>
<p>The first line specifies the input to the machine, which must be a
string. This string may be the encoding of some object or list of
objects.</p>
<p><span><strong>Notation:</strong></span> <span
class="math inline">\(\langle O \rangle\)</span> is the string that
encodes the object <span class="math inline">\(O\)</span>. <span
class="math inline">\(\langle O_1, \ldots, O_n \rangle\)</span> is the
string that encodes the list of objects <span class="math inline">\(O_1,
\ldots, O_n\)</span>.</p>
<p><span><strong>Assumption</strong></span>: There are Turing machines
that can be called as subroutines to decode the string representations
of common objects and interact with these objects as intended (data
structures).</p>
<p>For example, since there are algorithms to answer each of the
following questions, by Church-Turing thesis, there is a Turing machine
that accepts exactly those strings for which the answer to the question
is “yes”</p>
<ul>
<li><p>Does a string over <span class="math inline">\(\{0,1\}\)</span>
have even length?</p></li>
<li><p>Does a string over <span class="math inline">\(\{0,1\}\)</span>
encode a string of ASCII characters?<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p>Does a DFA have a specific number of states?</p></li>
<li><p>Do two NFAs have any state names in common?</p></li>
<li><p>Do two CFGs have the same start variable?</p></li>
</ul>
<p>A <span><strong>computational problem</strong></span> is decidable
iff language encoding its positive problem instances is decidable.</p>
<p>The computational problem “Does a specific DFA accept a given
string?” is encoded by the language <span
class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of DFAs $M$ and strings $w$ such that
$w \in L(M)$}\}  \\
  =&amp; \{ \langle M, w \rangle \mid M \textrm{ is a DFA}, w \textrm{
is a string}, w \in L(M) \}
\end{aligned}\]</span></p>
<p>The computational problem “Is the language generated by a CFG empty?”
is encoded by the language <span class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of CFGs $G$  such that $L(G) =
\emptyset$}\}  \\
  =&amp; \{ \langle G \rangle \mid G \textrm{ is a CFG},  L(G) =
\emptyset \}
\end{aligned}\]</span></p>
<p>The computational problem “Is the given Turing machine a decider?” is
encoded by the language <span class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of TMs $M$  such that $M$ halts on
every input}\}  \\
  =&amp; \{ \langle M \rangle \mid M \textrm{ is a TM and for each
string } w, \textrm{$M$ halts on $w$} \}
\end{aligned}\]</span></p>
<p><span><em>Note: writing down the language encoding a computational
problem is only the first step in determining if it’s recognizable,
decidable, or …</em></span></p>
<p><span><strong>Some classes of computational problems help us
understand the differences between the machine models we’ve been
studying:</strong></span></p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  DFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  NFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(A_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R,w
\rangle \mid  \text{$R$ is a  regular
    expression that generates input string $w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(A_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G,w
\rangle \mid  \text{$G$ is a context-free grammar
    that generates input string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a PDA that accepts input string
$w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A
\rangle \mid  \text{$A$ is a  DFA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle
A\rangle \mid  \text{$A$ is a NFA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(E_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R
\rangle \mid  \text{$R$ is a  regular
    expression and  $L(R) = \emptyset$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(E_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G
\rangle \mid  \text{$G$ is a context-free grammar
    and  $L(G) = \emptyset$\}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A
\rangle \mid  \text{$A$ is a PDA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are DFAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are NFAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R,
R&#39; \rangle \mid  \text{$R$ and $R&#39;$ are regular
    expressions and  $L(R) =L(R&#39;)$\}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G,
G&#39; \rangle \mid  \text{$G$ and $G&#39;$ are CFGs and  $L(G)
=L(G&#39;)$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are PDAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Sipser Section 4.1</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(M_1\)</span>
<img src="../../resources/machines/Lect17DFA1.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><span class="math inline">\(M_2\)</span>
<img src="../../resources/machines/Lect17DFA2.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><span class="math inline">\(M_3\)</span>
<img src="../../resources/machines/Lect17DFA3.png" style="width:2in"
alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Example strings in <span class="math inline">\(A_{DFA}\)</span></p>
<p>Example strings in <span class="math inline">\(E_{DFA}\)</span></p>
<p>Example strings in <span class="math inline">\(EQ_{DFA}\)</span></p>
<p>Food for thought: which of the following computational problems are
decidable: <span class="math inline">\(A_{DFA}\)</span>?, <span
class="math inline">\(E_{DFA}\)</span>?, <span
class="math inline">\(EQ_{DFA}\)</span>?</p>
<h1 class="unnumbered" id="week7-wednesday">Week7 wednesday</h1>
<p>Deciding a computational problem means building / defining a Turing
machine that recognizes the language encoding the computational problem,
and that is a decider.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for …</td>
<td style="text-align: center;"><span
class="math inline">\(A_{\ldots}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a \ldots that accepts input
  string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for …</td>
<td style="text-align: center;"><span
class="math inline">\(E_{\ldots}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A
\rangle \mid  \text{$A$ is a \ldots and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for …</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{\ldots}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are \ldots and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sipser Section 4.1</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><span class="math inline">\(M_1 =\)</span> “On input <span
class="math inline">\(\langle M,w\rangle\)</span>, where <span
class="math inline">\(M\)</span> is a DFA and <span
class="math inline">\(w\)</span> is a string:</p>
<ol start="0">
<li><p>Type check encoding to check input is correct type.</p></li>
<li><p>Simulate <span class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span> (by keeping track of states in <span
class="math inline">\(M\)</span>, transition function of <span
class="math inline">\(M\)</span>, etc.)</p></li>
<li><p>If the simulations ends in an accept state of <span
class="math inline">\(M\)</span>, accept. If it ends in a non-accept
state of <span class="math inline">\(M\)</span>, reject. "</p></li>
</ol>
</blockquote>
<p>What is <span class="math inline">\(L(M_1)\)</span>?</p>
<p>Is <span class="math inline">\(L(M_1)\)</span> a decider?</p>
<blockquote>
<p><span class="math inline">\(M_2 =\)</span>“On input <span
class="math inline">\(\langle M, w \rangle\)</span> where <span
class="math inline">\(M\)</span> is a DFA and <span
class="math inline">\(w\)</span> is a string,</p>
<ol>
<li><p>Run <span class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span>.</p></li>
<li><p>If <span class="math inline">\(M\)</span> accepts, accept; if
<span class="math inline">\(M\)</span> rejects, reject."</p></li>
</ol>
</blockquote>
<p>What is <span class="math inline">\(L(M_2)\)</span>?</p>
<p>Is <span class="math inline">\(M_2\)</span> a decider?</p>
<p><span class="math inline">\(A_{REX} =\)</span></p>
<p><span class="math inline">\(A_{NFA} =\)</span></p>
<p>True / False: <span class="math inline">\(A_{REX} = A_{NFA} =
A_{DFA}\)</span></p>
<p>True / False: <span class="math inline">\(A_{REX} \cap A_{NFA} =
\emptyset\)</span>, <span class="math inline">\(A_{REX} \cap A_{DFA} =
\emptyset\)</span>, <span class="math inline">\(A_{DFA} \cap A_{NFA} =
\emptyset\)</span></p>
<p>A Turing machine that decides <span
class="math inline">\(A_{NFA}\)</span> is:</p>
<p>A Turing machine that decides <span
class="math inline">\(A_{REX}\)</span> is:</p>
<blockquote>
<p><span class="math inline">\(M_3 =\)</span>“On input <span
class="math inline">\(\langle M\rangle\)</span> where <span
class="math inline">\(M\)</span> is a DFA,</p>
<ol>
<li><p>For integer <span class="math inline">\(i = 1, 2,
\ldots\)</span></p></li>
<li><p>Let <span class="math inline">\(s_i\)</span> be the <span
class="math inline">\(i\)</span>th string over the alphabet of <span
class="math inline">\(M\)</span> (ordered in string order).</p></li>
<li><p>Run <span class="math inline">\(M\)</span> on input <span
class="math inline">\(s_i\)</span>.</p></li>
<li><p>If <span class="math inline">\(M\)</span> accepts, <span
class="math inline">\(\underline{\phantom{FILL  IN BLANK}}\)</span>. If
<span class="math inline">\(M\)</span> rejects, increment <span
class="math inline">\(i\)</span> and keep going."</p></li>
</ol>
</blockquote>
<p>Choose the correct option to help fill in the blank so that <span
class="math inline">\(M_3\)</span> recognizes <span
class="math inline">\(E_{DFA}\)</span></p>
<ul>
<li><p>accepts</p></li>
<li><p>rejects</p></li>
<li><p>loop for ever</p></li>
<li><p>We can’t fill in the blank in any way to make this work</p></li>
<li><p>None of the above</p></li>
</ul>
<blockquote>
<p><span class="math inline">\(M_4 =\)</span> “ On input <span
class="math inline">\(\langle M \rangle\)</span> where <span
class="math inline">\(M\)</span> is a DFA,</p>
<ol>
<li><p>Mark the start state of <span
class="math inline">\(M\)</span>.</p></li>
<li><p>Repeat until no new states get marked:</p></li>
<li><p>Loop over the states of <span
class="math inline">\(M\)</span>.</p></li>
<li><p>Mark any unmarked state that has an incoming edge from a marked
state.</p></li>
<li><p>If no accept state of <span class="math inline">\(A\)</span> is
marked, <span class="math inline">\(\underline{\phantom{FILL  IN
BLANK}}\)</span>; otherwise, <span
class="math inline">\(\underline{\phantom{FILL  IN
BLANK}}\)</span>".</p></li>
</ol>
</blockquote>
<p>To build a Turing machine that decides <span
class="math inline">\(EQ_{DFA}\)</span>, notice that <span
class="math display">\[L_1 = L_2 \qquad\textrm{iff}\qquad (~(L_1 \cap
\overline{L_2}) \cup (L_2 \cap \overline L_1)~) = \emptyset\]</span>
<span><em>There are no elements that are in one set and not the
other</em></span></p>
<p><span class="math inline">\(M_{EQDFA} =\)</span></p>
<p><span><strong>Summary</strong></span>: We can use the decision
procedures (Turing machines) of decidable problems as subroutines in
other algorithms. For example, we have subroutines for deciding each of
<span class="math inline">\(A_{DFA}\)</span>, <span
class="math inline">\(E_{DFA}\)</span>, <span
class="math inline">\(EQ_{DFA}\)</span>. We can also use algorithms for
known constructions as subroutines in other algorithms. For example, we
have subroutines for: counting the number of states in a state diagram,
counting the number of characters in an alphabet, converting DFA to a
DFA recognizing the complement of the original language or a DFA
recognizing the Kleene star of the original language, constructing a DFA
or NFA from two DFA or NFA so that we have a machine recognizing the
language of the union (or intersection, concatenation) of the languages
of the original machines; converting regular expressions to equivalent
DFA; converting DFA to equivalent regular expressions, etc.</p>
<h1 class="unnumbered" id="week7-friday">Week7 friday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  DFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  NFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(A_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R,w
\rangle \mid  \text{$R$ is a  regular
    expression that generates input string $w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(A_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G,w
\rangle \mid  \text{$G$ is a context-free grammar
    that generates input string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a PDA that accepts input string
$w$}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(A_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M,w
\rangle \mid  \text{$M$ is a Turing machine that accepts input
string $w$}\}\)</span></td>
</tr>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(E_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M
\rangle \mid  \text{$M$ is a Turing machine and  $L(M) =
\emptyset$\}}\)</span></td>
</tr>
<tr class="odd">
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{
\langle  M_1, M_2 \rangle \mid  \text{$M_1$ and $M_2$ are Turing
machines and  
$L(M_1) =L(M_2)$\}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sipser Section 4.1</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="multicols">
<p><span>3</span> <span class="math inline">\(M_1\)</span> <img
src="../../resources/machines/Week8WarmupTM1.png" style="width:2in"
alt="image" /></p>
<p><span class="math inline">\(M_2\)</span> <img
src="../../resources/machines/Week8WarmupTM2.png" style="width:2in"
alt="image" /></p>
<p><span class="math inline">\(M_3\)</span> <img
src="../../resources/machines/Week8WarmupTM3.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example strings in <span class="math inline">\(A_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(E_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(EQ_{TM}\)</span></p>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is Turing-recognizable.</p>
<p><span><strong>Strategy</strong></span>: To prove this theorem, we
need to define a Turing machine <span
class="math inline">\(R_{ATM}\)</span> such that <span
class="math inline">\(L(R_{ATM}) = A_{TM}\)</span>.</p>
<p>Define <span class="math inline">\(R_{ATM} =\)</span> “</p>
<p>Proof of correctness:</p>
<p>We will show that <span class="math inline">\(A_{TM}\)</span> is
undecidable. <span><em>First, let’s explore what that
means.</em></span></p>
<p>A <span><strong>Turing-recognizable</strong></span> language is a set
of strings that is the language recognized by some Turing machine. We
also say that such languages are recognizable.</p>
<p>A <span><strong>Turing-decidable</strong></span> language is a set of
strings that is the language recognized by some decider. We also say
that such languages are decidable.</p>
<p>An <span><strong>unrecognizable</strong></span> language is a
language that is not Turing-recognizable.</p>
<p>An <span><strong>undecidable</strong></span> language is a language
that is not Turing-decidable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any undecidable language is also
unrecognizable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any unrecognizable language is also
undecidable.</p>
<p>To prove that a computational problem is
<span><strong>decidable</strong></span>, we find/ build a Turing machine
that recognizes the language encoding the computational problem, and
that is a decider.</p>
<p>How do we prove a specific problem is <span><strong>not
decidable</strong></span>?</p>
<p>How would we even find such a computational problem?</p>
<p><span><em>Counting arguments for the existence of an undecidable
language:</em></span></p>
<ul>
<li><p>The set of all Turing machines is countably infinite.</p></li>
<li><p>Each Turing-recognizable language is associated with a Turing
machine in a one-to-one relationship, so there can be no more
Turing-recognizable languages than there are Turing machines.</p></li>
<li><p>Since there are infinitely many Turing-recognizable languages
(think of the singleton sets), there are countably infinitely many
Turing-recognizable languages.</p></li>
<li><p>Such the set of Turing-decidable languages is an infinite subset
of the set of Turing-recognizable languages, the set of Turing-decidable
languages is also countably infinite.</p></li>
</ul>
<p>Since there are uncountably many languages (because <span
class="math inline">\(\mathcal{P}(\Sigma^*)\)</span> is uncountable),
there are uncountably many unrecognizable languages and there are
uncountably many undecidable languages.</p>
<p>Thus, there’s at least one undecidable language!</p>
<p><span><strong>What’s a specific example of a language that is
unrecognizable or undecidable?</strong></span></p>
<p>To prove that a language is undecidable, we need to prove that there
is no Turing machine that decides it.</p>
<p><span><strong>Key idea</strong></span>: proof by contradiction
relying on self-referential disagreement.</p>
<h1 class="unnumbered" id="week10-wednesday">Week10 wednesday</h1>
<p>Recall: For <span class="math inline">\(M\)</span> a deterministic
decider, its <span><strong>running time</strong></span> is the function
<span class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given
by <span class="math display">\[f(n) =  \text{max number of  steps $M$
takes before halting, over all inputs  of length $n$}\]</span> For each
function <span class="math inline">\(t(n)\)</span>, the
<span><strong>time complexity class</strong></span> <span
class="math inline">\(TIME(t(n))\)</span>, is defined by <span
class="math display">\[TIME( t(n)) = \{ L \mid \text{$L$ is decidable
by  a Turing machine with running time in  $O(t(n))$} \}\]</span> <span
class="math inline">\(P\)</span> is the class of languages that are
decidable in polynomial time on a deterministic 1-tape Turing machine
<span class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq DTIME(n^2)\)</span></p>
<p><span><strong>Every problem in NP is decidable with an
exponential-time algorithm</strong></span></p>
<p>Nondeterministic approach: guess a possible solution, verify that it
works.</p>
<p>Brute-force (worst-case exponential time) approach: iterate over all
possible solutions, for each one, check if it works.</p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[\begin{aligned}
    HAMPATH &amp;= \{\langle G,s,t \rangle \mid \textrm{$G$ is digraph
with $n$ nodes, }\\
    &amp; \qquad \textrm{there is path
from $s$ to $t$ that goes through every node exactly once}\}
\end{aligned}\]</span> <span class="math display">\[VERTEX-COVER = \{
\langle G,k\rangle \mid \textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(P\)</span></strong></span></th>
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(NP\)</span></strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(Membership in any) regular
language</td>
<td style="text-align: center;">Any problem in <span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">(Membership in any) context-free
language</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(SAT\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(CLIQUE\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(VERTEX-COVER\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(PATH\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(HAMPATH\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(RELPRIME\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Million-dollar question: Is <span class="math inline">\(P =
NP\)</span>?</p>
<p>One approach to trying to answer it is to look for
<span><em>hardest</em></span> problems in <span
class="math inline">\(NP\)</span> and then (1) if we can show that there
are efficient algorithms for them, then we can get efficient algorithms
for all problems in <span class="math inline">\(NP\)</span> so <span
class="math inline">\(P = NP\)</span>, or (2) these problems might be
good candidates for showing that there are problems in <span
class="math inline">\(NP\)</span> for which there are no efficient
algorithms.</p>
<p>Definition (Sipser 7.29) Language <span
class="math inline">\(A\)</span> is <span><strong>polynomial-time
mapping reducible</strong></span> to language <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_P B\)</span>, means there is a polynomial-time computable function
<span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> such that
for every <span class="math inline">\(x \in \Sigma^*\)</span> <span
class="math display">\[x \in A \qquad \text{iff} \qquad f(x) \in
B.\]</span> The function <span class="math inline">\(f\)</span> is
called the polynomial time reduction of <span
class="math inline">\(A\)</span> to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.31): If <span
class="math inline">\(A \leq_P B\)</span> and <span
class="math inline">\(B  \in P\)</span> then <span
class="math inline">\(A \in P\)</span>.</p>
<p>Proof:</p>
<p>Definition (Sipser 7.34; based in Stephen Cook and Leonid Levin’s
work in the 1970s): A language <span class="math inline">\(B\)</span> is
<span><strong>NP-complete</strong></span> means (1) <span
class="math inline">\(B\)</span> is in NP
<span><strong>and</strong></span> (2) every language <span
class="math inline">\(A\)</span> in <span
class="math inline">\(NP\)</span> is polynomial time reducible to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.35): If <span
class="math inline">\(B\)</span> is NP-complete and <span
class="math inline">\(B \in P\)</span> then <span
class="math inline">\(P = NP\)</span>.</p>
<p>Proof:</p>
<p><span><strong>3SAT</strong></span>: A literal is a Boolean variable
(e.g. <span class="math inline">\(x\)</span>) or a negated Boolean
variable (e.g. <span class="math inline">\(\bar{x}\)</span>). A Boolean
formula is a <span><strong>3cnf-formula</strong></span> if it is a
Boolean formula in conjunctive normal form (a conjunction of disjunctive
clauses of literals) and each clause has three literals. <span
class="math display">\[3SAT  = \{  \langle  \phi \rangle \mid
\text{$\phi$ is  a  satisfiable 3cnf-formula} \}\]</span></p>
<p>Example strings in <span class="math inline">\(3SAT\)</span></p>
<p>Example strings not in <span class="math inline">\(3SAT\)</span></p>
<p><span><strong>Cook-Levin Theorem</strong></span>: <span
class="math inline">\(3SAT\)</span> is <span
class="math inline">\(NP\)</span>-complete.</p>
<p><span><em>Are there other <span
class="math inline">\(NP\)</span>-complete problems?</em></span> To
prove that <span class="math inline">\(X\)</span> is <span
class="math inline">\(NP\)</span>-complete</p>
<ul>
<li><p><span><em>From scratch</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that all <span
class="math inline">\(NP\)</span> problems are polynomial-time reducible
to <span class="math inline">\(X\)</span>.</p></li>
<li><p><span><em>Using reduction</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that a known-to-be <span
class="math inline">\(NP\)</span>-complete problem is polynomial-time
reducible to <span class="math inline">\(X\)</span>.</p></li>
</ul>
<p><span><strong>CLIQUE</strong></span>: A <span><strong><span
class="math inline">\(k\)</span>-clique</strong></span> in an undirected
graph is a maximally connected subgraph with <span
class="math inline">\(k\)</span> nodes. <span
class="math display">\[CLIQUE  = \{  \langle G, k \rangle \mid \text{$G$
is an  undirected graph with  a $k$-clique} \}\]</span></p>
<p>Example strings in <span class="math inline">\(CLIQUE\)</span></p>
<p>Example strings not in <span
class="math inline">\(CLIQUE\)</span></p>
<p>Theorem (Sipser 7.32): <span class="math display">\[3SAT  \leq_P
CLIQUE\]</span></p>
<p>Given a Boolean formula in conjunctive normal form with <span
class="math inline">\(k\)</span> clauses and three literals per clause,
we will map it to a graph so that the graph has a clique if the original
formula is satisfiable and the graph does not have a clique if the
original formula is not satisfiable.</p>
<p>The graph has <span class="math inline">\(3k\)</span> vertices (one
for each literal in each clause) and an edge between all vertices
except</p>
<ul>
<li><p>vertices for two literals in the same clause</p></li>
<li><p>vertices for literals that are negations of one another</p></li>
</ul>
<p>Example: <span class="math inline">\((x \vee \bar{y} \vee {\bar z})
\wedge (\bar{x}  \vee y  \vee  z) \wedge (x \vee y  \vee z)\)</span></p>
<h1 class="unnumbered" id="week10-friday">Week10 friday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Model of
Computation</strong></span></td>
<td style="text-align: left;"><span><strong>Class of
Languages</strong></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Deterministic finite
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Nondeterministic finite automata</strong></span>: formal
definition, how to design for a given language, how to describe language
of a machine? <span><strong>Regular expressions</strong></span>: formal
definition, how to design for a given language, how to describe language
of expression? <span><em>Also</em></span>: converting between different
models.</td>
<td style="text-align: left;"><span><strong>Class of regular
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using <span><strong>pumping
lemma</strong></span> to prove nonregularity.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Push-down
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Context-free grammars</strong></span>: formal definition,
how to design for a given language, how to describe language of a
grammar?</td>
<td style="text-align: left;"><span><strong>Class of context-free
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Turing machines that always halt in
polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Nondeterministic Turing machines that
always halt in polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(NP\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Deciders</strong></span>
(Turing machines that always halt): formal definition, how to design for
a given language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of decidable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using diagonalization and
mapping reduction to show undecidability</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Turing
machines</strong></span> formal definition, how to design for a given
language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of recognizable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using closure and mapping
reduction to show unrecognizability</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Given a language, prove it is
regular</strong></span></p>
<p><span><em>Strategy 1</em></span>: construct DFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 2</em></span>: construct NFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 3</em></span>: construct regular expression
recognizing the language and prove it works.</p>
<p><span><em>“Prove it works” means …</em></span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(L  = \{ w \in \{0,1\}^* \mid \textrm{$w$ has odd
number of $1$s or starts with $0$}\}\)</span></p>
<p>Using NFA</p>
<p>Using regular expressions</p>
<p><span><strong>Example</strong></span>: Select all and only the
options that result in a true statement: “To show a language <span
class="math inline">\(A\)</span> is not regular, we can…”</p>
<ol>
<li><p>Show <span class="math inline">\(A\)</span> is finite</p></li>
<li><p>Show there is a CFG generating <span
class="math inline">\(A\)</span></p></li>
<li><p>Show <span class="math inline">\(A\)</span> has no pumping
length</p></li>
<li><p>Show <span class="math inline">\(A\)</span> is
undecidable</p></li>
</ol>
<p><span><strong>Example</strong></span>: What is the language generated
by the CFG with rules <span class="math display">\[\begin{aligned}
    S &amp;\to aSb \mid bY \mid Ya \\
    Y &amp;\to bY \mid Ya \mid \varepsilon
\end{aligned}\]</span></p>
<p><span><strong>Example</strong></span>: Prove that the language <span
class="math inline">\(T = \{ \langle M \rangle \mid \textrm{$M$ is a
Turing machine and $L(M)$ is infinite}\}\)</span> is undecidable.</p>
<p><span><strong>Example</strong></span>: Prove that the class of
decidable languages is closed under concatenation.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>An introduction to ASCII is available on the w3 tutorial
<a
href="https://www.w3schools.com/charsets/ref_html_ascii.asp">here</a>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
