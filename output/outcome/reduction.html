<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>reduction</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="day23">Day23</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><em>Last time</em></span> we proved that <span
class="math inline">\(A_{TM} \le_m HALT_{TM}\)</span> where <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span> and since <span class="math inline">\(A_{TM}\)</span> is
undecidable, <span class="math inline">\(HALT_{TM}\)</span> is also
undecidable. The function witnessing the mapping reduction mapped
strings in <span class="math inline">\(A_{TM}\)</span> to strings in
<span class="math inline">\(HALT_{TM}\)</span> and strings not in <span
class="math inline">\(A_{TM}\)</span> to strings not in <span
class="math inline">\(HALT_{TM}\)</span> by changing encoded Turing
machines to ones that had identical computations except looped instead
of rejecting.</p>
<p>True or False: <span class="math inline">\(\overline{A_{TM}} \leq_m
\overline{HALT_{TM}}\)</span></p>
<p>True or False: <span class="math inline">\(HALT_{TM} \leq_m
A_{TM}\)</span>.</p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in HALT_{TM}\)</span> iff <span
class="math inline">\(F(x)  \in  A_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x ,
w\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is in <span
class="math inline">\(A_{TM}\)</span>?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> does not
halt on <span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Theorem</strong></span> (Sipser 5.28): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is recognizable, then <span
class="math inline">\(A\)</span> is recognizable.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Corollary</strong></span>: If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable.</p>
<p><span><em>Strategy</em></span>:</p>
<p>(i) To prove that a recognizable language <span
class="math inline">\(R\)</span> is undecidable, prove that <span
class="math inline">\(A_{TM} \leq_m R\)</span>.</p>
<p>(ii) To prove that a co-recognizable language <span
class="math inline">\(U\)</span> is undecidable, prove that <span
class="math inline">\(\overline{A_{TM}} \leq_m U\)</span>, i.e. that
<span class="math inline">\(A_{TM} \leq_m \overline{U}\)</span>.</p>
<p><span class="math display">\[E_{TM} = \{ \langle M \rangle \mid
\text{$M$ is a Turing machine and $L(M) = \emptyset$} \}\]</span></p>
<p>Can we find algorithms to recognize</p>
<p><span class="math inline">\(E_{TM}\)</span> ?</p>
<p><span class="math inline">\(\overline{E_{TM}}\)</span> ?</p>
<p><span><strong>Claim</strong></span>: <span
class="math inline">\(A_{TM}  \leq_m \overline{E_{TM}}\)</span>.
<span><em>And hence also</em> </span> <span
class="math inline">\(\overline{A_{TM}} \leq_m E_{TM}\)</span></p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in A_{TM}\)</span> iff <span
class="math inline">\(F(x)  \notin  E_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x
\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in A_{TM}\)</span> iff its image is <span><strong>not</strong></span>
in <span class="math inline">\(E_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \in
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \notin
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="day24">Day24</h1>
<p>Recall: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_m B\)</span>, means there is a computable function <span
class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span></p>
<p>So far:</p>
<ul>
<li><p><span class="math inline">\(A_{TM}\)</span> is recognizable,
undecidable, and not-co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{A_{TM}}\)</span> is
unrecognizable, undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(HALT_{TM}\)</span> is recognizable,
undecidable, and not-co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{HALT_{TM}}\)</span> is
unrecognizable, undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(E_{TM}\)</span> is unrecognizable,
undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{E_{TM}}\)</span> is
recognizable, undecidable, and not-co-recognizable.</p></li>
</ul>
<p><span class="math display">\[EQ_{TM} = \{ \langle M_1, M_2 \rangle
\mid \text{$M_1$ and $M_2$ are both Turing machines and $L(M_1)
=L(M_2)$} \}\]</span></p>
<p>Can we find algorithms to recognize</p>
<p><span class="math inline">\(EQ_{TM}\)</span> ?</p>
<p><span class="math inline">\(\overline{EQ_{TM}}\)</span> ?</p>
<p><span><em>Goal</em></span>: Show that <span
class="math inline">\(EQ_{TM}\)</span> is not recognizable and that
<span class="math inline">\(\overline{EQ_{TM}}\)</span> is not
recognizable.</p>
<p>Using Corollary to <span><strong>Theorem 5.28</strong></span>: If
<span class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable, it’s enough to prove
that</p>
<ul>
<li><p><span class="math inline">\(\overline{HALT_{TM}} \leq_m
EQ_{TM}\)</span> aka <span class="math inline">\(HALT_{TM} \leq_m
\overline{EQ_{TM}}\)</span></p></li>
<li><p><span class="math inline">\(\overline{HALT_{TM}}  \leq_m
\overline{EQ_{TM}}\)</span> aka <span class="math inline">\(HALT_{TM}
\leq_m EQ_{TM}\)</span></p></li>
</ul>
<p>Need computable function <span class="math inline">\(F_1: \Sigma^*
\to \Sigma^*\)</span> such that <span class="math inline">\(x \in
HALT_{TM}\)</span> iff <span
class="math inline">\(F_1(x)  \notin  EQ_{TM}\)</span>.</p>
<p><span><em>Strategy</em></span>:</p>
<p>Map strings <span class="math inline">\(\langle M, w \rangle\)</span>
to strings <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=none]
      \node[initial,state] (q0)                    {$q_0$};
      \node[state,accepting] (qacc) [right of = q0, xshift =
20]{$q_{acc}$};
      \path (q0) edge  [loop above] node {$0, 1,
\scalebox{1.5}{\textvisiblespace} \to R$} (q0)
     ;
    \end{tikzpicture}}
    \rangle\)</span> . This image string is not in <span
class="math inline">\(EQ_{TM}\)</span> when <span
class="math inline">\(L(M&#39;_x) \neq \emptyset\)</span>.</p>
<p>We will build <span class="math inline">\(M&#39;_x\)</span> so that
<span class="math inline">\(L(M&#39;_{x}) = \Sigma^*\)</span> when <span
class="math inline">\(M\)</span> halts on <span
class="math inline">\(w\)</span> and <span
class="math inline">\(L(M&#39;_x) = \emptyset\)</span> when <span
class="math inline">\(M\)</span> loops on <span
class="math inline">\(w\)</span>.</p>
<p>Thus: when <span class="math inline">\(\langle M,w \rangle \in
HALT_{TM}\)</span> it gets mapped to a string not in <span
class="math inline">\(EQ_{TM}\)</span> and when <span
class="math inline">\(\langle M,w \rangle \notin HALT_{TM}\)</span> it
gets mapped to a string that is in <span
class="math inline">\(EQ_{TM}\)</span>.</p>
<p>Define</p>
<blockquote>
<p><span class="math inline">\(F_1 =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=none]
      \node[initial,state] (q0)                    {$q_0$};
      \node[state,accepting] (qacc) [right of = q0, xshift =
20]{$q_{acc}$};
      \path (q0) edge  [loop above] node {$0, 1,
\scalebox{1.5}{\textvisiblespace} \to R$} (q0)
     ;
    \end{tikzpicture}}
    \rangle\)</span> "</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is
<span><strong>not</strong></span> in <span
class="math inline">\(EQ_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Conclude: <span class="math inline">\(HALT_{TM} \leq_m
\overline{EQ_{TM}}\)</span></p>
<p>Need computable function <span class="math inline">\(F_2: \Sigma^*
\to \Sigma^*\)</span> such that <span class="math inline">\(x \in
HALT_{TM}\)</span> iff <span
class="math inline">\(F_2(x)  \in  EQ_{TM}\)</span>.</p>
<p><span><em>Strategy</em></span>:</p>
<p>Map strings <span class="math inline">\(\langle M, w \rangle\)</span>
to strings <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=none]
      \node[initial,state,accepting] (q0)                    {$q_0$};
     ;
    \end{tikzpicture}}
    \rangle\)</span> . This image string is in <span
class="math inline">\(EQ_{TM}\)</span> when <span
class="math inline">\(L(M&#39;_x) = \Sigma^*\)</span>.</p>
<p>We will build <span class="math inline">\(M&#39;_x\)</span> so that
<span class="math inline">\(L(M&#39;_{x}) = \Sigma^*\)</span> when <span
class="math inline">\(M\)</span> halts on <span
class="math inline">\(w\)</span> and <span
class="math inline">\(L(M&#39;_x) = \emptyset\)</span> when <span
class="math inline">\(M\)</span> loops on <span
class="math inline">\(w\)</span>.</p>
<p>Thus: when <span class="math inline">\(\langle M,w \rangle \in
HALT_{TM}\)</span> it gets mapped to a string in <span
class="math inline">\(EQ_{TM}\)</span> and when <span
class="math inline">\(\langle M,w \rangle \notin HALT_{TM}\)</span> it
gets mapped to a string that is not in <span
class="math inline">\(EQ_{TM}\)</span>.</p>
<p>Define</p>
<blockquote>
<p><span class="math inline">\(F_2 =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=none]
      \node[initial,state,accepting] (q0)                    {$q_0$};
     ;
    \end{tikzpicture}}
    \rangle\)</span> "</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is in <span
class="math inline">\(EQ_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Conclude: <span class="math inline">\(HALT_{TM} \leq_m
EQ_{TM}\)</span></p>
<h1 class="unnumbered" id="day25">Day25</h1>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p>True / False: NFAs and PDAs are equally expressive.</p>
<p>True / False: Regular expressions and CFGs are equally
expressive.</p>
<p><span><strong>Church-Turing Thesis</strong></span> (Sipser p. 183):
The informal notion of algorithm is formalized completely and correctly
by the formal definition of a Turing machine. In other words: all
reasonably expressive models of computation are equally expressive with
the standard Turing machine.</p>
<div class="center">
<p><span><em>Some examples of models that are <span><strong>equally
expressive</strong></span> with deterministic Turing machines:</em>
</span></p>
</div>
<p>The May-stay machine model is the same as the usual Turing machine
model, except that on each transition, the tape head may move L, move R,
or Stay.</p>
<p>Formally: <span class="math inline">\((Q, \Sigma, \Gamma, \delta,
q_0, q_{accept}, q_{reject})\)</span> where <span
class="math display">\[\delta: Q \times \Gamma \to Q \times \Gamma
\times \{L, R, S\}\]</span></p>
<p><span><strong>Claim</strong></span>: Turing machines and May-stay
machines are equally expressive. <span><em>To prove …</em></span></p>
<p>To translate a standard TM to a may-stay machine: never use the
direction <span class="math inline">\(S\)</span>!</p>
<p>To translate one of the may-stay machines to standard TM: any time TM
would Stay, move right then left.</p>
<p>A multitape Turing machine with <span
class="math inline">\(k\)</span> tapes can be formally represented as
<span class="math inline">\((Q, \Sigma,  \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math inline">\(Q\)</span> is the
finite set of states, <span class="math inline">\(\Sigma\)</span> is the
input alphabet with <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet with <span class="math inline">\(\Sigma \subsetneq
\Gamma\)</span> , <span class="math inline">\(\delta: Q\times
\Gamma^k\to Q \times \Gamma^k \times \{L,R\}^k\)</span> (where <span
class="math inline">\(k\)</span> is the number of states)</p>
<p>If <span class="math inline">\(M\)</span> is a standard TM, it is a
<span class="math inline">\(1\)</span>-tape machine.</p>
<p>To translate a <span class="math inline">\(k\)</span>-tape machine to
a standard TM: Use a new symbol to separate the contents of each tape
and keep track of location of head with special version of each tape
symbol. <span>Sipser Theorem 3.13</span></p>
<p><img src="../../resources/images/Figure314.png" style="width:2.5in"
alt="image" /></p>
<p>Enumerators give a different model of computation where a language is
<span><strong>produced, one string at a time</strong></span>, rather
than recognized by accepting (or not) individual strings.</p>
<p>Each enumerator machine has finite state control, unlimited work
tape, and a printer. The computation proceeds according to transition
function; at any point machine may “send” a string to the printer. <span
class="math display">\[E  = (Q, \Sigma, \Gamma, \delta, q_0,
q_{print})\]</span> <span class="math inline">\(Q\)</span> is the finite
set of states, <span class="math inline">\(\Sigma\)</span> is the output
alphabet, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet (<span class="math inline">\(\Sigma  \subsetneq\Gamma,
\textvisiblespace \in \Gamma \setminus \Sigma\)</span>), <span
class="math display">\[\delta:  Q  \times  \Gamma \times \Gamma \to  Q
\times  \Gamma \times  \Gamma \times \{L, R\} \times  \{L, R\}\]</span>
where in state <span class="math inline">\(q\)</span>, when the working
tape is scanning character <span class="math inline">\(x\)</span> and
the printer tape is scanning character <span
class="math inline">\(y\)</span>, <span class="math inline">\(\delta(
(q,x,y) ) = (q&#39;, x&#39;, y&#39;, d_w, d_p)\)</span> means transition
to control state <span class="math inline">\(q&#39;\)</span>, write
<span class="math inline">\(x&#39;\)</span> on the working tape, write
<span class="math inline">\(y&#39;\)</span> on the printer tape, move in
direction <span class="math inline">\(d_w\)</span> on the working tape,
and move in direction <span class="math inline">\(d_p\)</span> on the
printer tape. The computation starts in <span
class="math inline">\(q_0\)</span> and each time the computation enters
<span class="math inline">\(q_{print}\)</span> the string from the
leftmost edge of the printer tape to the first blank cell is considered
to be printed.</p>
<p>The language <span><strong>enumerated</strong></span> by <span
class="math inline">\(E\)</span>, <span
class="math inline">\(L(E)\)</span>, is <span class="math inline">\(\{ w
\in \Sigma^* \mid \text{$E$ eventually, at finite  time,
prints $w$} \}\)</span>.</p>
<p><span><strong>Theorem 3.21</strong></span> A language is
Turing-recognizable iff some enumerator enumerates it.</p>
<p><span><strong>Proof, part 1</strong></span>: Assume <span
class="math inline">\(L\)</span> is enumerated by some enumerator, <span
class="math inline">\(E\)</span>, so <span class="math inline">\(L =
L(E)\)</span>. We’ll use <span class="math inline">\(E\)</span> in a
subroutine within a high-level description of a new Turing machine that
we will build to recognize <span class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build Turing machine <span
class="math inline">\(M_E\)</span> with <span
class="math inline">\(L(M_E) = L(E)\)</span>.</p>
<p>Define <span class="math inline">\(M_E\)</span> as follows: <span
class="math inline">\(M_E =\)</span> “On input <span
class="math inline">\(w\)</span>,</p>
<ol>
<li><p>Run <span class="math inline">\(E\)</span>. For each string <span
class="math inline">\(x\)</span> printed by <span
class="math inline">\(E\)</span>.</p></li>
<li><p>Check if <span class="math inline">\(x = w\)</span>. If so,
accept (and halt); otherwise, continue."</p></li>
</ol>
<p><span><strong>Proof, part 2</strong></span>: Assume <span
class="math inline">\(L\)</span> is Turing-recognizable and there is a
Turing machine <span class="math inline">\(M\)</span> with <span
class="math inline">\(L = L(M)\)</span>. We’ll use <span
class="math inline">\(M\)</span> in a subroutine within a high-level
description of an enumerator that we will build to enumerate <span
class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build enumerator <span
class="math inline">\(E_M\)</span> with <span
class="math inline">\(L(E_M) = L(M)\)</span>.</p>
<p><span><strong>Idea</strong></span>: check each string in turn to see
if it is in <span class="math inline">\(L\)</span>.</p>
<p><span><em>How?</em></span> Run computation of <span
class="math inline">\(M\)</span> on each string.
<span><em>But</em></span>: need to be careful about computations that
don’t halt.</p>
<p><span><em>Recall</em></span> String order for <span
class="math inline">\(\Sigma = \{0,1\}\)</span>: <span
class="math inline">\(s_1 = \varepsilon\)</span>, <span
class="math inline">\(s_2 = 0\)</span>, <span class="math inline">\(s_3
= 1\)</span>, <span class="math inline">\(s_4 = 00\)</span>, <span
class="math inline">\(s_5 = 01\)</span>, <span
class="math inline">\(s_6  = 10\)</span>, <span
class="math inline">\(s_7  =  11\)</span>, <span
class="math inline">\(s_8 = 000\)</span>, …</p>
<p>Define <span class="math inline">\(E_M\)</span> as follows: <span
class="math inline">\(E_{M} =\)</span> “ <span><em>ignore any
input.</em></span> Repeat the following for <span
class="math inline">\(i=1, 2, 3, \ldots\)</span></p>
<ol>
<li><p>Run the computations of <span class="math inline">\(M\)</span> on
<span class="math inline">\(s_1\)</span>, <span
class="math inline">\(s_2\)</span>, …, <span
class="math inline">\(s_i\)</span> for (at most) <span
class="math inline">\(i\)</span> steps each</p></li>
<li><p>For each of these <span class="math inline">\(i\)</span>
computations that accept during the (at most) <span
class="math inline">\(i\)</span> steps, print out the accepted
string."</p></li>
</ol>
<p>At any point in the computation, the nondeterministic machine may
proceed according to several possibilities: <span
class="math inline">\((Q, \Sigma, \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math display">\[\delta: Q \times
\Gamma \to \mathcal{P}(Q \times \Gamma \times \{L, R\})\]</span> The
computation of a nondeterministic Turing machine is a tree with
branching when the next step of the computation has multiple
possibilities. A nondeterministic Turing machine accepts a string
exactly when some branch of the computation tree enters the accept
state.</p>
<p>Given a nondeterministic machine, we can use a <span
class="math inline">\(3\)</span>-tape Turing machine to simulate it by
doing a breadth-first search of computation tree: one tape is
“read-only” input tape, one tape simulates the tape of the
nondeterministic computation, and one tape tracks nondeterministic
branching. <span>Sipser page 178</span></p>
<p><span><strong>Summary</strong></span></p>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p>To prove the existence of a Turing machine that decides / recognizes
some language, it’s enough to construct an example using any of the
equally expressive models.</p>
<p>But: some of the <span><strong>performance</strong></span> properties
of these models are not equivalent.</p>
<h1 class="unnumbered" id="day20">Day20</h1>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(A_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M,w
\rangle \mid  \text{$M$ is a Turing machine that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(E_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M
\rangle \mid  \text{$M$ is a Turing machine and  $L(M) =
\emptyset$\}}\)</span></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{
\langle  M_1, M_2 \rangle \mid  \text{$M_1$ and $M_2$ are Turing
machines and  
     $L(M_1) =L(M_2)$\}}\)</span></td>
</tr>
</tbody>
</table>
</div>
<table>
<tbody>
<tr>
<td style="text-align: left;"><span
class="math inline">\(M_1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(M_2\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Example strings in <span class="math inline">\(A_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(E_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(EQ_{TM}\)</span></p>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is Turing-recognizable.</p>
<p><span><strong>Strategy</strong></span>: To prove this theorem, we
need to define a Turing machine <span
class="math inline">\(R_{ATM}\)</span> such that <span
class="math inline">\(L(R_{ATM}) = A_{TM}\)</span>.</p>
<p>Define <span class="math inline">\(R_{ATM} =\)</span> “</p>
<p>Proof of correctness:</p>
<p>We will show that <span class="math inline">\(A_{TM}\)</span> is
undecidable. <span><em>First, let’s explore what that
means.</em></span></p>
<p>To prove that a computational problem is
<span><strong>decidable</strong></span>, we find/ build a Turing machine
that recognizes the language encoding the computational problem, and
that is a decider.</p>
<p>How do we prove a specific problem is <span><strong>not
decidable</strong></span>?</p>
<p>How would we even find such a computational problem?</p>
<p><span><em>Counting arguments for the existence of an undecidable
language:</em></span></p>
<ul>
<li><p>The set of all Turing machines is countably infinite.</p></li>
<li><p>Each recognizable language has at least one Turing machine that
recognizes it (by definition), so there can be no more
Turing-recognizable languages than there are Turing machines.</p></li>
<li><p>Since there are infinitely many Turing-recognizable languages
(think of the singleton sets), there are countably infinitely many
Turing-recognizable languages.</p></li>
<li><p>Such the set of Turing-decidable languages is an infinite subset
of the set of Turing-recognizable languages, the set of Turing-decidable
languages is also countably infinite.</p></li>
</ul>
<p>Since there are uncountably many languages (because <span
class="math inline">\(\mathcal{P}(\Sigma^*)\)</span> is uncountable),
there are uncountably many unrecognizable languages and there are
uncountably many undecidable languages.</p>
<p>Thus, there’s at least one undecidable language!</p>
<p><span><strong>What’s a specific example of a language that is
unrecognizable or undecidable?</strong></span></p>
<p>To prove that a language is undecidable, we need to prove that there
is no Turing machine that decides it.</p>
<p><span><strong>Key idea</strong></span>: proof by contradiction
relying on self-referential disagreement.</p>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is not Turing-decidable.</p>
<p><span><strong>Proof</strong></span>: Suppose <span><strong>towards a
contradiction</strong></span> that there is a Turing machine that
decides <span class="math inline">\(A_{TM}\)</span>. We call this
presumed machine <span class="math inline">\(M_{ATM}\)</span>.</p>
<p>By assumption, for every Turing machine <span
class="math inline">\(M\)</span> and every string <span
class="math inline">\(w\)</span></p>
<ul>
<li><p>If <span class="math inline">\(w \in L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
<li><p>If <span class="math inline">\(w \notin L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
</ul>
<p>Define a <span><strong>new</strong></span> Turing machine using the
high-level description:</p>
<blockquote>
<p><span class="math inline">\(D =\)</span>“ On input <span
class="math inline">\(\langle M \rangle\)</span>, where <span
class="math inline">\(M\)</span> is a Turing machine:</p>
<ul>
<li><p>Run <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M, \langle M
\rangle  \rangle\)</span>.</p></li>
<li><p>If <span class="math inline">\(M_{ATM}\)</span> accepts, reject;
if <span class="math inline">\(M_{ATM}\)</span> rejects,
accept."</p></li>
</ul>
</blockquote>
<p>Is <span class="math inline">\(D\)</span> a Turing machine?</p>
<p>Is <span class="math inline">\(D\)</span> a decider?</p>
<p>What is the result of the computation of <span
class="math inline">\(D\)</span> on <span class="math inline">\(\langle
D \rangle\)</span>?</p>
<p><span><strong>Summarizing</strong></span>:</p>
<ul>
<li><p><span class="math inline">\(A_{TM}\)</span> is
recognizable.</p></li>
<li><p><span class="math inline">\(A_{TM}\)</span> is not
decidable.</p></li>
</ul>
<p>Recall definition: A language <span class="math inline">\(L\)</span>
over an alphabet <span class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</p>
<p>and Recall Theorem (Sipser Theorem 4.22): A language is
Turing-decidable if and only if both it and its complement are
Turing-recognizable.</p>
<ul>
<li><p><span class="math inline">\(A_{TM}\)</span> is
recognizable.</p></li>
<li><p><span class="math inline">\(A_{TM}\)</span> is not
decidable.</p></li>
<li><p><span class="math inline">\(\overline{A_{TM}}\)</span> is not
recognizable.</p></li>
<li><p><span class="math inline">\(\overline{A_{TM}}\)</span> is not
decidable.</p></li>
</ul>
<h1 class="unnumbered" id="day21">Day21</h1>
<p><span><strong>Mapping reduction</strong></span></p>
<p>Motivation: Proving that <span class="math inline">\(A_{TM}\)</span>
is undecidable was hard. How can we leverage that work? Can we relate
the decidability / undecidability of one problem to another?</p>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(Y\)</span> is easy,</p>
<p>…then <span class="math inline">\(X\)</span> must be easy too.</p>
</blockquote>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(X\)</span> is hard,</p>
<p>…then <span class="math inline">\(Y\)</span> must be hard too.</p>
</blockquote>
<p>“Problem <span class="math inline">\(X\)</span> is no harder than
problem <span class="math inline">\(Y\)</span>” means “Can answer
questions about membership in <span class="math inline">\(X\)</span> by
converting them to questions about membership in <span
class="math inline">\(Y\)</span>”.</p>
<p>Definition: For any languages <span class="math inline">\(A\)</span>
and <span class="math inline">\(B\)</span>, <span
class="math inline">\(A\)</span> is <span><strong>mapping reducible
to</strong></span> <span class="math inline">\(B\)</span> means there is
a computable function <span class="math inline">\(f : \Sigma^* \to
\Sigma^*\)</span> such that <span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>TODO</strong></span></p>
<ol>
<li><p>What is a computable function?</p></li>
<li><p>How do mapping reductions help establish the computational
difficulty of languages?</p></li>
</ol>
<p><span><strong>Computable functions</strong></span></p>
<p>Definition: A function <span class="math inline">\(f: \Sigma^* \to
\Sigma^*\)</span> is a <span><strong>computable function</strong></span>
means there is some Turing machine such that, for each <span
class="math inline">\(x\)</span>, on input <span
class="math inline">\(x\)</span> the Turing machine halts with exactly
<span class="math inline">\(f(x)\)</span> followed by all blanks on the
tape</p>
<p><span><em>Examples of computable functions</em></span>:</p>
<p>The function that maps a string to a string which is one character
longer and whose value, when interpreted as a fixed-width binary
representation of a nonnegative integer is twice the value of the input
string (when interpreted as a fixed-width binary representation of a
non-negative integer) <span class="math display">\[f_1: \Sigma^* \to
\Sigma^* \qquad  f_1(x)  = x0\]</span></p>
<p>To prove <span class="math inline">\(f_1\)</span> is computable
function, we define a Turing machine computing it.</p>
<p><span><em>High-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Append <span class="math inline">\(0\)</span> to <span
class="math inline">\(w\)</span>.</p>
<p>2. Halt.”</p>
</blockquote>
<p><span><em>Implementation-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Sweep read-write head to the right until find first blank
cell.</p>
<p>2. Write 0.</p>
<p>3. Halt.”</p>
</blockquote>
<p><span><em>Formal definition</em></span> <span
class="math inline">\((\{q0, qacc, qrej\}, \{0,1\},
\{0,1,\textvisiblespace\},\delta, q0, qacc, qrej)\)</span> where <span
class="math inline">\(\delta\)</span> is specified by the state
diagram:</p>
<p>The function that maps a string to the result of repeating the string
twice. <span class="math display">\[f_2: \Sigma^* \to \Sigma^* \qquad
f_2( x )  =  xx\]</span></p>
<p>The function that maps strings that are not the codes of NFAs to the
empty string and that maps strings that code NFAs to the code of a DFA
that recognizes the language recognized by the NFA produced by the
macro-state construction from Chapter 1.</p>
<p>The function that maps strings that are not the codes of Turing
machines to the empty string and that maps strings that code Turing
machines to the code of the related Turing machine that acts like the
Turing machine coded by the input, except that if this Turing machine
coded by the input tries to reject, the new machine will go into a loop.
<span class="math display">\[f_4: \Sigma^* \to \Sigma^*  \qquad f_4( x
)  =   \begin{cases}  \varepsilon \qquad&amp;\text{if $x$ is not the
code of  a TM} \\
\langle (Q \cup \{q_{trap} \}, \Sigma, \Gamma, \delta&#39;, q_0,
q_{acc}, q_{rej} ) \rangle \qquad&amp;\text{if $x = \langle (Q, \Sigma,
\Gamma, \delta, q_0, q_{acc}, q_{rej} )\rangle$}\end{cases}\]</span>
where <span class="math inline">\(q_{trap} \notin Q\)</span> and <span
class="math display">\[\delta&#39;( (q,x) ) = \begin{cases}
(r,y,d) &amp;\text{if $q \in Q$, $x \in \Gamma$, $\delta ((q,x)) =
(r,y,d)$, and  $r \neq  q_{rej}$} \\
(q_{trap}, \textvisiblespace, R) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>Definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span>, <span class="math inline">\(A \leq_m
B\)</span>m means there is a computable function <span
class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> In this case, we say the function
<span class="math inline">\(f\)</span>
<span><strong>witnesses</strong></span> that <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>.</p>
<p><span><em>Making intutition precise …</em></span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.22): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is decidable, then <span
class="math inline">\(A\)</span> is decidable.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<h1 class="unnumbered" id="day22">Day22</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{TM}
\leq_m A_{TM}\)</span> <span class="math inline">\(A_{TM} = \{ \langle
M, w \rangle  \mid M \text{ is a TM and } w \text{ is a string and } w
\in L(M) \}\)</span></p>
<p><span><em>To prove, need a witnessing function <span
class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> that is (1)
computable and (2) for each <span class="math inline">\(x \in
\Sigma^*\)</span>, <span class="math inline">\(x \in A_{TM}\)</span> iff
<span class="math inline">\(f(x) \in A_{TM}\)</span></em></span></p>
<p><span><strong>Corollary</strong></span>: For any language <span
class="math inline">\(L\)</span>, <span class="math inline">\(L \leq_m
L\)</span>, as witnessed by</p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{DFA}
\leq_m \{ ww \mid  w \in \{0,1\}^* \}\)</span></p>
<p><span><em>To prove, need a witnessing function <span
class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> that is (1)
computable and (2) for each <span class="math inline">\(x \in
\Sigma^*\)</span>, <span class="math inline">\(x \in A_{DFA}\)</span>
iff <span class="math inline">\(f(x) \in \{ ww \mid  w \in \{0,1\}^*
\}\)</span></em></span></p>
<p><span><strong>Corollary</strong></span>: For any language decidable
language <span class="math inline">\(X\)</span> and any set <span
class="math inline">\(Y\)</span> with at least one string string in
<span class="math inline">\(Y\)</span> and at least one string not in
<span class="math inline">\(Y\)</span>, <span class="math inline">\(X
\leq_m Y\)</span>, as witnessed by</p>
<p>Next: consider mapping reductions between potentially undecidable
languages.</p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>We know <span class="math inline">\(A_{TM}\)</span> is undecidable.
If we could prove that <span class="math inline">\(A_{TM} \leq_m
HALT_{TM}\)</span> then we could conclude that <span
class="math inline">\(HALT_{TM}\)</span> is undecidable too.</p>
<p>Could we adapt our approach from before by tweaking the identity
map?</p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;_x, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  
        %\includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
        \begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt,
auto, node distance=2cm, semithick]
            \tikzstyle{every state}=[text=black, fill=none]
            
            \node[initial,state] (q0)          {$q0$};
            \node[state,accepting]         (qacc) [right of=q0,
xshift=20pt] {$q_{acc}$};
            
            \path (q0) edge  [loop above] node {\parbox{1cm}{$0;
\square, R$\newline$1; \square, R$\newline $\square; \square, R$}} (q0)
            ;
          \end{tikzpicture},  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;_x\)</span> is a Turing machine that
computes like <span class="math inline">\(M\)</span> except, if the
computation of <span class="math inline">\(M\)</span> ever were to go to
a reject state, <span class="math inline">\(M&#39;_x\)</span> loops
instead.</p>
<p><span class="math inline">\(F( \langle
        \begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt,
auto, node distance=2cm, semithick]
            \tikzstyle{every state}=[text=black, fill=none]
            
            \node[initial,state] (q0)          {$q0$};
            \node[state]         (q1) [right of=q0, xshift=80pt] {$q1$};
            \node[state,accepting]   (qacc) [above of=q0] {$q_{acc}$};
            
            \path (q0) edge [bend left=20] node {\parbox{1cm}{$0;
0,R$\newline $1; 1, R$}} (q1)
                (q1) edge [bend left=20] node {\parbox{1cm}{$0;
0,R$\newline $1; 1, R$}} (q0)
                (q0) edge  [bend left=0] node {$\square; \square, R$}
(qacc)
            ;
        \end{tikzpicture}, \varepsilon \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
</body>
</html>
