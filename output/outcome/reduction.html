<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>reduction</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="week9-monday">Week9 monday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>We will define a computable function that witnesses the mapping
reduction <span class="math inline">\(A_{TM} \leq_m
HALT_{TM}\)</span>.</p>
<p>Using Theorem 5.23, we can then conclude that <span
class="math inline">\(HALT_{TM}\)</span> is undecidable.</p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  \includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;\)</span> is a Turing machine that computes
like <span class="math inline">\(M\)</span> except, if the computation
ever were to go to a reject state, <span
class="math inline">\(M&#39;\)</span> loops instead.</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  001  \rangle)\)</span> =</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=2.5in]{../../resources/machines/Lect22TM2.png}
,  1  \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
<p>True or False: <span class="math inline">\(\overline{A_{TM}} \leq_m
\overline{HALT_{TM}}\)</span></p>
<p>True or False: <span class="math inline">\(HALT_{TM} \leq_m
A_{TM}\)</span>.</p>
<h1 class="unnumbered" id="week9-wednesday">Week9 wednesday</h1>
<p>Recall: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_m B\)</span>, means there is a computable function <span
class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.28): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is recognizable, then <span
class="math inline">\(A\)</span> is recognizable.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Corollary</strong></span>: If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable.</p>
<p><span><em>Strategy</em></span>:</p>
<p>(i) To prove that a recognizable language <span
class="math inline">\(R\)</span> is undecidable, prove that <span
class="math inline">\(A_{TM} \leq_m R\)</span>.</p>
<p>(ii) To prove that a co-recognizable language <span
class="math inline">\(U\)</span> is undecidable, prove that <span
class="math inline">\(\overline{A_{TM}} \leq_m U\)</span>, i.e. that
<span class="math inline">\(A_{TM} \leq_m \overline{U}\)</span>.</p>
<p><span class="math display">\[E_{TM} = \{ \langle M \rangle \mid
\text{$M$ is a Turing machine and $L(M) = \emptyset$} \}\]</span></p>
<p>Example string in <span class="math inline">\(E_{TM}\)</span> is
<u></u> . Example string not in <span
class="math inline">\(E_{TM}\)</span> is <u></u> .</p>
<p><span class="math inline">\(E_{TM}\)</span> is   decidable /
undecidable   and   recognizable / unrecognizable  .</p>
<p><span class="math inline">\(\overline{E_{TM}}\)</span> is   decidable
/ undecidable   and   recognizable / unrecognizable  .</p>
<p><span><strong>Claim</strong></span>: <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
\overline{E_{TM}}\)</span>.</p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in A_{TM}\)</span> iff <span
class="math inline">\(F(x)  \notin  E_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output</p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x
\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \in
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \notin
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span class="math display">\[EQ_{TM} = \{ \langle M, M&#39; \rangle
\mid \text{$M$ and $M&#39;$ are both Turing machines and $L(M)
=L(M&#39;)$} \}\]</span></p>
<p>Example string in <span class="math inline">\(EQ_{TM}\)</span> is
<u></u> . Example string not in <span
class="math inline">\(EQ_{TM}\)</span> is <u></u> .</p>
<p><span class="math inline">\(EQ_{TM}\)</span> is   decidable /
undecidable   and   recognizable / unrecognizable  .</p>
<p><span class="math inline">\(\overline{EQ_{TM}}\)</span> is
  decidable / undecidable   and   recognizable / unrecognizable  .</p>
<p>To prove, show that <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
EQ_{TM}\)</span> and that <span
class="math inline">\(\underline{\phantom{\hspace{1.6in}}}  \leq_m
\overline{EQ_{TM}}\)</span>.</p>
<p>Verifying correctness:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week9-friday">Week9 friday</h1>
<p>In practice, computers (and Turing machines) don’t have infinite
tape, and we can’t afford to wait unboundedly long for an answer.
“Decidable" isn’t good enough - we want “Efficiently decidable".</p>
<p>For a given algorithm working on a given input, how long do we need
to wait for an answer? How does the running time depend on the input in
the worst-case? average-case? We expect to have to spend more time on
computations with larger inputs.</p>
<p>A language is <span><strong>recognizable</strong></span> if
<u></u></p>
<p>A language is <span><strong>decidable</strong></span> if <u></u></p>
<p>A language is <span><strong>efficiently decidable</strong></span> if
<u></u></p>
<p>A function is <span><strong>computable</strong></span> if <u></u></p>
<p>A function is <span><strong>efficiently computable</strong></span> if
<u></u><br />
</p>
<p>Definition (Sipser 7.1): For <span class="math inline">\(M\)</span> a
deterministic decider, its <span><strong>running time</strong></span> is
the function <span class="math inline">\(f: \mathbb{N} \to
\mathbb{N}\)</span> given by <span class="math display">\[f(n)
=  \text{max number of  steps $M$ takes before halting, over all
inputs  of length $n$}\]</span></p>
<p>Definition (Sipser 7.7): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>time complexity
class</strong></span> <span class="math inline">\(TIME(t(n))\)</span>,
is defined by <span class="math display">\[TIME( t(n)) = \{ L \mid
\text{$L$ is decidable by  a Turing machine with running time
in  $O(t(n))$} \}\]</span></p>
<p>An example of an element of <span
class="math inline">\(TIME(  1  )\)</span> is</p>
<p>An example of an element of <span
class="math inline">\(TIME(  n  )\)</span> is</p>
<p>Note: <span class="math inline">\(TIME( 1) \subseteq TIME
(n)  \subseteq TIME(n^2)\)</span></p>
<p>Definition (Sipser 7.12) : <span class="math inline">\(P\)</span> is
the class of languages that are decidable in polynomial time on a
deterministic 1-tape Turing machine <span
class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p><span><em>Compare to exponential time: brute-force
search.</em></span></p>
<p>Theorem (Sipser 7.8): Let <span class="math inline">\(t(n)\)</span>
be a function with <span class="math inline">\(t(n)  \geq n\)</span>.
Then every <span class="math inline">\(t(n)\)</span> time deterministic
multitape Turing machine has an equivalent <span
class="math inline">\(O(t^2(n))\)</span> time deterministic 1-tape
Turing machine.</p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq DTIME(n^2)\)</span></p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[HAMPATH = \{\langle G,s,t \rangle \mid
\textrm{$G$ is digraph with $n$ nodes, there is path
from $s$ to $t$ that goes through every node exactly once}\}\]</span>
<span class="math display">\[VERTEX-COVER = \{ \langle G,k\rangle \mid
\textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<h1 class="unnumbered" id="week8-monday">Week8 monday</h1>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is not Turing-decidable.</p>
<p><span><strong>Proof</strong></span>: Suppose <span><strong>towards a
contradiction</strong></span> that there is a Turing machine that
decides <span class="math inline">\(A_{TM}\)</span>. We call this
presumed machine <span class="math inline">\(M_{ATM}\)</span>.</p>
<p>By assumption, for every Turing machine <span
class="math inline">\(M\)</span> and every string <span
class="math inline">\(w\)</span></p>
<ul>
<li><p>If <span class="math inline">\(w \in L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
<li><p>If <span class="math inline">\(w \notin L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
</ul>
<p>Define a <span><strong>new</strong></span> Turing machine using the
high-level description:</p>
<blockquote>
<p><span class="math inline">\(D =\)</span>“ On input <span
class="math inline">\(\langle M \rangle\)</span>, where <span
class="math inline">\(M\)</span> is a Turing machine:</p>
<ul>
<li><p>Run <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M, \langle M
\rangle  \rangle\)</span>.</p></li>
<li><p>If <span class="math inline">\(M_{ATM}\)</span> accepts, reject;
if <span class="math inline">\(M_{ATM}\)</span> rejects,
accept."</p></li>
</ul>
</blockquote>
<p>Is <span class="math inline">\(D\)</span> a Turing machine?</p>
<p>Is <span class="math inline">\(D\)</span> a decider?</p>
<p>What is the result of the computation of <span
class="math inline">\(D\)</span> on <span class="math inline">\(\langle
D \rangle\)</span>?</p>
<p><span><strong>Theorem</strong></span> (Sipser Theorem 4.22): A
language is Turing-decidable if and only if both it and its complement
are Turing-recognizable.</p>
<p><span><strong>Proof, first direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-decidable. WTS
that both it and its complement are Turing-recognizable.</p>
<p><span><strong>Proof, second direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-recognizable,
and so is its complement. WTS that <span
class="math inline">\(L\)</span> is Turing-decidable.</p>
<p>Give an example of a <span><strong>decidable</strong></span> set:</p>
<p>Give an example of a <span><strong>recognizable
undecidable</strong></span> set:</p>
<p>Give an example of an <span><strong>unrecognizable</strong></span>
set:</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The class of Turing-decidable
languages is closed under complementation?</p>
<p>Definition: A language <span class="math inline">\(L\)</span> over an
alphabet <span class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</p>
<p>Notation: The complement of a set <span
class="math inline">\(X\)</span> is denoted with a superscript <span
class="math inline">\(c\)</span>, <span
class="math inline">\(X^c\)</span>, or an overline, <span
class="math inline">\(\overline{X}\)</span>.</p>
<h1 class="unnumbered" id="week8-wednesday">Week8 wednesday</h1>
<p><span><strong>Mapping reduction</strong></span></p>
<p>Motivation: Proving that <span class="math inline">\(A_{TM}\)</span>
is undecidable was hard. How can we leverage that work? Can we relate
the decidability / undecidability of one problem to another?</p>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(Y\)</span> is easy,</p>
<p>…then <span class="math inline">\(X\)</span> must be easy too.</p>
</blockquote>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(X\)</span> is hard,</p>
<p>…then <span class="math inline">\(Y\)</span> must be hard too.</p>
</blockquote>
<p>“Problem <span class="math inline">\(X\)</span> is no harder than
problem <span class="math inline">\(Y\)</span>” means “Can answer
questions about membership in <span class="math inline">\(X\)</span> by
converting them to questions about membership in <span
class="math inline">\(Y\)</span>”.</p>
<p>Definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Computable functions</strong></span></p>
<p>Definition: A function <span class="math inline">\(f: \Sigma^* \to
\Sigma^*\)</span> is a <span><strong>computable function</strong></span>
means there is some Turing machine such that, for each <span
class="math inline">\(x\)</span>, on input <span
class="math inline">\(x\)</span> the Turing machine halts with exactly
<span class="math inline">\(f(x)\)</span> followed by all blanks on the
tape</p>
<p><span><em>Examples of computable functions</em></span>:</p>
<p>The function that maps a string to a string which is one character
longer and whose value, when interpreted as a fixed-width binary
representation of a nonnegative integer is twice the value of the input
string (when interpreted as a fixed-width binary representation of a
non-negative integer) <span class="math display">\[f_1: \Sigma^* \to
\Sigma^* \qquad  f_1(x)  = x0\]</span></p>
<p>To prove <span class="math inline">\(f_1\)</span> is computable
function, we define a Turing machine computing it.</p>
<p><span><em>High-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Append <span class="math inline">\(0\)</span> to <span
class="math inline">\(w\)</span>.</p>
<p>2. Halt.”</p>
</blockquote>
<p><span><em>Implementation-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Sweep read-write head to the right until find first blank
cell.</p>
<p>2. Write 0.</p>
<p>3. Halt.”</p>
</blockquote>
<p><span><em>Formal definition</em></span> <span
class="math inline">\((\{q0, qacc, qrej\}, \{0,1\},
\{0,1,\textvisiblespace\},\delta, q0, qacc, qrej)\)</span> where <span
class="math inline">\(\delta\)</span> is specified by the state
diagram:</p>
<p>The function that maps a string to the result of repeating the string
twice. <span class="math display">\[f_2: \Sigma^* \to \Sigma^* \qquad
f_2( x )  =  xx\]</span></p>
<p>The function that maps strings that are not the codes of Turing
machines to the empty string and that maps strings that code Turing
machines to the code of the related Turing machine that acts like the
Turing machine coded by the input, except that if this Turing machine
coded by the input tries to reject, the new machine will go into a loop.
<span class="math display">\[f_3: \Sigma^* \to \Sigma^*  \qquad f_3( x
)  =   \begin{cases}  \varepsilon \qquad&amp;\text{if $x$ is not the
code of  a TM} \\
\langle (Q \cup \{q_{trap} \}, \Sigma, \Gamma, \delta&#39;, q_0,
q_{acc}, q_{rej} ) \rangle \qquad&amp;\text{if $x = \langle (Q, \Sigma,
\Gamma, \delta, q_0, q_{acc}, q_{rej} )\rangle$}\end{cases}\]</span>
where <span class="math inline">\(q_{trap} \notin Q\)</span> and <span
class="math display">\[\delta&#39;( (q,x) ) = \begin{cases}
(r,y,d) &amp;\text{if $q \in Q$, $x \in \Gamma$, $\delta ((q,x)) =
(r,y,d)$, and  $r \neq  q_{rej}$} \\
(q_{trap}, \textvisiblespace, R) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>The function that maps strings that are not the codes of CFGs to the
empty string and that maps strings that code CFGs to the code of a PDA
that recognizes the language generated by the CFG.</p>
<p><span><em>Other examples?</em></span></p>
<h1 class="unnumbered" id="week8-friday">Week8 friday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{TM}
\leq_m A_{TM}\)</span></p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{DFA}
\leq_m \{ ww \mid  w \in \{0,1\}^* \}\)</span></p>
<p><span><em>Example</em></span>: <span class="math inline">\(\{
0^i  1^j \mid i  \geq 0, j \geq 0 \} \leq_m A_{TM}\)</span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.22): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is decidable, then <span
class="math inline">\(A\)</span> is decidable.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  \includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;\)</span> is a Turing machine that computes
like <span class="math inline">\(M\)</span> except, if the computation
ever were to go to a reject state, <span
class="math inline">\(M&#39;\)</span> loops instead.</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  001  \rangle)\)</span> =</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=2.5in]{../../resources/machines/Lect22TM2.png}
,  1  \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
<h1 class="unnumbered" id="week10-wednesday">Week10 wednesday</h1>
<p>Recall: For <span class="math inline">\(M\)</span> a deterministic
decider, its <span><strong>running time</strong></span> is the function
<span class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given
by <span class="math display">\[f(n) =  \text{max number of  steps $M$
takes before halting, over all inputs  of length $n$}\]</span> For each
function <span class="math inline">\(t(n)\)</span>, the
<span><strong>time complexity class</strong></span> <span
class="math inline">\(TIME(t(n))\)</span>, is defined by <span
class="math display">\[TIME( t(n)) = \{ L \mid \text{$L$ is decidable
by  a Turing machine with running time in  $O(t(n))$} \}\]</span> <span
class="math inline">\(P\)</span> is the class of languages that are
decidable in polynomial time on a deterministic 1-tape Turing machine
<span class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq DTIME(n^2)\)</span></p>
<p><span><strong>Every problem in NP is decidable with an
exponential-time algorithm</strong></span></p>
<p>Nondeterministic approach: guess a possible solution, verify that it
works.</p>
<p>Brute-force (worst-case exponential time) approach: iterate over all
possible solutions, for each one, check if it works.</p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[\begin{aligned}
    HAMPATH &amp;= \{\langle G,s,t \rangle \mid \textrm{$G$ is digraph
with $n$ nodes, }\\
    &amp; \qquad \textrm{there is path
from $s$ to $t$ that goes through every node exactly once}\}
\end{aligned}\]</span> <span class="math display">\[VERTEX-COVER = \{
\langle G,k\rangle \mid \textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(P\)</span></strong></span></th>
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(NP\)</span></strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(Membership in any) regular
language</td>
<td style="text-align: center;">Any problem in <span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">(Membership in any) context-free
language</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(SAT\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(CLIQUE\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(VERTEX-COVER\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(PATH\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(HAMPATH\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(RELPRIME\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Million-dollar question: Is <span class="math inline">\(P =
NP\)</span>?</p>
<p>One approach to trying to answer it is to look for
<span><em>hardest</em></span> problems in <span
class="math inline">\(NP\)</span> and then (1) if we can show that there
are efficient algorithms for them, then we can get efficient algorithms
for all problems in <span class="math inline">\(NP\)</span> so <span
class="math inline">\(P = NP\)</span>, or (2) these problems might be
good candidates for showing that there are problems in <span
class="math inline">\(NP\)</span> for which there are no efficient
algorithms.</p>
<p>Definition (Sipser 7.29) Language <span
class="math inline">\(A\)</span> is <span><strong>polynomial-time
mapping reducible</strong></span> to language <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_P B\)</span>, means there is a polynomial-time computable function
<span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> such that
for every <span class="math inline">\(x \in \Sigma^*\)</span> <span
class="math display">\[x \in A \qquad \text{iff} \qquad f(x) \in
B.\]</span> The function <span class="math inline">\(f\)</span> is
called the polynomial time reduction of <span
class="math inline">\(A\)</span> to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.31): If <span
class="math inline">\(A \leq_P B\)</span> and <span
class="math inline">\(B  \in P\)</span> then <span
class="math inline">\(A \in P\)</span>.</p>
<p>Proof:</p>
<p>Definition (Sipser 7.34; based in Stephen Cook and Leonid Levin’s
work in the 1970s): A language <span class="math inline">\(B\)</span> is
<span><strong>NP-complete</strong></span> means (1) <span
class="math inline">\(B\)</span> is in NP
<span><strong>and</strong></span> (2) every language <span
class="math inline">\(A\)</span> in <span
class="math inline">\(NP\)</span> is polynomial time reducible to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.35): If <span
class="math inline">\(B\)</span> is NP-complete and <span
class="math inline">\(B \in P\)</span> then <span
class="math inline">\(P = NP\)</span>.</p>
<p>Proof:</p>
<p><span><strong>3SAT</strong></span>: A literal is a Boolean variable
(e.g. <span class="math inline">\(x\)</span>) or a negated Boolean
variable (e.g. <span class="math inline">\(\bar{x}\)</span>). A Boolean
formula is a <span><strong>3cnf-formula</strong></span> if it is a
Boolean formula in conjunctive normal form (a conjunction of disjunctive
clauses of literals) and each clause has three literals. <span
class="math display">\[3SAT  = \{  \langle  \phi \rangle \mid
\text{$\phi$ is  a  satisfiable 3cnf-formula} \}\]</span></p>
<p>Example strings in <span class="math inline">\(3SAT\)</span></p>
<p>Example strings not in <span class="math inline">\(3SAT\)</span></p>
<p><span><strong>Cook-Levin Theorem</strong></span>: <span
class="math inline">\(3SAT\)</span> is <span
class="math inline">\(NP\)</span>-complete.</p>
<p><span><em>Are there other <span
class="math inline">\(NP\)</span>-complete problems?</em></span> To
prove that <span class="math inline">\(X\)</span> is <span
class="math inline">\(NP\)</span>-complete</p>
<ul>
<li><p><span><em>From scratch</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that all <span
class="math inline">\(NP\)</span> problems are polynomial-time reducible
to <span class="math inline">\(X\)</span>.</p></li>
<li><p><span><em>Using reduction</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that a known-to-be <span
class="math inline">\(NP\)</span>-complete problem is polynomial-time
reducible to <span class="math inline">\(X\)</span>.</p></li>
</ul>
<p><span><strong>CLIQUE</strong></span>: A <span><strong><span
class="math inline">\(k\)</span>-clique</strong></span> in an undirected
graph is a maximally connected subgraph with <span
class="math inline">\(k\)</span> nodes. <span
class="math display">\[CLIQUE  = \{  \langle G, k \rangle \mid \text{$G$
is an  undirected graph with  a $k$-clique} \}\]</span></p>
<p>Example strings in <span class="math inline">\(CLIQUE\)</span></p>
<p>Example strings not in <span
class="math inline">\(CLIQUE\)</span></p>
<p>Theorem (Sipser 7.32): <span class="math display">\[3SAT  \leq_P
CLIQUE\]</span></p>
<p>Given a Boolean formula in conjunctive normal form with <span
class="math inline">\(k\)</span> clauses and three literals per clause,
we will map it to a graph so that the graph has a clique if the original
formula is satisfiable and the graph does not have a clique if the
original formula is not satisfiable.</p>
<p>The graph has <span class="math inline">\(3k\)</span> vertices (one
for each literal in each clause) and an edge between all vertices
except</p>
<ul>
<li><p>vertices for two literals in the same clause</p></li>
<li><p>vertices for literals that are negations of one another</p></li>
</ul>
<p>Example: <span class="math inline">\((x \vee \bar{y} \vee {\bar z})
\wedge (\bar{x}  \vee y  \vee  z) \wedge (x \vee y  \vee z)\)</span></p>
<h1 class="unnumbered" id="week10-friday">Week10 friday</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Model of
Computation</strong></span></td>
<td style="text-align: left;"><span><strong>Class of
Languages</strong></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Deterministic finite
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Nondeterministic finite automata</strong></span>: formal
definition, how to design for a given language, how to describe language
of a machine? <span><strong>Regular expressions</strong></span>: formal
definition, how to design for a given language, how to describe language
of expression? <span><em>Also</em></span>: converting between different
models.</td>
<td style="text-align: left;"><span><strong>Class of regular
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using <span><strong>pumping
lemma</strong></span> to prove nonregularity.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Push-down
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Context-free grammars</strong></span>: formal definition,
how to design for a given language, how to describe language of a
grammar?</td>
<td style="text-align: left;"><span><strong>Class of context-free
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Turing machines that always halt in
polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Nondeterministic Turing machines that
always halt in polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(NP\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Deciders</strong></span>
(Turing machines that always halt): formal definition, how to design for
a given language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of decidable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using diagonalization and
mapping reduction to show undecidability</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Turing
machines</strong></span> formal definition, how to design for a given
language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of recognizable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using closure and mapping
reduction to show unrecognizability</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Given a language, prove it is
regular</strong></span></p>
<p><span><em>Strategy 1</em></span>: construct DFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 2</em></span>: construct NFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 3</em></span>: construct regular expression
recognizing the language and prove it works.</p>
<p><span><em>“Prove it works” means …</em></span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(L  = \{ w \in \{0,1\}^* \mid \textrm{$w$ has odd
number of $1$s or starts with $0$}\}\)</span></p>
<p>Using NFA</p>
<p>Using regular expressions</p>
<p><span><strong>Example</strong></span>: Select all and only the
options that result in a true statement: “To show a language <span
class="math inline">\(A\)</span> is not regular, we can…”</p>
<ol>
<li><p>Show <span class="math inline">\(A\)</span> is finite</p></li>
<li><p>Show there is a CFG generating <span
class="math inline">\(A\)</span></p></li>
<li><p>Show <span class="math inline">\(A\)</span> has no pumping
length</p></li>
<li><p>Show <span class="math inline">\(A\)</span> is
undecidable</p></li>
</ol>
<p><span><strong>Example</strong></span>: What is the language generated
by the CFG with rules <span class="math display">\[\begin{aligned}
    S &amp;\to aSb \mid bY \mid Ya \\
    Y &amp;\to bY \mid Ya \mid \varepsilon
\end{aligned}\]</span></p>
<p><span><strong>Example</strong></span>: Prove that the language <span
class="math inline">\(T = \{ \langle M \rangle \mid \textrm{$M$ is a
Turing machine and $L(M)$ is infinite}\}\)</span> is undecidable.</p>
<p><span><strong>Example</strong></span>: Prove that the class of
decidable languages is closed under concatenation.</p>
</body>
</html>
