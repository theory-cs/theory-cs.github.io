<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>informal-definition-of-automata</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="week5-wednesday">Week5 wednesday</h1>
<p>Warmup: Design a CFG to generate the language <span
class="math inline">\(\{a^i b^j \mid j \geq i  \geq 0\}\)</span></p>
<p><span><em>Sample derivation:</em></span></p>
<p>Design a PDA to recognize the language <span
class="math inline">\(\{a^i b^j \mid j \geq i  \geq 0\}\)</span></p>
<p><span><strong>Theorem 2.20</strong></span>: A language is generated
by some context-free grammar if and only if it is recognized by some
push-down automaton.</p>
<p>Definition: a language is called
<span><strong>context-free</strong></span> if it is the language
generated by a context-free grammar. The class of all context-free
language over a given alphabet <span
class="math inline">\(\Sigma\)</span> is called
<span><strong>CFL</strong></span>.</p>
<p>Consequences:</p>
<ul>
<li><p>Quick proof that every regular language is context free</p></li>
<li><p>To prove closure of the class of context-free languages under a
given operation, we can choose either of two modes of proof (via CFGs or
PDAs) depending on which is easier</p></li>
<li><p>To fully specify a PDA we could give its <span
class="math inline">\(6\)</span>-tuple formal definition or we could
give its input alphabet, stack alphabet, and state diagram. An informal
description of a PDA is a step-by-step description of how its
computations would process input strings; the reader should be able to
reconstruct the state diagram or formal definition precisely from such a
descripton. The informal description of a PDA can refer to some common
modules or subroutines that are computable by PDAs:</p>
<ul>
<li><p>PDAs can “test for emptiness of stack” without providing details.
<span><em>How?</em></span> We can always push a special end-of-stack
symbol, <span class="math inline">\(\$\)</span>, at the start, before
processing any input, and then use this symbol as a flag.</p></li>
<li><p>PDAs can “test for end of input” without providing details.
<span><em>How?</em></span> We can transform a PDA to one where accepting
states are only those reachable when there are no more input
symbols.</p></li>
</ul></li>
</ul>
<p>Suppose <span class="math inline">\(L_1\)</span> and <span
class="math inline">\(L_2\)</span> are context-free languages over <span
class="math inline">\(\Sigma\)</span>.
<span><strong>Goal</strong></span>: <span class="math inline">\(L_1 \cup
L_2\)</span> is also context-free.</p>
<p><span><em>Approach 1: with PDAs</em></span></p>
<p>Let <span class="math inline">\(M_1 = ( Q_1, \Sigma, \Gamma_1,
\delta_1, q_1, F_1)\)</span> and <span class="math inline">\(M_2 = (
Q_2, \Sigma, \Gamma_2, \delta_2, q_2, F_2)\)</span> be PDAs with <span
class="math inline">\(L(M_1) =  L_1\)</span> and <span
class="math inline">\(L(M_2) = L_2\)</span>.</p>
<p>Define <span class="math inline">\(M =\)</span></p>
<p><span><em>Approach 2: with CFGs</em></span></p>
<p>Let <span class="math inline">\(G_1 = (V_1, \Sigma, R_1,
S_1)\)</span> and <span class="math inline">\(G_2 = (V_2, \Sigma, R_2,
S_2)\)</span> be CFGs with <span class="math inline">\(L(G_1)
=  L_1\)</span> and <span class="math inline">\(L(G_2) =
L_2\)</span>.</p>
<p>Define <span class="math inline">\(G =\)</span></p>
<p>Suppose <span class="math inline">\(L_1\)</span> and <span
class="math inline">\(L_2\)</span> are context-free languages over <span
class="math inline">\(\Sigma\)</span>.
<span><strong>Goal</strong></span>: <span class="math inline">\(L_1
\circ L_2\)</span> is also context-free.</p>
<p><span><em>Approach 1: with PDAs</em></span></p>
<p>Let <span class="math inline">\(M_1 = ( Q_1, \Sigma, \Gamma_1,
\delta_1, q_1, F_1)\)</span> and <span class="math inline">\(M_2 = (
Q_2, \Sigma, \Gamma_2, \delta_2, q_2, F_2)\)</span> be PDAs with <span
class="math inline">\(L(M_1) =  L_1\)</span> and <span
class="math inline">\(L(M_2) = L_2\)</span>.</p>
<p>Define <span class="math inline">\(M =\)</span></p>
<p><span><em>Approach 2: with CFGs</em></span></p>
<p>Let <span class="math inline">\(G_1 = (V_1, \Sigma, R_1,
S_1)\)</span> and <span class="math inline">\(G_2 = (V_2, \Sigma, R_2,
S_2)\)</span> be CFGs with <span class="math inline">\(L(G_1)
=  L_1\)</span> and <span class="math inline">\(L(G_2) =
L_2\)</span>.</p>
<p>Define <span class="math inline">\(G =\)</span></p>
<p><span><em>Summary</em></span></p>
<p>Over a fixed alphabet <span class="math inline">\(\Sigma\)</span>, a
language <span class="math inline">\(L\)</span> is
<span><strong>regular</strong></span></p>
<div class="center">
<p>iff it is described by some regular expression<br />
iff it is recognized by some DFA<br />
iff it is recognized by some NFA</p>
</div>
<p>Over a fixed alphabet <span class="math inline">\(\Sigma\)</span>, a
language <span class="math inline">\(L\)</span> is
<span><strong>context-free</strong></span></p>
<div class="center">
<p>iff it is generated by some CFG<br />
iff it is recognized by some PDA</p>
</div>
<p><span><strong>Fact</strong></span>: Every regular language is a
context-free language.</p>
<p><span><strong>Fact</strong></span>: There are context-free languages
that are not nonregular.</p>
<p><span><strong>Fact</strong></span>: There are countably many regular
languages.</p>
<p><span><strong>Fact</strong></span>: There are countably inifnitely
many context-free languages.</p>
<p><span><em>Consequence</em></span>: Most languages are
<span><strong>not</strong></span> context-free!</p>
<p><span><strong>Examples of non-context-free
languages</strong></span></p>
<p><span class="math display">\[\begin{aligned}
    &amp;\{ a^n b^n c^n \mid 0 \leq n , n \in \mathbb{Z}\}\\
    &amp;\{ a^i b^j c^k \mid 0 \leq i \leq j \leq k , i \in \mathbb{Z},
j \in \mathbb{Z}, k \in \mathbb{Z}\}\\
    &amp;\{ ww \mid w \in \{0,1\}^* \}
\end{aligned}\]</span> (Sipser Ex 2.36, Ex 2.37, 2.38)</p>
<p>There is a Pumping Lemma for CFL that can be used to prove a specific
language is non-context-free: If <span class="math inline">\(A\)</span>
is a context-free language, there there is a number <span
class="math inline">\(p\)</span> where, if <span
class="math inline">\(s\)</span> is any string in <span
class="math inline">\(A\)</span> of length at least <span
class="math inline">\(p\)</span>, then <span
class="math inline">\(s\)</span> may be divided into five pieces <span
class="math inline">\(s = uvxyz\)</span> where (1) for each <span
class="math inline">\(i \geq 0\)</span>, <span
class="math inline">\(uv^ixy^iz \in A\)</span>, (2) <span
class="math inline">\(|uv|&gt;0\)</span>, (3) <span
class="math inline">\(|vxy| \leq p\)</span>. <span><em>We will not go
into the details of the proof or application of Pumping Lemma for CFLs
this quarter.</em></span></p>
<h1 class="unnumbered" id="week5-friday">Week5 friday</h1>
<h1 class="unnumbered" id="week4-wednesday">Week4 wednesday</h1>
<p>Regular sets are not the end of the story</p>
<ul>
<li><p>Many nice / simple / important sets are not regular</p></li>
<li><p>Limitation of the finite-state automaton model: Can’t “count",
Can only remember finitely far into the past, Can’t backtrack, Must make
decisions in “real-time"</p></li>
<li><p>We know actual computers are more powerful than this
model...</p></li>
</ul>
<p>The <span><strong>next</strong></span> model of computation. Idea:
allow some memory of unbounded size. How?</p>
<ul>
<li><p>To generalize regular expressions: <span><strong>context-free
grammars</strong></span><br />
</p></li>
<li><p>To generalize NFA: <span><strong>Pushdown
automata</strong></span>, which is like an NFA with access to a stack:
Number of states is fixed, number of entries in stack is unbounded. At
each step (1) Transition to new state based on current state, letter
read, and top letter of stack, then (2) (Possibly) push or pop a letter
to (or from) top of stack. Accept a string iff there is some sequence of
states and some sequence of stack contents which helps the PDA processes
the entire input string and ends in an accepting state.</p></li>
</ul>
<p>Is there a PDA that recognizes the nonregular language <span
class="math inline">\(\{0^n1^n \mid n \geq 0 \}\)</span>?</p>
<p><img src="../../resources/machines/Lect9PDA.png" style="width:4in"
alt="image" /></p>
<p>The PDA with state diagram above can be informally described as:</p>
<blockquote>
<p>Read symbols from the input. As each 0 is read, push it onto the
stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If
the stack becomes empty and we are at the end of the input string,
accept the input. If the stack becomes empty and there are 1s left to
read, or if 1s are finished while the stack still contains 0s, or if any
0s appear in the string following 1s, reject the input.</p>
</blockquote>
<p>Trace the computation of this PDA on the input string <span
class="math inline">\(01\)</span>.</p>
<p>Trace the computation of this PDA on the input string <span
class="math inline">\(011\)</span>.</p>
<p>A PDA recognizing the set <span class="math inline">\(\{ \hspace{1.5
in} \}\)</span> can be informally described as:</p>
<blockquote>
<p>Read symbols from the input. As each 0 is read, push it onto the
stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If
the stack becomes empty and there is exactly one 1 left to read, read
that 1 and accept the input. If the stack becomes empty and there are
either zero or more than one 1s left to read, or if the 1s are finished
while the stack still contains 0s, or if any 0s appear in the input
following 1s, reject the input.</p>
</blockquote>
<p>Modify the state diagram below to get a PDA that implements this
description:</p>
<p><img src="../../resources/machines/Lect9PDA.png" style="width:4in"
alt="image" /></p>
<p><span><strong>Definition</strong></span> A <span><strong>pushdown
automaton</strong></span> (PDA) is specified by a <span
class="math inline">\(6\)</span>-tuple <span class="math inline">\((Q,
\Sigma, \Gamma, \delta, q_0, F)\)</span> where <span
class="math inline">\(Q\)</span> is the finite set of states, <span
class="math inline">\(\Sigma\)</span> is the input alphabet, <span
class="math inline">\(\Gamma\)</span> is the stack alphabet, <span
class="math display">\[\delta: Q \times
\Sigma_\varepsilon  \times  \Gamma_\varepsilon \to \mathcal{P}( Q \times
\Gamma_\varepsilon)\]</span> is the transition function, <span
class="math inline">\(q_0 \in Q\)</span> is the start state, <span
class="math inline">\(F \subseteq  Q\)</span> is the set of accept
states.</p>
<h1 class="unnumbered" id="week4-friday">Week4 friday</h1>
<p>Draw the state diagram and give the formal definition of a PDA with
<span class="math inline">\(\Sigma = \Gamma\)</span>.</p>
<p>Draw the state diagram and give the formal definition of a PDA with
<span class="math inline">\(\Sigma \cap \Gamma = \emptyset\)</span>.</p>
<p>For the PDA state diagrams below, <span class="math inline">\(\Sigma
= \{0,1\}\)</span>.</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Mathematical description of
language</th>
<th style="text-align: center;">State diagram of PDA recognizing
language</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\Gamma = \{
\$, \#\}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect10PDA1.png" style="width:3.5in"
alt="image" /></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\Gamma = \{
{@}, 1\}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect10PDA2.png" style="width:3.5in"
alt="image" /></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{ 0^i 1^j
0^k \mid i,j,k \geq 0 \}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><em>Note: alternate notation is to replace <span
class="math inline">\(;\)</span> with <span
class="math inline">\(\to\)</span></em></span></p>
<p><span><em>Big picture</em></span>: PDAs were motivated by wanting to
add some memory of unbounded size to NFA. How do we accomplish a similar
enhancement of regular expressions to get a syntactic model that is more
expressive?</p>
<p>DFA, NFA, PDA: Machines process one input string at a time; the
computation of a machine on its input string reads the input from left
to right.</p>
<p>Regular expressions: Syntactic descriptions of all strings that match
a particular pattern; the language described by a regular expression is
built up recursively according to the expression’s syntax</p>
<p><span><strong>Context-free grammars</strong></span>: Rules to produce
one string at a time, adding characters from the middle, beginning, or
end of the final string as the derivation proceeds.</p>
<h1 class="unnumbered" id="week6-monday">Week6 monday</h1>
<p>We are ready to introduce a formal model that will capture a notion
of general purpose computation.</p>
<ul>
<li><p><span><em>Similar to DFA, NFA, PDA</em></span>: input will be an
arbitrary string over a fixed alphabet.</p></li>
<li><p><span><em>Different from NFA, PDA</em></span>: machine is
deterministic.</p></li>
<li><p><span><em>Different from DFA, NFA, PDA</em></span>: read-write
head can move both to the left and to the right, and can extend to the
right past the original input.</p></li>
<li><p><span><em>Similar to DFA, NFA, PDA</em></span>: transition
function drives computation one step at a time by moving within a finite
set of states, always starting at designated start state.</p></li>
<li><p><span><em>Different from DFA, NFA, PDA</em></span>: the special
states for rejecting and accepting take effect immediately.</p></li>
</ul>
<p>(See more details: Sipser p. 166)</p>
<p>Formally: a Turing machine is <span class="math inline">\(M= (Q,
\Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})\)</span> where
<span class="math inline">\(\delta\)</span> is the
<span><strong>transition function</strong></span> <span
class="math display">\[\delta: Q\times \Gamma \to Q \times \Gamma \times
\{L, R\}\]</span> The <span><strong>computation</strong></span> of <span
class="math inline">\(M\)</span> on a string <span
class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> is:</p>
<ul>
<li><p>Read/write head starts at leftmost position on tape.</p></li>
<li><p>Input string is written on <span
class="math inline">\(|w|\)</span>-many leftmost cells of tape, rest of
the tape cells have the blank symbol. <span><strong>Tape
alphabet</strong></span> is <span class="math inline">\(\Gamma\)</span>
with <span class="math inline">\(\textvisiblespace\in \Gamma\)</span>
and <span class="math inline">\(\Sigma \subseteq \Gamma\)</span>. The
blank symbol <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>.</p></li>
<li><p>Given current state of machine and current symbol being read at
the tape head, the machine transitions to next state, writes a symbol to
the current position of the tape head (overwriting existing symbol), and
moves the tape head L or R (if possible).</p></li>
<li><p>Computation ends <span><strong>if and when</strong></span>
machine enters either the accept or the reject state. This is called
<span><strong>halting</strong></span>. Note: <span
class="math inline">\(q_{accept} \neq q_{reject}\)</span>.</p></li>
</ul>
<p>The <span><strong>language recognized by the Turing
machine</strong></span> <span class="math inline">\(M\)</span>, is <span
class="math inline">\(L(M) = \{ w \in \Sigma^* \mid w \textrm{ is
accepted by } M\}\)</span>, which is defined as <span
class="math display">\[\{ w \in \Sigma^* \mid \textrm{computation of $M$
on $w$ halts after entering the accept state}\}\]</span></p>
<div class="multicols">
<p><span>2</span> <img src="../../resources/machines/Lect13TM1.png"
style="width:2.5in" alt="image" /></p>
<p>Formal definition:</p>
<p>Sample computation:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(q0\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The language recognized by this machine is …</p>
<p><span><strong>Describing Turing machines</strong></span> (Sipser p.
185) To define a Turing machine, we could give a</p>
<ul>
<li><p><span><strong>Formal definition</strong></span>: the <span
class="math inline">\(7\)</span>-tuple of parameters including set of
states, input alphabet, tape alphabet, transition function, start state,
accept state, and reject state; or,</p></li>
<li><p><span><strong>Implementation-level definition</strong></span>:
English prose that describes the Turing machine head movements relative
to contents of tape, and conditions for accepting / rejecting based on
those contents.</p></li>
<li><p><span><strong>High-level description</strong></span>: description
of algorithm (precise sequence of instructions), without implementation
details of machine. As part of this description, can “call" and run
another TM as a subroutine.</p></li>
</ul>
<p>Fix <span class="math inline">\(\Sigma = \{0,1\}\)</span>, <span
class="math inline">\(\Gamma = \{ 0, 1, \textvisiblespace\}\)</span> for
the Turing machines with the following state diagrams:</p>
<div class="center">
<p><img src="../../resources/machines/Lect14TM1.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example of string accepted:<br />
Example of string rejected:<br />
Implementation-level description</p>
<p>High-level description</p>
<div class="center">
<p><img src="../../resources/machines/Lect14TM2.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example of string accepted:<br />
Example of string rejected:<br />
Implementation-level description</p>
<p>High-level description</p>
<div class="center">
<p><img src="../../resources/machines/Lect14TM3.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example of string accepted:<br />
Example of string rejected:<br />
Implementation-level description</p>
<p>High-level description</p>
<div class="center">
<p><img src="../../resources/machines/Lect14TM4.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example of string accepted:<br />
Example of string rejected:<br />
Implementation-level description</p>
<p>High-level description</p>
<h1 class="unnumbered" id="week6-wednesday">Week6 wednesday</h1>
<p><span><em>Sipser Figure 3.10</em></span></p>
<p><span><strong>Conventions in state diagram of TM</strong></span>:
<span class="math inline">\(b \to R\)</span> label means <span
class="math inline">\(b \to b, R\)</span> and all arrows missing from
diagram represent transitions with output <span
class="math inline">\((q_{reject}, \textvisiblespace , R)\)</span></p>
<div class="multicols">
<p><span>2</span></p>
<div class="center">
<p><img src="../../resources/machines/Lect13TM3.png" style="width:4in"
alt="image" /></p>
</div>
<p>Implementation level description of this machine:</p>
<blockquote>
<p>Zig-zag across tape to corresponding positions on either side of
<span class="math inline">\(\#\)</span> to check whether the characters
in these positions agree. If they do not, or if there is no <span
class="math inline">\(\#\)</span>, reject. If they do, cross them
off.</p>
<p>Once all symbols to the left of the <span
class="math inline">\(\#\)</span> are crossed off, check for any
un-crossed-off symbols to the right of <span
class="math inline">\(\#\)</span>; if there are any, reject; if there
aren’t, accept.</p>
</blockquote>
<p>The language recognized by this machine is <span
class="math display">\[\{ w \# w \mid w \in \{0,1\}^* \}\]</span></p>
<p>Computation on input string <span
class="math inline">\(01\#01\)</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(q_1
\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\#\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<div class="multicols">
<p><span>2</span> High-level description of this machine is</p>
<p><span><em>Recall:</em></span> High-level descriptions of Turing
machine algorithms are written as indented text within quotation marks.
Stages of the algorithm are typically numbered consecutively. The first
line specifies the input to the machine, which must be a string.</p>
<p><span><em>Extra practice</em></span></p>
<p>Computation on input string <span
class="math inline">\(01\#1\)</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(q_1\downarrow\)</span></th>
<th colspan="6" style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\#\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\textvisiblespace\)</span></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td colspan="7" style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>A language <span class="math inline">\(L\)</span> is
<span><strong>recognized by</strong></span> a Turing machine <span
class="math inline">\(M\)</span> means</p>
<p>A Turing machine <span class="math inline">\(M\)</span>
<span><strong>recognizes</strong></span> a language <span
class="math inline">\(L\)</span> means</p>
<p>A Turing machine <span class="math inline">\(M\)</span> is a
<span><strong>decider</strong></span> means</p>
<p>A language <span class="math inline">\(L\)</span> is
<span><strong>decided by</strong></span> a Turing machine <span
class="math inline">\(M\)</span> means</p>
<p>A Turing machine <span class="math inline">\(M\)</span>
<span><strong>decides</strong></span> a language <span
class="math inline">\(L\)</span> means</p>
<p>Fix <span class="math inline">\(\Sigma = \{0,1\}\)</span>, <span
class="math inline">\(\Gamma = \{ 0, 1, \textvisiblespace\}\)</span> for
the Turing machines with the following state diagrams:</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM1.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM2.png" style="width:2in"
alt="image" /></td>
</tr>
<tr>
<td style="text-align: center;">Decider? Yes   /    No</td>
<td style="text-align: center;">Decider? Yes   /    No</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM3.png" style="width:2in"
alt="image" /></td>
<td style="text-align: center;"><img
src="../../resources/machines/Lect14TM4.png" style="width:2in"
alt="image" /></td>
</tr>
<tr>
<td style="text-align: center;">Decider? Yes   /    No</td>
<td style="text-align: center;">Decider? Yes   /    No</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week6-friday">Week6 friday</h1>
<p>A <span><strong>Turing-recognizable</strong></span> language is a set
of strings that is the language recognized by some Turing machine. We
also say that such languages are recognizable.</p>
<p>A <span><strong>Turing-decidable</strong></span> language is a set of
strings that is the language recognized by some decider. We also say
that such languages are decidable.</p>
<p>An <span><strong>unrecognizable</strong></span> language is a
language that is not Turing-recognizable.</p>
<p>An <span><strong>undecidable</strong></span> language is a language
that is not Turing-decidable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any decidable language is also
recognizable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any recognizable language is also
decidable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any undecidable language is also
unrecognizable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: Any unrecognizable language is also
undecidable.</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: The class of Turing-decidable
languages is closed under complementation.</p>
<p>Using formal definition:</p>
<p>Using high-level description:</p>
<p><span><strong>Church-Turing Thesis</strong></span> (Sipser p. 183):
The informal notion of algorithm is formalized completely and correctly
by the formal definition of a Turing machine. In other words: all
reasonably expressive models of computation are equally expressive with
the standard Turing machine.</p>
<p>Definition: A language <span class="math inline">\(L\)</span> over an
alphabet <span class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</p>
<p><span><strong>Theorem</strong></span> (Sipser Theorem 4.22): A
language is Turing-decidable if and only if both it and its complement
are Turing-recognizable.</p>
<p><span><strong>Proof, first direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-decidable. WTS
that both it and its complement are Turing-recognizable.</p>
<p><span><strong>Proof, second direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-recognizable,
and so is its complement. WTS that <span
class="math inline">\(L\)</span> is Turing-decidable.</p>
<p>Notation: The complement of a set <span
class="math inline">\(X\)</span> is denoted with a superscript <span
class="math inline">\(c\)</span>, <span
class="math inline">\(X^c\)</span>, or an overline, <span
class="math inline">\(\overline{X}\)</span>.</p>
<p><span><strong>Claim</strong></span>: If two languages (over a fixed
alphabet <span class="math inline">\(\Sigma\)</span>) are
Turing-decidable, then their union is as well.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Claim</strong></span>: If two languages (over a fixed
alphabet <span class="math inline">\(\Sigma\)</span>) are
Turing-recognizable, then their union is as well.</p>
<p><span><strong>Proof</strong></span>:</p>
<h1 class="unnumbered" id="week3-monday">Week3 monday</h1>
<p><span><strong>Warmup</strong></span>: Design a DFA (deterministic
finite automaton) and an NFA (nondeterministic finite automaton) that
each recognize each of the following languages over <span
class="math inline">\(\{a,b\}\)</span> <span class="math display">\[\{ w
\mid \text{$w$ has an $a$ and ends in $b$}\}\]</span></p>
<p><span class="math display">\[\{ w \mid \text{$w$ has an $a$ or ends
in $b$}\}\]</span></p>
<p><strong>Strategy</strong>: To design DFA or NFA for a given language,
identify patterns that can be built up as we process strings and create
states for intermediate stages. Or: decompose the language to a simpler
one that we already know how to recognize with a DFA or NFA.</p>
<p><span><em>Recall</em></span> (from Wednesday of last week, and in
textbook Exercise 1.14): if there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span> then there is another DFA, let’s
call it <span class="math inline">\(M&#39;\)</span>, such that <span
class="math inline">\(L(M&#39;) = \overline{A}\)</span>, the complement
of <span class="math inline">\(A\)</span>, defined as <span
class="math inline">\(\{ w \in \Sigma^* \mid w \notin A \}\)</span>.</p>
<p>Let’s practice defining automata constructions by coming up with
other ways to get new automata from old.</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N_1\)</span> such that <span
class="math inline">\(L(N_1) = A_1\)</span> and NFA <span
class="math inline">\(N_2\)</span> such that <span
class="math inline">\(L(N_2) = A_2\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Use nondeterminism to
choose which of <span class="math inline">\(N_1\)</span>, <span
class="math inline">\(N_2\)</span> to run.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\)</span>
and <span class="math inline">\(N_2 = (Q_2, \Sigma, \delta_2,q_2,
F_2)\)</span> and assume <span class="math inline">\(Q_1 \cap Q_2 =
\emptyset\)</span> and that <span class="math inline">\(q_0 \notin Q_1
\cup Q_2\)</span>. Construct <span class="math inline">\(N = (Q, \Sigma,
\delta, q_0, F_1 \cup F_2)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q =\)</span></p></li>
<li><p><span class="math inline">\(\delta: Q \times \Sigma_\varepsilon
\to \mathcal{P}(Q)\)</span> is defined by, for <span
class="math inline">\(q \in Q\)</span> and <span class="math inline">\(x
\in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\phantom{\delta((q,x))=\begin{cases}  \delta_1
((q,x)) &amp;\qquad\text{if } q\in Q_1 \\ \delta_2 ((q,x))
&amp;\qquad\text{if } q\in Q_2 \\ \{q1,q2\} &amp;\qquad\text{if } q =
q_0, x = \varepsilon \\ \emptyset\text{if } q= q_0, x \neq \varepsilon
\end{cases}}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span> by considering an
arbitrary string accepted by <span class="math inline">\(N\)</span>,
tracing an accepting computation of <span
class="math inline">\(N\)</span> on it, and using that trace to prove
the string is in at least one of <span
class="math inline">\(A_1\)</span>, <span
class="math inline">\(A_2\)</span>; then, taking an arbitrary string in
<span class="math inline">\(A_1 \cup A_2\)</span> and proving that it is
accepted by <span class="math inline">\(N\)</span>. Details left for
extra practice.</em></span></p>
<p><span><strong>Example</strong></span>: The language recognized by the
NFA over <span class="math inline">\(\{a,b\}\)</span> with state
diagram</p>
<p>is:</p>
<p>Could we do the same construction with DFA?</p>
<p>Happily, though, an analogous claim is true!</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cup A_2\)</span>. <span><em>Theorem
1.25 in Sipser, page 45</em></span></p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
<p><span><strong>Example</strong></span>: When <span
class="math inline">\(A_1 = \{w \mid w~\text{has an $a$ and ends in $b$}
\}\)</span> and <span class="math inline">\(A_2 = \{ w \mid w~\text{is
of even length} \}\)</span>.</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cap A_2\)</span>. <span><em>Sipser
Theorem 1.25, page 45</em></span></p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
<h1 class="unnumbered" id="week3-wednesday">Week3 wednesday</h1>
<p>So far we have that:</p>
<ul>
<li><p>If there is a DFA recognizing a language, there is a DFA
recognizing its complement.</p></li>
<li><p>If there are NFA recognizing two languages, there is a NFA
recognizing their union.</p></li>
<li><p>If there are DFA recognizing two languages, there is a DFA
recognizing their union.</p></li>
<li><p>If there are DFA recognizing two languages, there is a DFA
recognizing their intersection.</p></li>
</ul>
<p>Our goals for today are (1) prove similar results about other set
operations, (2) prove that NFA and DFA are equally expressive, and
therefore (3) define an important class of languages.</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N_1\)</span> such that <span
class="math inline">\(L(N_1) = A_1\)</span> and NFA <span
class="math inline">\(N_2\)</span> such that <span
class="math inline">\(L(N_2) = A_2\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A_1 \circ A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Allow computation to move
between <span class="math inline">\(N_1\)</span> and <span
class="math inline">\(N_2\)</span> “spontaneously" when reach an
accepting state of <span class="math inline">\(N_1\)</span>, guessing
that we’ve reached the point where the two parts of the string in the
set-wise concatenation are glued together.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\)</span>
and <span class="math inline">\(N_2 = (Q_2, \Sigma, \delta_2,q_2,
F_2)\)</span> and assume <span class="math inline">\(Q_1 \cap Q_2 =
\emptyset\)</span>. Construct <span class="math inline">\(N = (Q,
\Sigma, \delta, q_0, F)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q =\)</span></p></li>
<li><p><span class="math inline">\(q_0 =\)</span></p></li>
<li><p><span class="math inline">\(F =\)</span></p></li>
<li><p><span class="math inline">\(\delta: Q \times \Sigma_\varepsilon
\to \mathcal{P}(Q)\)</span> is defined by, for <span
class="math inline">\(q \in Q\)</span> and <span class="math inline">\(a
\in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\delta((q,a))=\begin{cases}  
                \delta_1 ((q,a)) &amp;\qquad\text{if } q\in Q_1 \textrm{
and } q \notin F_1\\
                \delta_1 ((q,a)) &amp;\qquad\text{if } q\in F_1 \textrm{
and } a \in \Sigma\\
                \delta_1 ((q,a)) \cup \{q_2\} &amp;\qquad\text{if } q\in
F_1 \textrm{ and } a = \varepsilon\\
                \delta_2 ((q,a)) &amp;\qquad\text{if } q\in Q_2
            \end{cases}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N) = A_1 \circ A_2\)</span> by considering an
arbitrary string accepted by <span class="math inline">\(N\)</span>,
tracing an accepting computation of <span
class="math inline">\(N\)</span> on it, and using that trace to prove
the string can be written as the result of concatenating two strings,
the first in <span class="math inline">\(A_1\)</span> and the second in
<span class="math inline">\(A_2\)</span>; then, taking an arbitrary
string in <span class="math inline">\(A_1 \circ A_2\)</span> and proving
that it is accepted by <span class="math inline">\(N\)</span>. Details
left for extra practice.</em></span></p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N\)</span> such that <span
class="math inline">\(L(N) = A\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N&#39;\)</span>, such that
<span class="math inline">\(L(N&#39;) = A^*\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Add a fresh start state,
which is an accept state. Add spontaneous moves from each (old) accept
state to the old start state.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N = (Q, \Sigma, \delta, q_1, F)\)</span> and
assume <span class="math inline">\(q_0 \notin Q\)</span>. Construct
<span class="math inline">\(N&#39; = (Q&#39;, \Sigma, \delta&#39;, q_0,
F&#39;)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q&#39; = Q \cup
\{q_0\}\)</span></p></li>
<li><p><span class="math inline">\(F&#39; = F \cup
\{q_0\}\)</span></p></li>
<li><p><span class="math inline">\(\delta&#39;: Q&#39; \times
\Sigma_\varepsilon \to \mathcal{P}(Q&#39;)\)</span> is defined by, for
<span class="math inline">\(q \in Q&#39;\)</span> and <span
class="math inline">\(a \in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\delta&#39;((q,a))=\begin{cases}  
                \delta ((q,a)) &amp;\qquad\text{if } q\in Q \textrm{ and
} q \notin F\\
                \delta ((q,a)) &amp;\qquad\text{if } q\in F \textrm{ and
} a \in \Sigma\\
                \delta ((q,a)) \cup \{q_1\} &amp;\qquad\text{if } q\in F
\textrm{ and } a = \varepsilon\\
                \{q_1\} &amp;\qquad\text{if } q = q_0 \textrm{ and } a =
\varepsilon \\
                \emptyset &amp;\qquad\text{if } q = q_0 \textrm { and }
a \in \Sigma
            \end{cases}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N&#39;) = A^*\)</span> by considering an
arbitrary string accepted by <span
class="math inline">\(N&#39;\)</span>, tracing an accepting computation
of <span class="math inline">\(N&#39;\)</span> on it, and using that
trace to prove the string can be written as the result of concatenating
some number of strings, each of which is in <span
class="math inline">\(A\)</span>; then, taking an arbitrary string in
<span class="math inline">\(A^*\)</span> and proving that it is accepted
by <span class="math inline">\(N&#39;\)</span>. Details left for extra
practice.</em></span></p>
<p><span><strong>Application</strong></span>: A state diagram for a NFA
over <span class="math inline">\(\Sigma = \{a,b\}\)</span> that
recognizes <span class="math inline">\(L (( a^*b)^* )\)</span>:</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N\)</span> such that <span
class="math inline">\(L(N) = A\)</span> then there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: States in <span
class="math inline">\(M\)</span> are “macro-states" – collections of
states from <span class="math inline">\(N\)</span> – that represent the
set of possible states a computation of <span
class="math inline">\(N\)</span> might be in.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N = (Q, \Sigma, \delta, q_0, F)\)</span>. Define
<span class="math display">\[M = (~ \mathcal{P}(Q), \Sigma, \delta&#39;,
q&#39;,  \{ X \subseteq Q \mid X \cap F \neq \emptyset \}~ )\]</span>
where <span class="math inline">\(q&#39; = \{ q \in Q \mid \text{$q =
q_0$ or is accessible from $q_0$ by spontaneous moves in $N$}
\}\)</span> and <span class="math display">\[\delta&#39; (~(X, x)~) = \{
q \in Q \mid q \in \delta( ~(r,x)~) ~\text{for some $r \in X$ or is
accessible
from such an $r$ by spontaneous moves in $N$} \}\]</span></p>
<p>Consider the state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span>. Use the “macro-state”
construction to find an equivalent DFA.</p>
<p><img src="../../resources/machines/Lect6NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>Consider the state diagram of an NFA over <span
class="math inline">\(\{0,1\}\)</span>. Use the “macro-state”
construction to find an equivalent DFA.</p>
<p><img src="../../resources/machines/Lect6NFA2.png" style="width:1.8in"
alt="image" /></p>
<p>Note: We can often prune the DFAs that result from the “macro-state”
constructions to get an equivalent DFA with fewer states (e.g. only the
“macro-states" reachable from the start state).</p>
<p><span><strong>The class of regular languages</strong></span></p>
<p>Fix an alphabet <span class="math inline">\(\Sigma\)</span>. For each
language <span class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span>:</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"><span><strong>There is a DFA over <span
class="math inline">\(\Sigma\)</span> that recognizes <span
class="math inline">\(L\)</span></strong></span></td>
<td style="text-align: center;"><span class="math inline">\(\exists M
~(M \textrm{ is a DFA and } L(M) = A)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span><em>if and only
if</em></span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span><strong>There is a NFA over <span
class="math inline">\(\Sigma\)</span> that recognizes <span
class="math inline">\(L\)</span></strong></span></td>
<td style="text-align: center;"><span class="math inline">\(\exists N
~(N \textrm{ is a NFA and } L(N) = A)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span><em>if and only
if</em></span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span><strong>There is a regular
expression over <span class="math inline">\(\Sigma\)</span> that
describes <span class="math inline">\(L\)</span></strong></span></td>
<td style="text-align: center;"><span class="math inline">\(\exists R
~(R \textrm{ is a regular expression and } L(R) = A)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>A language is called <span><strong>regular</strong></span> when any
(hence all) of the above three conditions are met.</p>
<p>We already proved that DFAs and NFAs are equally expressive. It
remains to prove that regular expressions are too.</p>
<p>Part 1: Suppose <span class="math inline">\(A\)</span> is a language
over an alphabet <span class="math inline">\(\Sigma\)</span>. If there
is a regular expression <span class="math inline">\(R\)</span> such that
<span class="math inline">\(L(R) = A\)</span>, then there is a NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A\)</span>.</p>
<p><span><strong>Structural induction</strong></span>: Regular
expression is built from basis regular expressions using inductive steps
(union, concatenation, Kleene star symbols). Use constructions to mirror
these in NFAs.</p>
<p><span><strong>Application</strong></span>: A state diagram for a NFA
over <span class="math inline">\(\{a,b\}\)</span> that recognizes <span
class="math inline">\(L(a^* (ab)^*)\)</span>:</p>
<p>Part 2: Suppose <span class="math inline">\(A\)</span> is a language
over an alphabet <span class="math inline">\(\Sigma\)</span>. If there
is a DFA <span class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span>, then there is a regular
expression, let’s call it <span class="math inline">\(R\)</span>, such
that <span class="math inline">\(L(R) = A\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Trace all possible paths
from start state to accept state. Express labels of these paths as
regular expressions, and union them all.</p>
<ol>
<li><p>Add new start state with <span
class="math inline">\(\varepsilon\)</span> arrow to old start
state.</p></li>
<li><p>Add new accept state with <span
class="math inline">\(\varepsilon\)</span> arrow from old accept states.
Make old accept states non-accept.</p></li>
<li><p>Remove one (of the old) states at a time: modify regular
expressions on arrows that went through removed state to restore
language recognized by machine.</p></li>
</ol>
<p><span><strong>Application</strong></span>: Find a regular expression
describing the language recognized by the DFA with state diagram</p>
<p><img src="../../resources/machines/Lect6NFA3.png" style="width:2.5in"
alt="image" /></p>
<h1 class="unnumbered" id="week2-wednesday">Week2 wednesday</h1>
<p><span><strong>Review</strong></span>: Formal definition of finite
automaton: <span class="math inline">\(M = (Q, \Sigma, \delta, q_0,
F)\)</span></p>
<div class="center">
<div class="multicols">
<p><span>2</span></p>
<ul>
<li><p>Finite set of states <span
class="math inline">\(Q\)</span></p></li>
<li><p>Alphabet <span class="math inline">\(\Sigma\)</span></p></li>
<li><p>Transition function <span
class="math inline">\(\delta\)</span></p></li>
<li><p>Start state <span class="math inline">\(q_0\)</span></p></li>
<li><p>Accept (final) states <span
class="math inline">\(F\)</span></p></li>
</ul>
</div>
</div>
<p>In the state diagram of <span class="math inline">\(M\)</span>, how
many outgoing arrows are there from each state?</p>
<p><span class="math inline">\(M = ( \{ q, r, s\}, \{a,b\}, \delta, q,
\{q\} )\)</span> where <span class="math inline">\(\delta\)</span> is
(rows labelled by states and columns labelled by symbols):</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(\delta\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(a\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(b\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The state diagram for <span class="math inline">\(M\)</span> is</p>
<p>Give two examples of strings that are accepted by <span
class="math inline">\(M\)</span> and two examples of strings that are
rejected by <span class="math inline">\(M\)</span>:</p>
<p><span class="math inline">\(L(M) =\)</span></p>
<p>A regular expression describing <span
class="math inline">\(L(M)\)</span> is</p>
<p>Let the alphabet be <span class="math inline">\(\Sigma_1 =
\{0,1\}\)</span>.</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \in \Sigma_1^* \mid w~\text{contains at most
two $1$&#39;s} \}\)</span> is</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \in \Sigma_1^* \mid w~\text{contains more than
two $1$&#39;s} \}\)</span> is</p>
<p><strong>Strategy</strong>: Add “labels" for states in the state
diagram, e.g. “have not seen any of desired pattern yet” or “sink
state”. Then, we can use the analysis of the roles of the states in the
state diagram to work towards a description of the language recognized
by the finite automaton.</p>
<p>A useful bit of terminology: the <span><strong>iterated transition
function</strong></span> of a finite automaton <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> is
defined recursively by <span class="math display">\[\delta^* (~(q,w)~)
=\begin{cases}
q  \qquad &amp;\text{if $q \in Q, w = \varepsilon$} \\
\delta( ~(q,a)~) \qquad &amp;\text{if $q \in Q$, $w = a \in \Sigma$ } \\
\delta(~(\delta^*(q,u), a) ~) \qquad &amp;\text{if $q \in Q$, $w = ua$
where $u \in  \Sigma^*$ and $a \in \Sigma$}
\end{cases}\]</span></p>
<p>Using this terminology, <span class="math inline">\(M\)</span>
accepts a string <span class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> if and only if <span
class="math inline">\(\delta^*( ~(q_0,w)~) \in F\)</span>.</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>. By definition,
this means <span class="math inline">\(A\)</span> is a subset of <span
class="math inline">\(\Sigma^*\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span> then there is another DFA, let’s
call it <span class="math inline">\(M&#39;\)</span>, such that <span
class="math inline">\(L(M&#39;) = \overline{A}\)</span>, the complement
of <span class="math inline">\(A\)</span>, defined as <span
class="math inline">\(\{ w \in \Sigma^* \mid w \notin A \}\)</span>.</p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Proof</strong></span>:</p>
<p>Application: Design a finite automaton that recognizes the language
of all strings over <span class="math inline">\(\{a,b\}\)</span> whose
length is not a multiple of <span class="math inline">\(3\)</span>.</p>
<p><span><strong>Note</strong></span>: On Friday, we’ll see a new kind
of finite automaton. It will be helpful to distinguish it from the
machines we’ve been talking about so we’ll use
<span><strong>Deterministic Finite Automaton</strong></span> (DFA) to
refer to the machines from Section 1.1.</p>
<h1 class="unnumbered" id="week2-friday">Week2 friday</h1>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="2" style="text-align: left;"><span><strong>Nondeterministic
finite automaton</strong></span> (Sipser Page 53) Given as <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Finite set of states <span
class="math inline">\(Q\)</span></td>
<td style="text-align: left;">Can be labelled by any collection of
distinct names. Default: <span class="math inline">\(q0, q1,
\ldots\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Alphabet <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">Each input to the automaton is a string
over <span class="math inline">\(\Sigma\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;">Arrow labels <span
class="math inline">\(\Sigma_\varepsilon\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\Sigma_\varepsilon = \Sigma \cup \{
\varepsilon\}\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Arrows in the state diagram are labelled
either by symbols from <span class="math inline">\(\Sigma\)</span> or by
<span class="math inline">\(\varepsilon\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Transition function <span
class="math inline">\(\delta\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\delta: Q
\times \Sigma_{\varepsilon} \to \mathcal{P}(Q)\)</span> gives the
<span><strong>set of possible next states</strong></span> for a
transition</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">from the current state upon reading a
symbol or spontaneously moving.</td>
</tr>
<tr>
<td style="text-align: left;">Start state <span
class="math inline">\(q_0\)</span></td>
<td style="text-align: left;">Element of <span
class="math inline">\(Q\)</span>. Each computation of the machine starts
at the start state.</td>
</tr>
<tr>
<td style="text-align: left;">Accept (final) states <span
class="math inline">\(F\)</span></td>
<td style="text-align: left;"><span class="math inline">\(F
\subseteq  Q\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="2" style="text-align: left;"><span
class="math inline">\(M\)</span> accepts the input string <span
class="math inline">\(w \in \Sigma^*\)</span> if and only if
<span><strong>there is</strong></span> a computation of <span
class="math inline">\(M\)</span> on <span
class="math inline">\(w\)</span> that processes the whole string and
ends in an accept state.</td>
</tr>
</tbody>
</table>
</div>
<p>The formal definition of the NFA over <span
class="math inline">\(\{0,1\}\)</span> given by this state diagram
is:</p>
<p><img src="../../resources/machines/Lect4NFA1.png" style="width:2in"
alt="image" /></p>
<p>The language over <span class="math inline">\(\{0,1\}\)</span>
recognized by this NFA is:</p>
<p>Change the transition function to get a different NFA which accepts
the empty string (and potentially other strings too).</p>
<p>The state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span> is below. The formal definition
of this NFA is:</p>
<p><img src="../../resources/machines/Lect5NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>The language recognized by this NFA is:</p>
<h1 class="unnumbered" id="week1-friday">Week1 friday</h1>
<p><span><strong>Review</strong></span>: Determine whether each
statement below about regular expressions over the alphabet <span
class="math inline">\(\{a,b,c\}\)</span> is true or false:</p>
<p>True or False: <span class="math inline">\(ab  \in L(~ (a \cup
b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(ba \in L( ~ a^* b^*
~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(a \cup
b \cup c)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(~ (a
\cup b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon \in L( ~ aa^*
\cup bb^* ~)\)</span></p>
<p>**This definition was in the pre-class reading** A finite automaton
(FA) is specified by <span class="math inline">\(M = (Q, \Sigma, \delta,
q_0, F)\)</span>. This <span class="math inline">\(5\)</span>-tuple is
called the <span><strong>formal definition</strong></span> of the FA.
The FA can also be represented by its state diagram: with nodes for the
state, labelled edges specifying the transition function, and
decorations on nodes denoting the start and accept states.</p>
<blockquote>
<p>Finite set of states <span class="math inline">\(Q\)</span> can be
labelled by any collection of distinct names. Often we use default state
labels <span class="math inline">\(q0, q1, \ldots\)</span></p>
</blockquote>
<blockquote>
<p>The alphabet <span class="math inline">\(\Sigma\)</span> determines
the possible inputs to the automaton. Each input to the automaton is a
string over <span class="math inline">\(\Sigma\)</span>, and the
automaton “processes” the input one symbol (or character) at a time.</p>
</blockquote>
<blockquote>
<p>The transition function <span class="math inline">\(\delta\)</span>
gives the next state of the automaton based on the current state of the
machine and on the next input symbol.</p>
</blockquote>
<blockquote>
<p>The start state <span class="math inline">\(q_0\)</span> is an
element of <span class="math inline">\(Q\)</span>. Each computation of
the machine starts at the start state.</p>
</blockquote>
<blockquote>
<p>The accept (final) states <span class="math inline">\(F\)</span> form
a subset of the states of the automaton, <span class="math inline">\(F
\subseteq  Q\)</span>. These states are used to flag if the machine
accepts or rejects an input string.</p>
</blockquote>
<blockquote>
<p>The computation of a machine on an input string is a sequence of
states in the machine, starting with the start state, determined by
transitions of the machine as it reads successive input symbols.</p>
</blockquote>
<blockquote>
<p>The finite automaton <span class="math inline">\(M\)</span> accepts
the given input string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in an accept
state. <span class="math inline">\(M\)</span> rejects the given input
string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in a nonaccept
state, that is, a state that is not in <span
class="math inline">\(F\)</span>.</p>
</blockquote>
<blockquote>
<p>The language of <span class="math inline">\(M\)</span>, <span
class="math inline">\(L(M)\)</span>, is defined as the set of all
strings that are each accepted by the machine <span
class="math inline">\(M\)</span>. Each string that is rejected by <span
class="math inline">\(M\)</span> is not in <span
class="math inline">\(L(M)\)</span>. The language of <span
class="math inline">\(M\)</span> is also called the language recognized
by <span class="math inline">\(M\)</span>.</p>
</blockquote>
<p>What is <span><strong>finite</strong></span> about all finite
automata? (Select all that apply)</p>
<ul>
<li><p>The size of the machine (number of states, number of
arrows)</p></li>
<li><p>The length of each computation of the machine</p></li>
<li><p>The number of strings that are accepted by the machine</p></li>
</ul>
<figure>
<img src="../../resources/machines/Lect2DFA1.png" style="width:3in" />
</figure>
<p>The formal definition of this FA is</p>
<p>Classify each string <span class="math inline">\(a, aa, ab, ba, bb,
\varepsilon\)</span> as accepted by the FA or rejected by the FA.</p>
<p><span><em>Why are these the only two options?</em></span></p>
<p>The language recognized by this automaton is</p>
<figure>
<img src="../../resources/machines/Lect2DFA2.png" style="width:3in" />
</figure>
<p>The language recognized by this automaton is</p>
<figure>
<img src="../../resources/machines/Lect2DFA3.png" style="width:3in" />
</figure>
<p>The language recognized by this automaton is</p>
</body>
</html>
