<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>classify-decision-problem</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="week9-monday">Week9 monday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<p><span><em>Last time</em></span> we proved that <span
class="math inline">\(A_{TM} \le_m HALT_{TM}\)</span> where <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span> and since <span class="math inline">\(A_{TM}\)</span> is
undecidable, <span class="math inline">\(HALT_{TM}\)</span> is also
undecidable. The function witnessing the mapping reduction mapped
strings in <span class="math inline">\(A_{TM}\)</span> to strings in
<span class="math inline">\(HALT_{TM}\)</span> and strings not in <span
class="math inline">\(A_{TM}\)</span> to strings not in <span
class="math inline">\(HALT_{TM}\)</span> by changing encoded Turing
machines to ones that had identical computations except looped instead
of rejecting.</p>
<p>True or False: <span class="math inline">\(\overline{A_{TM}} \leq_m
\overline{HALT_{TM}}\)</span></p>
<p>True or False: <span class="math inline">\(HALT_{TM} \leq_m
A_{TM}\)</span>.</p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in HALT_{TM}\)</span> iff <span
class="math inline">\(F(x)  \in  A_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x ,
w\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is in <span
class="math inline">\(A_{TM}\)</span>?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> does not
halt on <span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Theorem</strong></span> (Sipser 5.28): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is recognizable, then <span
class="math inline">\(A\)</span> is recognizable.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Corollary</strong></span>: If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable.</p>
<p><span><em>Strategy</em></span>:</p>
<p>(i) To prove that a recognizable language <span
class="math inline">\(R\)</span> is undecidable, prove that <span
class="math inline">\(A_{TM} \leq_m R\)</span>.</p>
<p>(ii) To prove that a co-recognizable language <span
class="math inline">\(U\)</span> is undecidable, prove that <span
class="math inline">\(\overline{A_{TM}} \leq_m U\)</span>, i.e. that
<span class="math inline">\(A_{TM} \leq_m \overline{U}\)</span>.</p>
<p><span class="math display">\[E_{TM} = \{ \langle M \rangle \mid
\text{$M$ is a Turing machine and $L(M) = \emptyset$} \}\]</span></p>
<p>Can we find algorithms to recognize</p>
<p><span class="math inline">\(E_{TM}\)</span> ?</p>
<p><span class="math inline">\(\overline{E_{TM}}\)</span> ?</p>
<p><span><strong>Claim</strong></span>: <span
class="math inline">\(A_{TM}  \leq_m \overline{E_{TM}}\)</span>.
<span><em>And hence also</em> </span> <span
class="math inline">\(\overline{A_{TM}} \leq_m E_{TM}\)</span></p>
<p><span><strong>Proof</strong></span>: Need computable function <span
class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span> such that <span
class="math inline">\(x \in A_{TM}\)</span> iff <span
class="math inline">\(F(x)  \notin  E_{TM}\)</span>. Define</p>
<blockquote>
<p><span class="math inline">\(F =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_x
\rangle\)</span>."</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in A_{TM}\)</span> iff its image is <span><strong>not</strong></span>
in <span class="math inline">\(E_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \in
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(w \notin
L(M)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="week9-wednesday">Week9 wednesday</h1>
<p>Recall: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_m B\)</span>, means there is a computable function <span
class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span></p>
<p>So far:</p>
<ul>
<li><p><span class="math inline">\(A_{TM}\)</span> is recognizable,
undecidable, and not-co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{A_{TM}}\)</span> is
unrecognizable, undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(HALT_{TM}\)</span> is recognizable,
undecidable, and not-co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{HALT_{TM}}\)</span> is
unrecognizable, undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(E_{TM}\)</span> is unrecognizable,
undecidable, and co-recognizable.</p></li>
<li><p><span class="math inline">\(\overline{E_{TM}}\)</span> is
recognizable, undecidable, and not-co-recognizable.</p></li>
</ul>
<p><span class="math display">\[EQ_{TM} = \{ \langle M, M&#39; \rangle
\mid \text{$M$ and $M&#39;$ are both Turing machines and $L(M)
=L(M&#39;)$} \}\]</span></p>
<p>Can we find algorithms to recognize</p>
<p><span class="math inline">\(EQ_{TM}\)</span> ?</p>
<p><span class="math inline">\(\overline{EQ_{TM}}\)</span> ?</p>
<p><span><em>Goal</em></span>: Show that <span
class="math inline">\(EQ_{TM}\)</span> is not recognizable and that
<span class="math inline">\(\overline{EQ_{TM}}\)</span> is not
recognizable.</p>
<p>Using Corollary to <span><strong>Theorem 5.28</strong></span>: If
<span class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is unrecognizable, then <span
class="math inline">\(B\)</span> is unrecognizable, it’s enough to prove
that</p>
<ul>
<li><p><span class="math inline">\(\overline{HALT_{TM}} \leq_m
EQ_{TM}\)</span> aka <span class="math inline">\(HALT_{TM} \leq_m
\overline{EQ_{TM}}\)</span></p></li>
<li><p><span class="math inline">\(\overline{HALT_{TM}}  \leq_m
\overline{EQ_{TM}}\)</span> aka <span class="math inline">\(HALT_{TM}
\leq_m EQ_{TM}\)</span></p></li>
</ul>
<p>Need computable function <span class="math inline">\(F_1: \Sigma^*
\to \Sigma^*\)</span> such that <span class="math inline">\(x \in
HALT_{TM}\)</span> iff <span
class="math inline">\(F_1(x)  \notin  EQ_{TM}\)</span>.</p>
<p><span><em>Strategy</em></span>:</p>
<p>Map strings <span class="math inline">\(\langle M, w \rangle\)</span>
to strings <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=yellow!40]
      \node[initial,state] (q0)                    {$q_0$};
      \node[state,accepting] (qacc) [right of = q0, xshift =
20]{$q_{acc}$};
      \path (q0) edge  [loop above] node {$0, 1,
\scalebox{1.5}{\textvisiblespace} \to R$} (q0)
     ;
    \end{tikzpicture}}
    \rangle\)</span> . This image string is not in <span
class="math inline">\(EQ_{TM}\)</span> when <span
class="math inline">\(L(M&#39;_x) \neq \emptyset\)</span>.</p>
<p>We will build <span class="math inline">\(M&#39;_x\)</span> so that
<span class="math inline">\(L(M&#39;_{x}) = \Sigma^*\)</span> when <span
class="math inline">\(M\)</span> halts on <span
class="math inline">\(w\)</span> and <span
class="math inline">\(L(M&#39;_x) = \emptyset\)</span> when <span
class="math inline">\(M\)</span> loops on <span
class="math inline">\(w\)</span>.</p>
<p>Thus: when <span class="math inline">\(\langle M,w \rangle \in
HALT_{TM}\)</span> it gets mapped to a string not in <span
class="math inline">\(EQ_{TM}\)</span> and when <span
class="math inline">\(\langle M,w \rangle \notin HALT_{TM}\)</span> it
gets mapped to a string that is in <span
class="math inline">\(EQ_{TM}\)</span>.</p>
<p>Define</p>
<blockquote>
<p><span class="math inline">\(F_1 =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=yellow!40]
      \node[initial,state] (q0)                    {$q_0$};
      \node[state,accepting] (qacc) [right of = q0, xshift =
20]{$q_{acc}$};
      \path (q0) edge  [loop above] node {$0, 1,
\scalebox{1.5}{\textvisiblespace} \to R$} (q0)
     ;
    \end{tikzpicture}}
    \rangle\)</span> "</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is
<span><strong>not</strong></span> in <span
class="math inline">\(EQ_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Conclude: <span class="math inline">\(HALT_{TM} \leq_m
\overline{EQ_{TM}}\)</span></p>
<p>Need computable function <span class="math inline">\(F_2: \Sigma^*
\to \Sigma^*\)</span> such that <span class="math inline">\(x \in
HALT_{TM}\)</span> iff <span
class="math inline">\(F_2(x)  \in  EQ_{TM}\)</span>.</p>
<p><span><em>Strategy</em></span>:</p>
<p>Map strings <span class="math inline">\(\langle M, w \rangle\)</span>
to strings <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=yellow!40]
      \node[initial,state,accepting] (q0)                    {$q_0$};
     ;
    \end{tikzpicture}}
    \rangle\)</span> . This image string is in <span
class="math inline">\(EQ_{TM}\)</span> when <span
class="math inline">\(L(M&#39;_x) = \Sigma^*\)</span>.</p>
<p>We will build <span class="math inline">\(M&#39;_x\)</span> so that
<span class="math inline">\(L(M&#39;_{x}) = \Sigma^*\)</span> when <span
class="math inline">\(M\)</span> halts on <span
class="math inline">\(w\)</span> and <span
class="math inline">\(L(M&#39;_x) = \emptyset\)</span> when <span
class="math inline">\(M\)</span> loops on <span
class="math inline">\(w\)</span>.</p>
<p>Thus: when <span class="math inline">\(\langle M,w \rangle \in
HALT_{TM}\)</span> it gets mapped to a string in <span
class="math inline">\(EQ_{TM}\)</span> and when <span
class="math inline">\(\langle M,w \rangle \notin HALT_{TM}\)</span> it
gets mapped to a string that is not in <span
class="math inline">\(EQ_{TM}\)</span>.</p>
<p>Define</p>
<blockquote>
<p><span class="math inline">\(F_2 =  ``\)</span> On input <span
class="math inline">\(x\)</span>,</p>
<ul>
<li><p>Type-check whether <span class="math inline">\(x = \langle M, w
\rangle\)</span> for some TM <span class="math inline">\(M\)</span> and
string <span class="math inline">\(w\)</span>. If so, move to step 2; if
not, output <span class="math inline">\(\langle \hspace{2in}
\rangle\)</span></p></li>
<li><p>Construct the following machine <span
class="math inline">\(M&#39;_x\)</span>:</p></li>
<li><p>Output <span class="math inline">\(\langle M&#39;_{x},
\scalebox{0.5}{\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten
&gt;=1pt, auto, node distance=2cm, semithick]
      \tikzstyle{every state}=[text=black, fill=yellow!40]
      \node[initial,state,accepting] (q0)                    {$q_0$};
     ;
    \end{tikzpicture}}
    \rangle\)</span> "</p></li>
</ul>
</blockquote>
<p>Verifying correctness: (1) Is function well-defined and computable?
(2) Does it have the translation property <span class="math inline">\(x
\in HALT_{TM}\)</span> iff its image is in <span
class="math inline">\(EQ_{TM}\)</span> ?</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Input string</th>
<th style="text-align: center;">Output string</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> halts on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\langle M, w
\rangle\)</span> where <span class="math inline">\(M\)</span> loops on
<span class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(x\)</span>
not encoding any pair of TM and string</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Conclude: <span class="math inline">\(HALT_{TM} \leq_m
EQ_{TM}\)</span></p>
<h1 class="unnumbered" id="week9-friday">Week9 friday</h1>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p>True / False: NFAs and PDAs are equally expressive.</p>
<p>True / False: Regular expressions and CFGs are equally
expressive.</p>
<p><span><strong>Church-Turing Thesis</strong></span> (Sipser p. 183):
The informal notion of algorithm is formalized completely and correctly
by the formal definition of a Turing machine. In other words: all
reasonably expressive models of computation are equally expressive with
the standard Turing machine.</p>
<div class="center">
<p><span><em>Some examples of models that are <span><strong>equally
expressive</strong></span> with deterministic Turing machines:</em>
</span></p>
</div>
<p>The May-stay machine model is the same as the usual Turing machine
model, except that on each transition, the tape head may move L, move R,
or Stay.</p>
<p>Formally: <span class="math inline">\((Q, \Sigma, \Gamma, \delta,
q_0, q_{accept}, q_{reject})\)</span> where <span
class="math display">\[\delta: Q \times \Gamma \to Q \times \Gamma
\times \{L, R, S\}\]</span></p>
<p><span><strong>Claim</strong></span>: Turing machines and May-stay
machines are equally expressive. <span><em>To prove …</em></span></p>
<p>To translate a standard TM to a may-stay machine: never use the
direction <span class="math inline">\(S\)</span>!</p>
<p>To translate one of the may-stay machines to standard TM: any time TM
would Stay, move right then left.</p>
<p>A multitape Turing macihne with <span
class="math inline">\(k\)</span> tapes can be formally representated as
<span class="math inline">\((Q, \Sigma,  \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math inline">\(Q\)</span> is the
finite set of states, <span class="math inline">\(\Sigma\)</span> is the
input alphabet with <span class="math inline">\(\textvisiblespace \notin
\Sigma\)</span>, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet with <span class="math inline">\(\Sigma \subsetneq
\Gamma\)</span> , <span class="math inline">\(\delta: Q\times
\Gamma^k\to Q \times \Gamma^k \times \{L,R\}^k\)</span> (where <span
class="math inline">\(k\)</span> is the number of states)</p>
<p>If <span class="math inline">\(M\)</span> is a standard TM, it is a
<span class="math inline">\(1\)</span>-tape machine.</p>
<p>To translate a <span class="math inline">\(k\)</span>-tape machine to
a standard TM: Use a new symbol to separate the contents of each tape
and keep track of location of head with special version of each tape
symbol. <span>Sipser Theorem 3.13</span></p>
<p><img src="../../resources/images/Figure314.png" style="width:2.5in"
alt="image" /></p>
<p>Enumerators give a different model of computation where a language is
<span><strong>produced, one string at a time</strong></span>, rather
than recognized by accepting (or not) individual strings.</p>
<p>Each enumerator machine has finite state control, unlimited work
tape, and a printer. The computation proceeds according to transition
function; at any point machine may “send” a string to the printer. <span
class="math display">\[E  = (Q, \Sigma, \Gamma, \delta, q_0,
q_{print})\]</span> <span class="math inline">\(Q\)</span> is the finite
set of states, <span class="math inline">\(\Sigma\)</span> is the output
alphabet, <span class="math inline">\(\Gamma\)</span> is the tape
alphabet (<span class="math inline">\(\Sigma  \subsetneq\Gamma,
\textvisiblespace \in \Gamma \setminus \Sigma\)</span>), <span
class="math display">\[\delta:  Q  \times  \Gamma \times \Gamma \to  Q
\times  \Gamma \times  \Gamma \times \{L, R\} \times  \{L, R\}\]</span>
where in state <span class="math inline">\(q\)</span>, when the working
tape is scanning character <span class="math inline">\(x\)</span> and
the printer tape is scanning character <span
class="math inline">\(y\)</span>, <span class="math inline">\(\delta(
(q,x,y) ) = (q&#39;, x&#39;, y&#39;, d_w, d_p)\)</span> means transition
to control state <span class="math inline">\(q&#39;\)</span>, write
<span class="math inline">\(x&#39;\)</span> on the working tape, write
<span class="math inline">\(y&#39;\)</span> on the printer tape, move in
direction <span class="math inline">\(d_w\)</span> on the working tape,
and move in direction <span class="math inline">\(d_p\)</span> on the
printer tape. The computation starts in <span
class="math inline">\(q_0\)</span> and each time the computation enters
<span class="math inline">\(q_{print}\)</span> the string from the
leftmost edge of the printer tape to the first blank cell is considered
to be printed.</p>
<p>The language <span><strong>enumerated</strong></span> by <span
class="math inline">\(E\)</span>, <span
class="math inline">\(L(E)\)</span>, is <span class="math inline">\(\{ w
\in \Sigma^* \mid \text{$E$ eventually, at finite  time,
prints $w$} \}\)</span>.</p>
<p><span><strong>Theorem 3.21</strong></span> A language is
Turing-recognizable iff some enumerator enumerates it.</p>
<p><span><strong>Proof, part 1</strong></span>: Assume <span
class="math inline">\(L\)</span> is enumerated by some enumerator, <span
class="math inline">\(E\)</span>, so <span class="math inline">\(L =
L(E)\)</span>. We’ll use <span class="math inline">\(E\)</span> in a
subroutine within a high-level description of a new Turing machine that
we will build to recognize <span class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build Turing machine <span
class="math inline">\(M_E\)</span> with <span
class="math inline">\(L(M_E) = L(E)\)</span>.</p>
<p>Define <span class="math inline">\(M_E\)</span> as follows: <span
class="math inline">\(M_E =\)</span> “On input <span
class="math inline">\(w\)</span>,</p>
<ol>
<li><p>Run <span class="math inline">\(E\)</span>. For each string <span
class="math inline">\(x\)</span> printed by <span
class="math inline">\(E\)</span>.</p></li>
<li><p>Check if <span class="math inline">\(x = w\)</span>. If so,
accept (and halt); otherwise, continue."</p></li>
</ol>
<p><span><strong>Proof, part 2</strong></span>: Assume <span
class="math inline">\(L\)</span> is Turing-recognizable and there is a
Turing machine <span class="math inline">\(M\)</span> with <span
class="math inline">\(L = L(M)\)</span>. We’ll use <span
class="math inline">\(M\)</span> in a subroutine within a high-level
description of an enumerator that we will build to enumerate <span
class="math inline">\(L\)</span>.</p>
<p><span><strong>Goal</strong></span>: build enumerator <span
class="math inline">\(E_M\)</span> with <span
class="math inline">\(L(E_M) = L(M)\)</span>.</p>
<p><span><strong>Idea</strong></span>: check each string in turn to see
if it is in <span class="math inline">\(L\)</span>.</p>
<p><span><em>How?</em></span> Run computation of <span
class="math inline">\(M\)</span> on each string.
<span><em>But</em></span>: need to be careful about computations that
don’t halt.</p>
<p><span><em>Recall</em></span> String order for <span
class="math inline">\(\Sigma = \{0,1\}\)</span>: <span
class="math inline">\(s_1 = \varepsilon\)</span>, <span
class="math inline">\(s_2 = 0\)</span>, <span class="math inline">\(s_3
= 1\)</span>, <span class="math inline">\(s_4 = 00\)</span>, <span
class="math inline">\(s_5 = 01\)</span>, <span
class="math inline">\(s_6  = 10\)</span>, <span
class="math inline">\(s_7  =  11\)</span>, <span
class="math inline">\(s_8 = 000\)</span>, …</p>
<p>Define <span class="math inline">\(E_M\)</span> as follows: <span
class="math inline">\(E_{M} =\)</span> “ <span><em>ignore any
input.</em></span> Repeat the following for <span
class="math inline">\(i=1, 2, 3, \ldots\)</span></p>
<ol>
<li><p>Run the computations of <span class="math inline">\(M\)</span> on
<span class="math inline">\(s_1\)</span>, <span
class="math inline">\(s_2\)</span>, …, <span
class="math inline">\(s_i\)</span> for (at most) <span
class="math inline">\(i\)</span> steps each</p></li>
<li><p>For each of these <span class="math inline">\(i\)</span>
computations that accept during the (at most) <span
class="math inline">\(i\)</span> steps, print out the accepted
string."</p></li>
</ol>
<p>At any point in the computation, the nondeterministic machine may
proceed according to several possibilities: <span
class="math inline">\((Q, \Sigma, \Gamma, \delta, q_0, q_{acc},
q_{rej})\)</span> where <span class="math display">\[\delta: Q \times
\Gamma \to \mathcal{P}(Q \times \Gamma \times \{L, R\})\]</span> The
computation of a nondeterministic Turing machine is a tree with
branching when the next step of the computation has multiple
possibilities. A nondeterministic Turing machine accepts a string
exactly when some branch of the computation tree enters the accept
state.</p>
<p>Given a nondeterministic machine, we can use a <span
class="math inline">\(3\)</span>-tape Turing machine to simulate it by
doing a breadth-first search of computation tree: one tape is
“read-only” input tape, one tape simulates the tape of the
nondeterministic computation, and one tape tracks nondeterministic
branching. <span>Sipser page 178</span></p>
<p><span><strong>Summary</strong></span></p>
<p>Two models of computation are called <span><strong>equally
expressive</strong></span> when every language recognizable with the
first model is recognizable with the second, and vice versa.</p>
<p>To prove the existence of a Turing machine that decides / recognizes
some language, it’s enough to construct an example using any of the
equally expressive models.</p>
<p>But: some of the <span><strong>performance</strong></span> properties
of these models are not equivalent.</p>
<h1 class="unnumbered" id="week8-monday">Week8 monday</h1>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(A_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M,w
\rangle \mid  \text{$M$ is a Turing machine that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(E_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle M
\rangle \mid  \text{$M$ is a Turing machine and  $L(M) =
\emptyset$\}}\)</span></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;">for Turing machines</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{TM}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{
\langle  M_1, M_2 \rangle \mid  \text{$M_1$ and $M_2$ are Turing
machines and  
     $L(M_1) =L(M_2)$\}}\)</span></td>
</tr>
</tbody>
</table>
</div>
<div class="multicols">
<p><span>3</span> <span class="math inline">\(M_1\)</span> <img
src="../../resources/machines/Week8WarmupTM1.png" style="width:2in"
alt="image" /></p>
<p><span class="math inline">\(M_2\)</span> <img
src="../../resources/machines/Week8WarmupTM2.png" style="width:2in"
alt="image" /></p>
<p><span class="math inline">\(M_3\)</span> <img
src="../../resources/machines/Week8WarmupTM3.png" style="width:2in"
alt="image" /></p>
</div>
<p>Example strings in <span class="math inline">\(A_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(E_{TM}\)</span></p>
<p>Example strings in <span class="math inline">\(EQ_{TM}\)</span></p>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is Turing-recognizable.</p>
<p><span><strong>Strategy</strong></span>: To prove this theorem, we
need to define a Turing machine <span
class="math inline">\(R_{ATM}\)</span> such that <span
class="math inline">\(L(R_{ATM}) = A_{TM}\)</span>.</p>
<p>Define <span class="math inline">\(R_{ATM} =\)</span> “</p>
<p>Proof of correctness:</p>
<p>We will show that <span class="math inline">\(A_{TM}\)</span> is
undecidable. <span><em>First, let’s explore what that
means.</em></span></p>
<p>To prove that a computational problem is
<span><strong>decidable</strong></span>, we find/ build a Turing machine
that recognizes the language encoding the computational problem, and
that is a decider.</p>
<p>How do we prove a specific problem is <span><strong>not
decidable</strong></span>?</p>
<p>How would we even find such a computational problem?</p>
<p><span><em>Counting arguments for the existence of an undecidable
language:</em></span></p>
<ul>
<li><p>The set of all Turing machines is countably infinite.</p></li>
<li><p>Each recognizable language has at least one Turing machine that
recognizes it (by definition), so there can be no more
Turing-recognizable languages than there are Turing machines.</p></li>
<li><p>Since there are infinitely many Turing-recognizable languages
(think of the singleton sets), there are countably infinitely many
Turing-recognizable languages.</p></li>
<li><p>Such the set of Turing-decidable languages is an infinite subset
of the set of Turing-recognizable languages, the set of Turing-decidable
languages is also countably infinite.</p></li>
</ul>
<p>Since there are uncountably many languages (because <span
class="math inline">\(\mathcal{P}(\Sigma^*)\)</span> is uncountable),
there are uncountably many unrecognizable languages and there are
uncountably many undecidable languages.</p>
<p>Thus, there’s at least one undecidable language!</p>
<p><span><strong>What’s a specific example of a language that is
unrecognizable or undecidable?</strong></span></p>
<p>To prove that a language is undecidable, we need to prove that there
is no Turing machine that decides it.</p>
<p><span><strong>Key idea</strong></span>: proof by contradiction
relying on self-referential disagreement.</p>
<p><span><strong>Theorem</strong></span>: <span
class="math inline">\(A_{TM}\)</span> is not Turing-decidable.</p>
<p><span><strong>Proof</strong></span>: Suppose <span><strong>towards a
contradiction</strong></span> that there is a Turing machine that
decides <span class="math inline">\(A_{TM}\)</span>. We call this
presumed machine <span class="math inline">\(M_{ATM}\)</span>.</p>
<p>By assumption, for every Turing machine <span
class="math inline">\(M\)</span> and every string <span
class="math inline">\(w\)</span></p>
<ul>
<li><p>If <span class="math inline">\(w \in L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
<li><p>If <span class="math inline">\(w \notin L(M)\)</span>, then the
computation of <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M,w \rangle ~~
\underline{\phantom{\hspace{2.5in}}}\)</span></p></li>
</ul>
<p>Define a <span><strong>new</strong></span> Turing machine using the
high-level description:</p>
<blockquote>
<p><span class="math inline">\(D =\)</span>“ On input <span
class="math inline">\(\langle M \rangle\)</span>, where <span
class="math inline">\(M\)</span> is a Turing machine:</p>
<ul>
<li><p>Run <span class="math inline">\(M_{ATM}\)</span> on <span
class="math inline">\(\langle M, \langle M
\rangle  \rangle\)</span>.</p></li>
<li><p>If <span class="math inline">\(M_{ATM}\)</span> accepts, reject;
if <span class="math inline">\(M_{ATM}\)</span> rejects,
accept."</p></li>
</ul>
</blockquote>
<p>Is <span class="math inline">\(D\)</span> a Turing machine?</p>
<p>Is <span class="math inline">\(D\)</span> a decider?</p>
<p>What is the result of the computation of <span
class="math inline">\(D\)</span> on <span class="math inline">\(\langle
D \rangle\)</span>?</p>
<p>Definition: A language <span class="math inline">\(L\)</span> over an
alphabet <span class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</p>
<p><span><strong>Theorem</strong></span> (Sipser Theorem 4.22): A
language is Turing-decidable if and only if both it and its complement
are Turing-recognizable.</p>
<p><span><strong>Proof, first direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-decidable. WTS
that both it and its complement are Turing-recognizable.</p>
<p><span><strong>Proof, second direction:</strong></span> Suppose
language <span class="math inline">\(L\)</span> is Turing-recognizable,
and so is its complement. WTS that <span
class="math inline">\(L\)</span> is Turing-decidable.</p>
<p>Notation: The complement of a set <span
class="math inline">\(X\)</span> is denoted with a superscript <span
class="math inline">\(c\)</span>, <span
class="math inline">\(X^c\)</span>, or an overline, <span
class="math inline">\(\overline{X}\)</span>.</p>
<h1 class="unnumbered" id="week8-wednesday">Week8 wednesday</h1>
<p><span><strong>Mapping reduction</strong></span></p>
<p>Motivation: Proving that <span class="math inline">\(A_{TM}\)</span>
is undecidable was hard. How can we leverage that work? Can we relate
the decidability / undecidability of one problem to another?</p>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(Y\)</span> is easy,</p>
<p>…then <span class="math inline">\(X\)</span> must be easy too.</p>
</blockquote>
<blockquote>
<p>If problem <span class="math inline">\(X\)</span> is <span><strong>no
harder than</strong></span> problem <span
class="math inline">\(Y\)</span></p>
<p>…and if <span class="math inline">\(X\)</span> is hard,</p>
<p>…then <span class="math inline">\(Y\)</span> must be hard too.</p>
</blockquote>
<p>“Problem <span class="math inline">\(X\)</span> is no harder than
problem <span class="math inline">\(Y\)</span>” means “Can answer
questions about membership in <span class="math inline">\(X\)</span> by
converting them to questions about membership in <span
class="math inline">\(Y\)</span>”.</p>
<p>Definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>TODO</strong></span></p>
<ol>
<li><p>What is a computable function?</p></li>
<li><p>How do mapping reductions help establish the computational
difficulty of languages?</p></li>
</ol>
<p><span><strong>Computable functions</strong></span></p>
<p>Definition: A function <span class="math inline">\(f: \Sigma^* \to
\Sigma^*\)</span> is a <span><strong>computable function</strong></span>
means there is some Turing machine such that, for each <span
class="math inline">\(x\)</span>, on input <span
class="math inline">\(x\)</span> the Turing machine halts with exactly
<span class="math inline">\(f(x)\)</span> followed by all blanks on the
tape</p>
<p><span><em>Examples of computable functions</em></span>:</p>
<p>The function that maps a string to a string which is one character
longer and whose value, when interpreted as a fixed-width binary
representation of a nonnegative integer is twice the value of the input
string (when interpreted as a fixed-width binary representation of a
non-negative integer) <span class="math display">\[f_1: \Sigma^* \to
\Sigma^* \qquad  f_1(x)  = x0\]</span></p>
<p>To prove <span class="math inline">\(f_1\)</span> is computable
function, we define a Turing machine computing it.</p>
<p><span><em>High-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Append <span class="math inline">\(0\)</span> to <span
class="math inline">\(w\)</span>.</p>
<p>2. Halt.”</p>
</blockquote>
<p><span><em>Implementation-level description</em></span></p>
<blockquote>
<p>“On input <span class="math inline">\(w\)</span></p>
<p>1. Sweep read-write head to the right until find first blank
cell.</p>
<p>2. Write 0.</p>
<p>3. Halt.”</p>
</blockquote>
<p><span><em>Formal definition</em></span> <span
class="math inline">\((\{q0, qacc, qrej\}, \{0,1\},
\{0,1,\textvisiblespace\},\delta, q0, qacc, qrej)\)</span> where <span
class="math inline">\(\delta\)</span> is specified by the state
diagram:</p>
<p>The function that maps a string to the result of repeating the string
twice. <span class="math display">\[f_2: \Sigma^* \to \Sigma^* \qquad
f_2( x )  =  xx\]</span></p>
<p>The function that maps strings that are not the codes of NFAs to the
empty string and that maps strings that code NFAs to the code of a DFA
that recognizes the language recognized by the NFA produced by the
macro-state construction from Chapter 1.</p>
<p>The function that maps strings that are not the codes of Turing
machines to the empty string and that maps strings that code Turing
machines to the code of the related Turing machine that acts like the
Turing machine coded by the input, except that if this Turing machine
coded by the input tries to reject, the new machine will go into a loop.
<span class="math display">\[f_4: \Sigma^* \to \Sigma^*  \qquad f_4( x
)  =   \begin{cases}  \varepsilon \qquad&amp;\text{if $x$ is not the
code of  a TM} \\
\langle (Q \cup \{q_{trap} \}, \Sigma, \Gamma, \delta&#39;, q_0,
q_{acc}, q_{rej} ) \rangle \qquad&amp;\text{if $x = \langle (Q, \Sigma,
\Gamma, \delta, q_0, q_{acc}, q_{rej} )\rangle$}\end{cases}\]</span>
where <span class="math inline">\(q_{trap} \notin Q\)</span> and <span
class="math display">\[\delta&#39;( (q,x) ) = \begin{cases}
(r,y,d) &amp;\text{if $q \in Q$, $x \in \Gamma$, $\delta ((q,x)) =
(r,y,d)$, and  $r \neq  q_{rej}$} \\
(q_{trap}, \textvisiblespace, R) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>Definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span></p>
<p><span><em>Making intutition precise …</em></span></p>
<p><span><strong>Theorem</strong></span> (Sipser 5.22): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(B\)</span> is decidable, then <span
class="math inline">\(A\)</span> is decidable.</p>
<p><span><strong>Theorem</strong></span> (Sipser 5.23): If <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(A\)</span> is undecidable, then <span
class="math inline">\(B\)</span> is undecidable.</p>
<h1 class="unnumbered" id="week8-friday">Week8 friday</h1>
<p>Recall definition: <span class="math inline">\(A\)</span> is
<span><strong>mapping reducible to</strong></span> <span
class="math inline">\(B\)</span> means there is a computable function
<span class="math inline">\(f : \Sigma^* \to \Sigma^*\)</span> such that
<span><em>for all</em></span> strings <span
class="math inline">\(x\)</span> in <span
class="math inline">\(\Sigma^*\)</span>, <span
class="math display">\[x  \in  A \qquad \qquad \text{if and  only  if}
\qquad \qquad f(x) \in B.\]</span> Notation: when <span
class="math inline">\(A\)</span> is mapping reducible to <span
class="math inline">\(B\)</span>, we write <span
class="math inline">\(A  \leq_m B\)</span>.</p>
<p><span><em>Intuition:</em></span> <span class="math inline">\(A \leq_m
B\)</span> means <span class="math inline">\(A\)</span> is no harder
than <span class="math inline">\(B\)</span>, i.e. that the level of
difficulty of <span class="math inline">\(A\)</span> is less than or
equal the level of difficulty of <span
class="math inline">\(B\)</span>.</p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{TM}
\leq_m A_{TM}\)</span></p>
<p><span><em>Example</em></span>: <span class="math inline">\(A_{DFA}
\leq_m \{ ww \mid  w \in \{0,1\}^* \}\)</span></p>
<p><span><strong>Halting problem</strong></span> <span
class="math display">\[HALT_{TM} = \{ \langle M, w \rangle \mid
\text{$M$ is a  Turing machine, $w$ is  a string, and $M$ halts on $w$}
\}\]</span></p>
<p>Define <span class="math inline">\(F: \Sigma^* \to \Sigma^*\)</span>
by <span class="math display">\[F(x) =  \begin{cases}
    const_{out} \qquad &amp;\text{if  $x \neq \langle M,w \rangle$ for
any Turing machine  $M$ and string  $w$ over the alphabet of $M$} \\
    \langle M&#39;, w \rangle \qquad &amp;  \text{if $x = \langle M, w
\rangle$ for some Turing machine  $M$ and string $w$ over the alphabet
of $M$.}
    \end{cases}\]</span> where <span
class="math inline">\(const_{out}  =  \langle  \includegraphics[width=1.5in]{../../resources/machines/Lect22TM1.png}
,  \varepsilon  \rangle\)</span> and <span
class="math inline">\(M&#39;\)</span> is a Turing machine that computes
like <span class="math inline">\(M\)</span> except, if the computation
ever were to go to a reject state, <span
class="math inline">\(M&#39;\)</span> loops instead.</p>
<p><span class="math inline">\(F( \langle
\includegraphics[width=2.5in]{../../resources/machines/Lect22TM2.png}
,  \varepsilon  \rangle)\)</span> =</p>
<p>To use this function to prove that <span class="math inline">\(A_{TM}
\leq_m HALT_{TM}\)</span>, we need two claims:</p>
<p>Claim (1): <span class="math inline">\(F\)</span> is computable</p>
<p>Claim (2): for every <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \in  A_{TM}\)</span> iff <span
class="math inline">\(F(x) \in HALT_{TM}\)</span>.</p>
<h1 class="unnumbered" id="week7-wednesday">Week7 wednesday</h1>
<p><span><strong>The Church-Turing thesis posits that each algorithm can
be implemented by some Turing machine.</strong></span></p>
<p><span><strong>Describing algorithms</strong></span> (Sipser p. 185)
To define a Turing machine, we could give a</p>
<ul>
<li><p><span><strong>Formal definition</strong></span>: the <span
class="math inline">\(7\)</span>-tuple of parameters including set of
states, input alphabet, tape alphabet, transition function, start state,
accept state, and reject state. This is the low-level programming view
that models the logic computation flow in a processor.</p></li>
<li><p><span><strong>Implementation-level definition</strong></span>:
English prose that describes the Turing machine head movements relative
to contents of tape, and conditions for accepting / rejecting based on
those contents. This level describes memory management and implementing
data access with data structures.</p>
<ul>
<li><p>Mention the tape or its contents (e.g. “Scan the tape from left
to right until a blank is seen.”)</p></li>
<li><p>Mention the tape head (e.g. “Return the tape head to the left end
of the tape.”)</p></li>
</ul></li>
<li><p><span><strong>High-level description</strong></span> of algorithm
executed by Turing machine: description of algorithm (precise sequence
of instructions), without implementation details of machine. High-level
descriptions of Turing machine algorithms are written as indented text
within quotation marks. Stages of the algorithm are typically numbered
consecutively. The first line specifies the input to the machine, which
must be a string.</p>
<ul>
<li><p>Use other Turing machines as subroutines (e.g. “Run <span
class="math inline">\(M\)</span> on <span
class="math inline">\(w\)</span>”)</p></li>
<li><p>Build new machines from existing machines using previously shown
results (e.g. “Given NFA <span class="math inline">\(A\)</span>
construct an NFA <span class="math inline">\(B\)</span> such that <span
class="math inline">\(L(B) = \overline{L(A)}\)</span>”)</p></li>
<li><p>Use previously shown conversions and constructions (e.g. “Convert
regular expression <span class="math inline">\(R\)</span> to an NFA
<span class="math inline">\(N\)</span>”)</p></li>
</ul></li>
</ul>
<p><span><strong>Formatted inputs to Turing machine
algorithms</strong></span></p>
<p>The input to a Turing machine is always a string. The format of the
input to a Turing machine can be checked to interpret this string as
representing structured data (like a csv file, the formal definition of
a DFA, another Turing machine, etc.)</p>
<p>This string may be the encoding of some object or list of
objects.</p>
<p><span><strong>Notation:</strong></span> <span
class="math inline">\(\langle O \rangle\)</span> is the string that
encodes the object <span class="math inline">\(O\)</span>. <span
class="math inline">\(\langle O_1, \ldots, O_n \rangle\)</span> is the
string that encodes the list of objects <span class="math inline">\(O_1,
\ldots, O_n\)</span>.</p>
<p><span><strong>Assumption</strong></span>: There are algorithms
(Turing machines) that can be called as subroutines to decode the string
representations of common objects and interact with these objects as
intended (data structures). These algorithms are able to “type-check”
and string representations for different data structures are unique.</p>
<p>For example, since there are algorithms to answer each of the
following questions, by Church-Turing thesis, there is a Turing machine
that accepts exactly those strings for which the answer to the question
is “yes”</p>
<ul>
<li><p>Does a string over <span class="math inline">\(\{0,1\}\)</span>
have even length?</p></li>
<li><p>Does a string over <span class="math inline">\(\{0,1\}\)</span>
encode a string of ASCII characters?<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p>Does a DFA have a specific number of states?</p></li>
<li><p>Do two NFAs have any state names in common?</p></li>
<li><p>Do two CFGs have the same start variable?</p></li>
</ul>
<p>A <span><strong>computational problem</strong></span> is decidable
iff language encoding its positive problem instances is decidable.</p>
<p>The computational problem “Does a specific DFA accept a given
string?” is encoded by the language <span
class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of DFAs $M$ and strings $w$ such that
$w \in L(M)$}\}  \\
  =&amp; \{ \langle M, w \rangle \mid M \textrm{ is a DFA}, w \textrm{
is a string}, w \in L(M) \}
\end{aligned}\]</span></p>
<p>The computational problem “Is the language generated by a CFG empty?”
is encoded by the language <span class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of CFGs $G$  such that $L(G) =
\emptyset$}\}  \\
  =&amp; \{ \langle G \rangle \mid G \textrm{ is a CFG},  L(G) =
\emptyset \}
\end{aligned}\]</span></p>
<p>The computational problem “Is the given Turing machine a decider?” is
encoded by the language <span class="math display">\[\begin{aligned}
  &amp;\{ \textrm{representations of TMs $M$  such that $M$ halts on
every input}\}  \\
  =&amp; \{ \langle M \rangle \mid M \textrm{ is a TM and for each
string } w, \textrm{$M$ halts on $w$} \}
\end{aligned}\]</span></p>
<p><span><em>Note: writing down the language encoding a computational
problem is only the first step in determining if it’s recognizable,
decidable, or …</em></span></p>
<p>Deciding a computational problem means building / defining a Turing
machine that recognizes the language encoding the computational problem,
and that is a decider.</p>
<h1 class="unnumbered" id="week7-friday">Week7 friday</h1>
<p>Some classes of computational problems will help us understand the
differences between the machine models we’ve been studying. (Sipser
Section 4.1)</p>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Acceptance
problem</strong></span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  DFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a  NFA that accepts input
    string $w$}\}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(A_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R,w
\rangle \mid  \text{$R$ is a  regular
    expression that generates input string $w$}\}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(A_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G,w
\rangle \mid  \text{$G$ is a context-free grammar
    that generates input string $w$}\}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(A_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle B,w
\rangle \mid  \text{$B$ is a PDA that accepts input string
$w$}\}\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
emptiness testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A
\rangle \mid  \text{$A$ is a  DFA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle
A\rangle \mid  \text{$A$ is a NFA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(E_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R
\rangle \mid  \text{$R$ is a  regular
    expression and  $L(R) = \emptyset$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(E_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G
\rangle \mid  \text{$G$ is a context-free grammar
    and  $L(G) = \emptyset$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(E_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A
\rangle \mid  \text{$A$ is a PDA and  $L(A) =
\emptyset$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="3" style="text-align: left;"><span><strong>Language
equality testing</strong></span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">…for DFA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are DFAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for NFA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{NFA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are NFAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for regular expressions</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{REX}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle R,
R&#39; \rangle \mid  \text{$R$ and $R&#39;$ are regular
    expressions and  $L(R) =L(R&#39;)$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for CFG</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{CFG}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle G,
G&#39; \rangle \mid  \text{$G$ and $G&#39;$ are CFGs and  $L(G)
=L(G&#39;)$\}}\)</span></td>
</tr>
<tr>
<td style="text-align: left;">…for PDA</td>
<td style="text-align: center;"><span
class="math inline">\(EQ_{PDA}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\{ \langle A,
B \rangle \mid  \text{$A$ and $B$ are PDAs and  $L(A)
=L(B)$\}}\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Example strings in <span class="math inline">\(A_{DFA}\)</span></p>
<p>Example strings in <span class="math inline">\(E_{DFA}\)</span></p>
<p>Example strings in <span class="math inline">\(EQ_{DFA}\)</span></p>
<blockquote>
<p><span class="math inline">\(M_1 =\)</span> “On input <span
class="math inline">\(\langle M,w\rangle\)</span>, where <span
class="math inline">\(M\)</span> is a DFA and <span
class="math inline">\(w\)</span> is a string:</p>
<ol start="0">
<li><p>Type check encoding to check input is correct type. If not,
reject.</p></li>
<li><p>Simulate <span class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span> (by keeping track of states in <span
class="math inline">\(M\)</span>, transition function of <span
class="math inline">\(M\)</span>, etc.)</p></li>
<li><p>If the simulations ends in an accept state of <span
class="math inline">\(M\)</span>, accept. If it ends in a non-accept
state of <span class="math inline">\(M\)</span>, reject. "</p></li>
</ol>
</blockquote>
<p>What is <span class="math inline">\(L(M_1)\)</span>?</p>
<p>Is <span class="math inline">\(M_1\)</span> a decider?</p>
<p><span><em>Alternate description</em></span>: Sometimes omit step 0
from listing and do implicit type check.</p>
<p>Synonyms: “Simulate”, “run”, “call”.</p>
<p>True / False: <span class="math inline">\(A_{REX} = A_{NFA} =
A_{DFA}\)</span></p>
<p>True / False: <span class="math inline">\(A_{REX} \cap A_{NFA} =
\emptyset\)</span>, <span class="math inline">\(A_{REX} \cap A_{DFA} =
\emptyset\)</span>, <span class="math inline">\(A_{DFA} \cap A_{NFA} =
\emptyset\)</span></p>
<p>A Turing machine that decides <span
class="math inline">\(A_{NFA}\)</span> is:</p>
<p>A Turing machine that decides <span
class="math inline">\(A_{REX}\)</span> is:</p>
<p><span class="math inline">\(E_{DFA} = \{ \langle A \rangle
\mid  \text{$A$ is a  DFA and  $L(A) = \emptyset$}\}\)</span>.
True/False: A Turing machine that decides <span
class="math inline">\(E_{DFA}\)</span> is</p>
<blockquote>
<p><span class="math inline">\(M_2 =\)</span>“On input <span
class="math inline">\(\langle M\rangle\)</span> where <span
class="math inline">\(M\)</span> is a DFA,</p>
<ol>
<li><p>For integer <span class="math inline">\(i = 1, 2,
\ldots\)</span></p></li>
<li><p>Let <span class="math inline">\(s_i\)</span> be the <span
class="math inline">\(i\)</span>th string over the alphabet of <span
class="math inline">\(M\)</span> (ordered in string order).</p></li>
<li><p>Run <span class="math inline">\(M\)</span> on input <span
class="math inline">\(s_i\)</span>.</p></li>
<li><p>If <span class="math inline">\(M\)</span> accepts, <span
class="math inline">\(\underline{\phantom{FILL  IN BLANK}}\)</span>. If
<span class="math inline">\(M\)</span> rejects, increment <span
class="math inline">\(i\)</span> and keep going."</p></li>
</ol>
</blockquote>
<p>Choose the correct option to help fill in the blank so that <span
class="math inline">\(M_2\)</span> recognizes <span
class="math inline">\(E_{DFA}\)</span></p>
<ul>
<li><p>accepts</p></li>
<li><p>rejects</p></li>
<li><p>loop for ever</p></li>
<li><p>We can’t fill in the blank in any way to make this work</p></li>
</ul>
<blockquote>
<p><span class="math inline">\(M_3 =\)</span> “ On input <span
class="math inline">\(\langle M \rangle\)</span> where <span
class="math inline">\(M\)</span> is a DFA,</p>
<ol>
<li><p>Mark the start state of <span
class="math inline">\(M\)</span>.</p></li>
<li><p>Repeat until no new states get marked:</p></li>
<li><p>Loop over the states of <span
class="math inline">\(M\)</span>.</p></li>
<li><p>Mark any unmarked state that has an incoming edge from a marked
state.</p></li>
<li><p>If no accept state of <span class="math inline">\(A\)</span> is
marked, <span class="math inline">\(\underline{\phantom{FILL  IN
BLANK}}\)</span>; otherwise, <span
class="math inline">\(\underline{\phantom{FILL  IN
BLANK}}\)</span>".</p></li>
</ol>
</blockquote>
<p>To build a Turing machine that decides <span
class="math inline">\(EQ_{DFA}\)</span>, notice that <span
class="math display">\[L_1 = L_2 \qquad\textrm{iff}\qquad (~(L_1 \cap
\overline{L_2}) \cup (L_2 \cap \overline L_1)~) = \emptyset\]</span>
<span><em>There are no elements that are in one set and not the
other</em></span></p>
<p><span class="math inline">\(M_{EQDFA} =\)</span></p>
<p><span><strong>Summary</strong></span>: We can use the decision
procedures (Turing machines) of decidable problems as subroutines in
other algorithms. For example, we have subroutines for deciding each of
<span class="math inline">\(A_{DFA}\)</span>, <span
class="math inline">\(E_{DFA}\)</span>, <span
class="math inline">\(EQ_{DFA}\)</span>. We can also use algorithms for
known constructions as subroutines in other algorithms. For example, we
have subroutines for: counting the number of states in a state diagram,
counting the number of characters in an alphabet, converting DFA to a
DFA recognizing the complement of the original language or a DFA
recognizing the Kleene star of the original language, constructing a DFA
or NFA from two DFA or NFA so that we have a machine recognizing the
language of the union (or intersection, concatenation) of the languages
of the original machines; converting regular expressions to equivalent
DFA; converting DFA to equivalent regular expressions, etc.</p>
<h1 class="unnumbered" id="week10-monday">Week10 monday</h1>
<p>In practice, computers (and Turing machines) don’t have infinite
tape, and we can’t afford to wait unboundedly long for an answer.
“Decidable" isn’t good enough - we want “Efficiently decidable".</p>
<p>For a given algorithm working on a given input, how long do we need
to wait for an answer? How does the running time depend on the input in
the worst-case? average-case? We expect to have to spend more time on
computations with larger inputs.</p>
<p>A language is <span><strong>recognizable</strong></span> if
<u></u></p>
<p>A language is <span><strong>decidable</strong></span> if <u></u></p>
<p>A language is <span><strong>efficiently decidable</strong></span> if
<u></u></p>
<p>A function is <span><strong>computable</strong></span> if <u></u></p>
<p>A function is <span><strong>efficiently computable</strong></span> if
<u></u><br />
</p>
<p>Definition (Sipser 7.1): For <span class="math inline">\(M\)</span> a
deterministic decider, its <span><strong>running time</strong></span> is
the function <span class="math inline">\(f: \mathbb{N} \to
\mathbb{N}\)</span> given by <span class="math display">\[f(n)
=  \text{max number of  steps $M$ takes before halting, over all
inputs  of length $n$}\]</span></p>
<p>Definition (Sipser 7.7): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>time complexity
class</strong></span> <span class="math inline">\(TIME(t(n))\)</span>,
is defined by <span class="math display">\[TIME( t(n)) = \{ L \mid
\text{$L$ is decidable by  a Turing machine with running time
in  $O(t(n))$} \}\]</span></p>
<p>An example of an element of <span
class="math inline">\(TIME(  1  )\)</span> is</p>
<p>An example of an element of <span
class="math inline">\(TIME(  n  )\)</span> is</p>
<p>Note: <span class="math inline">\(TIME( 1) \subseteq TIME
(n)  \subseteq TIME(n^2)\)</span></p>
<p>Definition (Sipser 7.12) : <span class="math inline">\(P\)</span> is
the class of languages that are decidable in polynomial time on a
deterministic 1-tape Turing machine <span
class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p><span><em>Compare to exponential time: brute-force
search.</em></span></p>
<p>Theorem (Sipser 7.8): Let <span class="math inline">\(t(n)\)</span>
be a function with <span class="math inline">\(t(n)  \geq n\)</span>.
Then every <span class="math inline">\(t(n)\)</span> time deterministic
multitape Turing machine has an equivalent <span
class="math inline">\(O(t^2(n))\)</span> time deterministic 1-tape
Turing machine.</p>
<p>Definition (Sipser 7.1): For <span class="math inline">\(M\)</span> a
deterministic decider, its <span><strong>running time</strong></span> is
the function <span class="math inline">\(f: \mathbb{N} \to
\mathbb{N}\)</span> given by <span class="math display">\[f(n)
=  \text{max number of  steps $M$ takes before halting, over all
inputs  of length $n$}\]</span></p>
<p>Definition (Sipser 7.7): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>time complexity
class</strong></span> <span class="math inline">\(TIME(t(n))\)</span>,
is defined by <span class="math display">\[TIME( t(n)) = \{ L \mid
\text{$L$ is decidable by  a Turing machine with running time
in  $O(t(n))$} \}\]</span> Definition (Sipser 7.12) : <span
class="math inline">\(P\)</span> is the class of languages that are
decidable in polynomial time on a deterministic 1-tape Turing machine
<span class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq TIME(n^2)\)</span></p>
<p><span><strong>Every problem in NP is decidable with an
exponential-time algorithm</strong></span></p>
<p>Nondeterministic approach: guess a possible solution, verify that it
works.</p>
<p>Brute-force (worst-case exponential time) approach: iterate over all
possible solutions, for each one, check if it works.</p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[HAMPATH = \{\langle G,s,t \rangle \mid
\textrm{$G$ is digraph with $n$ nodes, there is path
from $s$ to $t$ that goes through every node exactly once}\}\]</span>
<span class="math display">\[VERTEX-COVER = \{ \langle G,k\rangle \mid
\textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(P\)</span></strong></span></th>
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(NP\)</span></strong></span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">(Membership in any) regular
language</td>
<td style="text-align: center;">Any problem in <span
class="math inline">\(P\)</span></td>
</tr>
<tr>
<td style="text-align: center;">(Membership in any) context-free
language</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(SAT\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(CLIQUE\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(VERTEX-COVER\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(PATH\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(HAMPATH\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(RELPRIME\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong></strong></span> Notice: <span class="math inline">\(NP
\subseteq \{ L \mid L \text{ is decidable} \}\)</span> so <span
class="math inline">\(A_{TM} \notin NP\)</span></p>
<p>Million-dollar question: Is <span class="math inline">\(P =
NP\)</span>?</p>
<p>One approach to trying to answer it is to look for
<span><em>hardest</em></span> problems in <span
class="math inline">\(NP\)</span> and then (1) if we can show that there
are efficient algorithms for them, then we can get efficient algorithms
for all problems in <span class="math inline">\(NP\)</span> so <span
class="math inline">\(P = NP\)</span>, or (2) these problems might be
good candidates for showing that there are problems in <span
class="math inline">\(NP\)</span> for which there are no efficient
algorithms.</p>
<h1 class="unnumbered" id="week10-wednesday">Week10 wednesday</h1>
<p>Definition (Sipser 7.29) Language <span
class="math inline">\(A\)</span> is <span><strong>polynomial-time
mapping reducible</strong></span> to language <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_P B\)</span>, means there is a polynomial-time computable function
<span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> such that
for every <span class="math inline">\(x \in \Sigma^*\)</span> <span
class="math display">\[x \in A \qquad \text{iff} \qquad f(x) \in
B.\]</span> The function <span class="math inline">\(f\)</span> is
called the polynomial time reduction of <span
class="math inline">\(A\)</span> to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.31): If <span
class="math inline">\(A \leq_P B\)</span> and <span
class="math inline">\(B  \in P\)</span> then <span
class="math inline">\(A \in P\)</span>.</p>
<p>Proof:</p>
<p>Definition (Sipser 7.34; based in Stephen Cook and Leonid Levin’s
work in the 1970s): A language <span class="math inline">\(B\)</span> is
<span><strong>NP-complete</strong></span> means (1) <span
class="math inline">\(B\)</span> is in NP
<span><strong>and</strong></span> (2) every language <span
class="math inline">\(A\)</span> in <span
class="math inline">\(NP\)</span> is polynomial time reducible to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.35): If <span
class="math inline">\(B\)</span> is NP-complete and <span
class="math inline">\(B \in P\)</span> then <span
class="math inline">\(P = NP\)</span>.</p>
<p>Proof:</p>
<p><span><strong>3SAT</strong></span>: A literal is a Boolean variable
(e.g. <span class="math inline">\(x\)</span>) or a negated Boolean
variable (e.g. <span class="math inline">\(\bar{x}\)</span>). A Boolean
formula is a <span><strong>3cnf-formula</strong></span> if it is a
Boolean formula in conjunctive normal form (a conjunction of disjunctive
clauses of literals) and each clause has three literals. <span
class="math display">\[3SAT  = \{  \langle  \phi \rangle \mid
\text{$\phi$ is  a  satisfiable 3cnf-formula} \}\]</span></p>
<p>Example string in <span class="math inline">\(3SAT\)</span> <span
class="math display">\[\langle (x \vee \bar{y} \vee {\bar z}) \wedge
(\bar{x}  \vee y  \vee  z) \wedge (x \vee y  \vee z)
\rangle\]</span></p>
<p>Example string not in <span class="math inline">\(3SAT\)</span> <span
class="math display">\[\langle (x \vee y \vee z) \wedge
    (x \vee y \vee{\bar z}) \wedge
    (x \vee \bar{y} \vee z) \wedge
    (x \vee \bar{y} \vee \bar{z}) \wedge
    (\bar{x} \vee y \vee z) \wedge
    (\bar{x} \vee y \vee{\bar z}) \wedge
    (\bar{x} \vee \bar{y} \vee z) \wedge
    (\bar{x} \vee \bar{y} \vee \bar{z}) \rangle\]</span></p>
<p><span><strong>Cook-Levin Theorem</strong></span>: <span
class="math inline">\(3SAT\)</span> is <span
class="math inline">\(NP\)</span>-complete.</p>
<p><span><em>Are there other <span
class="math inline">\(NP\)</span>-complete problems?</em></span> To
prove that <span class="math inline">\(X\)</span> is <span
class="math inline">\(NP\)</span>-complete</p>
<ul>
<li><p><span><em>From scratch</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that all <span
class="math inline">\(NP\)</span> problems are polynomial-time reducible
to <span class="math inline">\(X\)</span>.</p></li>
<li><p><span><em>Using reduction</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that a known-to-be <span
class="math inline">\(NP\)</span>-complete problem is polynomial-time
reducible to <span class="math inline">\(X\)</span>.</p></li>
</ul>
<p><span><strong>CLIQUE</strong></span>: A <span><strong><span
class="math inline">\(k\)</span>-clique</strong></span> in an undirected
graph is a maximally connected subgraph with <span
class="math inline">\(k\)</span> nodes. <span
class="math display">\[CLIQUE  = \{  \langle G, k \rangle \mid \text{$G$
is an  undirected graph with  a $k$-clique} \}\]</span></p>
<p>Example string in <span class="math inline">\(CLIQUE\)</span></p>
<p>Example string not in <span class="math inline">\(CLIQUE\)</span></p>
<p>Theorem (Sipser 7.32): <span class="math display">\[3SAT  \leq_P
CLIQUE\]</span></p>
<p>Given a Boolean formula in conjunctive normal form with <span
class="math inline">\(k\)</span> clauses and three literals per clause,
we will map it to a graph so that the graph has a clique if the original
formula is satisfiable and the graph does not have a clique if the
original formula is not satisfiable.</p>
<p>The graph has <span class="math inline">\(3k\)</span> vertices (one
for each literal in each clause) and an edge between all vertices
except</p>
<ul>
<li><p>vertices for two literals in the same clause</p></li>
<li><p>vertices for literals that are negations of one another</p></li>
</ul>
<p>Example: <span class="math inline">\((x \vee \bar{y} \vee {\bar z})
\wedge (\bar{x}  \vee y  \vee  z) \wedge (x \vee y  \vee z)\)</span></p>
<h1 class="unnumbered" id="week10-friday">Week10 friday</h1>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span><strong>Model of
Computation</strong></span></td>
<td style="text-align: left;"><span><strong>Class of
Languages</strong></span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span><strong>Deterministic finite
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Nondeterministic finite automata</strong></span>: formal
definition, how to design for a given language, how to describe language
of a machine? <span><strong>Regular expressions</strong></span>: formal
definition, how to design for a given language, how to describe language
of expression? <span><em>Also</em></span>: converting between different
models.</td>
<td style="text-align: left;"><span><strong>Class of regular
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using <span><strong>pumping
lemma</strong></span> to prove nonregularity.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span><strong>Push-down
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Context-free grammars</strong></span>: formal definition,
how to design for a given language, how to describe language of a
grammar?</td>
<td style="text-align: left;"><span><strong>Class of context-free
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class?</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Turing machines that always halt in
polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(P\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Nondeterministic Turing machines that
always halt in polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(NP\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span><strong>Deciders</strong></span>
(Turing machines that always halt): formal definition, how to design for
a given language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of decidable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using diagonalization and
mapping reduction to show undecidability</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span><strong>Turing
machines</strong></span> formal definition, how to design for a given
language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of recognizable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using closure and mapping
reduction to show unrecognizability</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Given a language, prove it is
regular</strong></span></p>
<p><span><em>Strategy 1</em></span>: construct DFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 2</em></span>: construct NFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 3</em></span>: construct regular expression
recognizing the language and prove it works.</p>
<p><span><em>“Prove it works” means …</em></span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(L  = \{ w \in \{0,1\}^* \mid \textrm{$w$ has odd
number of $1$s or starts with $0$}\}\)</span></p>
<p>Using NFA</p>
<p>Using regular expressions</p>
<p><span><strong>Example</strong></span>: Select all and only the
options that result in a true statement: “To show a language <span
class="math inline">\(A\)</span> is not regular, we can…”</p>
<ol>
<li><p>Show <span class="math inline">\(A\)</span> is finite</p></li>
<li><p>Show there is a CFG generating <span
class="math inline">\(A\)</span></p></li>
<li><p>Show <span class="math inline">\(A\)</span> has no pumping
length</p></li>
<li><p>Show <span class="math inline">\(A\)</span> is
undecidable</p></li>
</ol>
<p><span><strong>Example</strong></span>: What is the language generated
by the CFG with rules <span class="math display">\[\begin{aligned}
    S &amp;\to aSb \mid bY \mid Ya \\
    Y &amp;\to bY \mid Ya \mid \varepsilon
\end{aligned}\]</span></p>
<p><span><strong>Example</strong></span>: Prove that the language <span
class="math inline">\(T = \{ \langle M \rangle \mid \textrm{$M$ is a
Turing machine and $L(M)$ is infinite}\}\)</span> is undecidable.</p>
<p><span><strong>Example</strong></span>: Prove that the class of
decidable languages is closed under concatenation.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>An introduction to ASCII is available on the w3 tutorial
<a
href="https://www.w3schools.com/charsets/ref_html_ascii.asp">here</a>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
