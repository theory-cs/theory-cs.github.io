<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week10</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="monday-may-30">Monday May 30</h1>
<p>No class in observance of Memorial Day holiday.</p>
<h2 class="unnumbered" id="wednesday-june-1">Wednesday June 1</h2>
<p>Recall: For <span class="math inline">\(M\)</span> a deterministic
decider, its <span><strong>running time</strong></span> is the function
<span class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given
by <span class="math display">\[f(n) =  \text{max number of  steps $M$
takes before halting, over all inputs  of length $n$}\]</span> For each
function <span class="math inline">\(t(n)\)</span>, the
<span><strong>time complexity class</strong></span> <span
class="math inline">\(TIME(t(n))\)</span>, is defined by <span
class="math display">\[TIME( t(n)) = \{ L \mid \text{$L$ is decidable
by  a Turing machine with running time in  $O(t(n))$} \}\]</span> <span
class="math inline">\(P\)</span> is the class of languages that are
decidable in polynomial time on a deterministic 1-tape Turing machine
<span class="math display">\[P  =  \bigcup_k TIME(n^k)\]</span></p>
<p>Definition (Sipser 7.9): For <span class="math inline">\(N\)</span> a
nodeterministic decider. The <span><strong>running time</strong></span>
of <span class="math inline">\(N\)</span> is the function <span
class="math inline">\(f: \mathbb{N} \to \mathbb{N}\)</span> given by
<span class="math display">\[f(n) =  \text{max number of  steps $N$
takes on  any branch before halting, over all inputs  of length
$n$}\]</span></p>
<p>Definition (Sipser 7.21): For each function <span
class="math inline">\(t(n)\)</span>, the <span><strong>nondeterministic
time complexity class</strong></span> <span
class="math inline">\(NTIME(t(n))\)</span>, is defined by <span
class="math display">\[NTIME( t(n)) = \{ L \mid \text{$L$ is decidable
by a nondeterministic Turing machine with running time in $O(t(n))$}
\}\]</span> <span class="math display">\[NP = \bigcup_k
NTIME(n^k)\]</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(TIME(n^2) \subseteq NTIME(n^2)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(NTIME(n^2) \subseteq DTIME(n^2)\)</span></p>
<p><span><strong>Every problem in NP is decidable with an
exponential-time algorithm</strong></span></p>
<p>Nondeterministic approach: guess a possible solution, verify that it
works.</p>
<p>Brute-force (worst-case exponential time) approach: iterate over all
possible solutions, for each one, check if it works.</p>
<p><span><strong>Examples in <span
class="math inline">\(P\)</span></strong> </span></p>
<p><span><em>Can’t use nondeterminism; Can use multiple tapes; Often
need to be “more clever” than naïve / brute force approach</em></span>
<span class="math display">\[PATH = \{\langle G,s,t\rangle \mid
\textrm{$G$ is digraph with $n$ nodes there is path from s to
t}\}\]</span> Use breadth first search to show in <span
class="math inline">\(P\)</span> <span class="math display">\[RELPRIME =
\{ \langle x,y\rangle \mid \textrm{$x$ and $y$ are relatively prime
integers}\}\]</span> Use Euclidean Algorithm to show in <span
class="math inline">\(P\)</span> <span class="math display">\[L(G) = \{w
\mid \textrm{$w$ is generated by $G$}\}\]</span> (where <span
class="math inline">\(G\)</span> is a context-free grammar). Use dynamic
programming to show in <span class="math inline">\(P\)</span>.</p>
<p><span><strong>Examples in <span
class="math inline">\(NP\)</span></strong></span></p>
<p><span><em>“Verifiable" i.e. NP, Can be decided by a nondeterministic
TM in polynomial time, best known deterministic solution may be
brute-force, solution can be verified by a deterministic TM in
polynomial time.</em></span></p>
<p><span class="math display">\[\begin{aligned}
    HAMPATH &amp;= \{\langle G,s,t \rangle \mid \textrm{$G$ is digraph
with $n$ nodes, }\\
    &amp; \qquad \textrm{there is path
from $s$ to $t$ that goes through every node exactly once}\}
\end{aligned}\]</span> <span class="math display">\[VERTEX-COVER = \{
\langle G,k\rangle \mid \textrm{$G$ is an undirected graph with $n$
nodes that has a $k$-node vertex cover}\}\]</span> <span
class="math display">\[CLIQUE = \{ \langle G,k\rangle \mid \textrm{$G$
is an undirected graph with $n$ nodes that has a $k$-clique}\}\]</span>
<span class="math display">\[SAT =\{ \langle X \rangle \mid \textrm{$X$
is a satisfiable Boolean formula with $n$ variables}\}\]</span></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(P\)</span></strong></span></th>
<th style="text-align: center;"><span><strong>Problems in <span
class="math inline">\(NP\)</span></strong></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(Membership in any) regular
language</td>
<td style="text-align: center;">Any problem in <span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">(Membership in any) context-free
language</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(A_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(SAT\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(E_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(CLIQUE\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(EQ_{DFA}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(VERTEX-COVER\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(PATH\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(HAMPATH\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(RELPRIME\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Million-dollar question: Is <span class="math inline">\(P =
NP\)</span>?</p>
<p>One approach to trying to answer it is to look for
<span><em>hardest</em></span> problems in <span
class="math inline">\(NP\)</span> and then (1) if we can show that there
are efficient algorithms for them, then we can get efficient algorithms
for all problems in <span class="math inline">\(NP\)</span> so <span
class="math inline">\(P = NP\)</span>, or (2) these problems might be
good candidates for showing that there are problems in <span
class="math inline">\(NP\)</span> for which there are no efficient
algorithms.</p>
<p>Definition (Sipser 7.29) Language <span
class="math inline">\(A\)</span> is <span><strong>polynomial-time
mapping reducible</strong></span> to language <span
class="math inline">\(B\)</span>, written <span class="math inline">\(A
\leq_P B\)</span>, means there is a polynomial-time computable function
<span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span> such that
for every <span class="math inline">\(x \in \Sigma^*\)</span> <span
class="math display">\[x \in A \qquad \text{iff} \qquad f(x) \in
B.\]</span> The function <span class="math inline">\(f\)</span> is
called the polynomial time reduction of <span
class="math inline">\(A\)</span> to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.31): If <span
class="math inline">\(A \leq_P B\)</span> and <span
class="math inline">\(B  \in P\)</span> then <span
class="math inline">\(A \in P\)</span>.</p>
<p>Proof:</p>
<p>Definition (Sipser 7.34; based in Stephen Cook and Leonid Levin’s
work in the 1970s): A language <span class="math inline">\(B\)</span> is
<span><strong>NP-complete</strong></span> means (1) <span
class="math inline">\(B\)</span> is in NP
<span><strong>and</strong></span> (2) every language <span
class="math inline">\(A\)</span> in <span
class="math inline">\(NP\)</span> is polynomial time reducible to <span
class="math inline">\(B\)</span>.</p>
<p><span><strong>Theorem</strong></span> (Sipser 7.35): If <span
class="math inline">\(B\)</span> is NP-complete and <span
class="math inline">\(B \in P\)</span> then <span
class="math inline">\(P = NP\)</span>.</p>
<p>Proof:</p>
<p><span><strong>3SAT</strong></span>: A literal is a Boolean variable
(e.g. <span class="math inline">\(x\)</span>) or a negated Boolean
variable (e.g. <span class="math inline">\(\bar{x}\)</span>). A Boolean
formula is a <span><strong>3cnf-formula</strong></span> if it is a
Boolean formula in conjunctive normal form (a conjunction of disjunctive
clauses of literals) and each clause has three literals. <span
class="math display">\[3SAT  = \{  \langle  \phi \rangle \mid
\text{$\phi$ is  a  satisfiable 3cnf-formula} \}\]</span></p>
<p>Example strings in <span class="math inline">\(3SAT\)</span></p>
<p>Example strings not in <span class="math inline">\(3SAT\)</span></p>
<p><span><strong>Cook-Levin Theorem</strong></span>: <span
class="math inline">\(3SAT\)</span> is <span
class="math inline">\(NP\)</span>-complete.</p>
<p><span><em>Are there other <span
class="math inline">\(NP\)</span>-complete problems?</em></span> To
prove that <span class="math inline">\(X\)</span> is <span
class="math inline">\(NP\)</span>-complete</p>
<ul>
<li><p><span><em>From scratch</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that all <span
class="math inline">\(NP\)</span> problems are polynomial-time reducible
to <span class="math inline">\(X\)</span>.</p></li>
<li><p><span><em>Using reduction</em></span>: prove <span
class="math inline">\(X\)</span> is in <span
class="math inline">\(NP\)</span> and that a known-to-be <span
class="math inline">\(NP\)</span>-complete problem is polynomial-time
reducible to <span class="math inline">\(X\)</span>.</p></li>
</ul>
<p><span><strong>CLIQUE</strong></span>: A <span><strong><span
class="math inline">\(k\)</span>-clique</strong></span> in an undirected
graph is a maximally connected subgraph with <span
class="math inline">\(k\)</span> nodes. <span
class="math display">\[CLIQUE  = \{  \langle G, k \rangle \mid \text{$G$
is an  undirected graph with  a $k$-clique} \}\]</span></p>
<p>Example strings in <span class="math inline">\(CLIQUE\)</span></p>
<p>Example strings not in <span
class="math inline">\(CLIQUE\)</span></p>
<p>Theorem (Sipser 7.32): <span class="math display">\[3SAT  \leq_P
CLIQUE\]</span></p>
<p>Given a Boolean formula in conjunctive normal form with <span
class="math inline">\(k\)</span> clauses and three literals per clause,
we will map it to a graph so that the graph has a clique if the original
formula is satisfiable and the graph does not have a clique if the
original formula is not satisfiable.</p>
<p>The graph has <span class="math inline">\(3k\)</span> vertices (one
for each literal in each clause) and an edge between all vertices
except</p>
<ul>
<li><p>vertices for two literals in the same clause</p></li>
<li><p>vertices for literals that are negations of one another</p></li>
</ul>
<p>Example: <span class="math inline">\((x \vee \bar{y} \vee {\bar z})
\wedge (\bar{x}  \vee y  \vee  z) \wedge (x \vee y  \vee z)\)</span></p>
<h2 class="unnumbered" id="review-week-10-wednesday">Review: Week 10
Wednesday</h2>
<p>Please complete the review quiz questions on <a
href="http://gradescope.com">Gradescope</a> about complexity (<span
class="math inline">\(P\)</span>, <span
class="math inline">\(NP\)</span>, and <span
class="math inline">\(NP\)</span>-completeness.)</p>
<h2 class="unnumbered" id="friday-june-3">Friday June 3</h2>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Model of
Computation</strong></span></td>
<td style="text-align: left;"><span><strong>Class of
Languages</strong></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Deterministic finite
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Nondeterministic finite automata</strong></span>: formal
definition, how to design for a given language, how to describe language
of a machine? <span><strong>Regular expressions</strong></span>: formal
definition, how to design for a given language, how to describe language
of expression? <span><em>Also</em></span>: converting between different
models.</td>
<td style="text-align: left;"><span><strong>Class of regular
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using <span><strong>pumping
lemma</strong></span> to prove nonregularity.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Push-down
automata</strong></span>: formal definition, how to design for a given
language, how to describe language of a machine?
<span><strong>Context-free grammars</strong></span>: formal definition,
how to design for a given language, how to describe language of a
grammar?</td>
<td style="text-align: left;"><span><strong>Class of context-free
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Turing machines that always halt in
polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(P\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Nondeterministic Turing machines that
always halt in polynomial time</td>
<td style="text-align: left;"><span
class="math inline">\(NP\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><strong>Deciders</strong></span>
(Turing machines that always halt): formal definition, how to design for
a given language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of decidable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using diagonalization and
mapping reduction to show undecidability</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><strong>Turing
machines</strong></span> formal definition, how to design for a given
language, how to describe language of a machine?</td>
<td style="text-align: left;"><span><strong>Class of recognizable
languages</strong></span>: what are the closure properties of this
class? which languages are not in the class? using closure and mapping
reduction to show unrecognizability</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Given a language, prove it is
regular</strong></span></p>
<p><span><em>Strategy 1</em></span>: construct DFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 2</em></span>: construct NFA recognizing the
language and prove it works.</p>
<p><span><em>Strategy 3</em></span>: construct regular expression
recognizing the language and prove it works.</p>
<p><span><em>“Prove it works” means …</em></span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(L  = \{ w \in \{0,1\}^* \mid \textrm{$w$ has odd
number of $1$s or starts with $0$}\}\)</span></p>
<p>Using NFA</p>
<p>Using regular expressions</p>
<p><span><strong>Example</strong></span>: Select all and only the
options that result in a true statement: “To show a language <span
class="math inline">\(A\)</span> is not regular, we can…”</p>
<ol>
<li><p>Show <span class="math inline">\(A\)</span> is finite</p></li>
<li><p>Show there is a CFG generating <span
class="math inline">\(A\)</span></p></li>
<li><p>Show <span class="math inline">\(A\)</span> has no pumping
length</p></li>
<li><p>Show <span class="math inline">\(A\)</span> is
undecidable</p></li>
</ol>
<p><span><strong>Example</strong></span>: What is the language generated
by the CFG with rules <span class="math display">\[\begin{aligned}
    S &amp;\to aSb \mid bY \mid Ya \\
    Y &amp;\to bY \mid Ya \mid \varepsilon
\end{aligned}\]</span></p>
<p><span><strong>Example</strong></span>: Prove that the language <span
class="math inline">\(T = \{ \langle M \rangle \mid \textrm{$M$ is a
Turing machine and $L(M)$ is infinite}\}\)</span> is undecidable.</p>
<p><span><strong>Example</strong></span>: Prove that the class of
decidable languages is closed under concatenation.</p>
<div class="center">
<p><img src="../../resources/images/wood-951875_960_720.jpeg"
style="width:5in" alt="image" /></p>
</div>
<h2 class="unnumbered" id="review-week-10-friday">Review: Week 10
Friday</h2>
<p>Please complete the review quiz questions on <a
href="http://gradescope.com">Gradescope</a> giving feedback on the
quarter. Have a great summer!</p>
</body>
</html>
