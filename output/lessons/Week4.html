<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week4</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h2 class="unnumbered" id="week-4-at-a-glance">Week 4 at a glance</h2>
<h3 class="unnumbered"
id="textbook-reading-section-1.4-2.2-2.1.">Textbook reading: Section
1.4, 2.2, 2.1.</h3>
<p>Before Monday, read Introduction to Section 1.4 (page 77) which
introduces nonregularity.</p>
<p>Before Wednesday, read Definition 2.13 (page 111-112) introducing
Pushdown Automata.</p>
<p>Before Friday, read Example 2.18 (page 114).</p>
<p>For Week 5 Monday: read Introduction to Section 2.1 (pages
101-102).</p>
<h3 class="unnumbered" id="we-will-be-learning-and-practicing-to">We
will be learning and practicing to:</h3>
<ul>
<li><p>Clearly and unambiguously communicate computational ideas using
appropriate formalism. Translate across levels of abstraction.</p>
<ul>
<li><p>Give examples of sets that are regular (and prove that they
are).</p>
<ul>
<li><p><span><strong>State the definition of the class of regular
languages</strong></span></p></li>
<li><p><span><strong>Explain the limits of the class of regular
languages</strong></span></p></li>
<li><p><span><strong>Identify some regular sets and some nonregular
sets</strong></span></p></li>
</ul></li>
<li><p>Use precise notation to formally define the state diagram of a
PDA</p></li>
<li><p>Use clear English to describe computations of PDA informally.</p>
<ul>
<li><p><span><strong>Define push-down automata informally and
formally</strong></span></p></li>
<li><p><span><strong>State the formal definition of a
PDA</strong></span></p></li>
<li><p><span><strong>Trace the computation(s) of a PDA on a given string
using its state diagram</strong></span></p></li>
<li><p><span><strong>Determine if a given string is in the language
recognized by a PDA</strong></span></p></li>
<li><p><span><strong>Translate between a state diagram and a formal
deﬁnition of a PDA</strong></span></p></li>
<li><p><span><strong>Determine the language recognized by a given
PDA</strong></span></p></li>
</ul></li>
</ul></li>
<li><p>Know, select and apply appropriate computing knowledge and
problem-solving techniques.</p>
<ul>
<li><p>Apply classical techniques including pumping lemma,
determinization, diagonalization, and reduction to analyze the
complexity of languages and problems.</p>
<ul>
<li><p><span><strong>Justify why the Pumping Lemma is
true.</strong></span></p></li>
<li><p><span><strong>Use the pumping lemma to prove that a given
language is not regular.</strong></span></p></li>
</ul></li>
</ul></li>
</ul>
<h3 class="unnumbered" id="todo">TODO:</h3>
<div class="list">
<p>Schedule your Test 1 Attempt 1, Test 2 Attempt 1, Test 1 Attempt 2,
and Test 2 Attempt 2 times at PrairieTest
(http://us.prairietest.com)</p>
<p>Review Quiz 3 on PrairieLearn (http://us.prairielearn.com), due
1/29/2025</p>
<p>Homework 2 submitted via Gradescope (https://www.gradescope.com/),
due 1/30/2025</p>
<p>Review Quiz 4 on PrairieLearn (http://us.prairielearn.com), due
2/5/2025</p>
</div>
<h2 class="unnumbered" id="monday-pumping-lemma">Monday: Pumping
Lemma</h2>
<p><span><strong>Definition and Theorem</strong></span>: For an alphabet
<span class="math inline">\(\Sigma\)</span>, a language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> is called
<span><strong>regular</strong></span> exactly when <span
class="math inline">\(L\)</span> is recognized by some DFA, which
happens exactly when <span class="math inline">\(L\)</span> is
recognized by some NFA, and happens exactly when <span
class="math inline">\(L\)</span> is described by some regular
expression</p>
<p><span><strong>We saw that</strong></span>: The class of regular
languages is closed under complementation, union, intersection, set-wise
concatenation, and Kleene star.</p>
<p><span><em>Extra practice</em></span>:</p>
<p><span><strong>Disprove</strong></span>: There is some alphabet <span
class="math inline">\(\Sigma\)</span> for which there is some language
recognized by an NFA but not by any DFA.</p>
<p><span><strong>Disprove</strong></span>: There is some alphabet <span
class="math inline">\(\Sigma\)</span> for which there is some finite
language not described by any regular expression over <span
class="math inline">\(\Sigma\)</span>.</p>
<p><span><strong>Disprove</strong></span>: If a language is recognized
by an NFA then the complement of this language is not recognized by any
DFA.</p>
<p><span><strong>Fix alphabet <span
class="math inline">\(\Sigma\)</span>. Is every language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> regular?</strong></span></p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Set</th>
<th style="text-align: center;">Cardinality</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(\{0,1\}^*\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\mathcal{P}(
\{0,1\})\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">The set of all languages over <span
class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">The set of all regular expressions over
<span class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">The set of all regular languages over
<span class="math inline">\(\{0,1\}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Strategy: Find an <span><strong>invariant</strong></span> property
that is true of all regular languages. When analyzing a given language,
if the invariant is not true about it, then the language is not
regular.</p>
<p><span><strong>Pumping Lemma</strong></span> (Sipser Theorem 1.70): If
<span class="math inline">\(A\)</span> is a regular language, then there
is a number <span class="math inline">\(p\)</span> (a <span><em>pumping
length</em></span>) where, if <span class="math inline">\(s\)</span> is
any string in <span class="math inline">\(A\)</span> of length at least
<span class="math inline">\(p\)</span>, then <span
class="math inline">\(s\)</span> may be divided into three pieces, <span
class="math inline">\(s = xyz\)</span> such that</p>
<ul>
<li><p><span class="math inline">\(|y| &gt; 0\)</span></p></li>
<li><p>for each <span class="math inline">\(i \geq 0\)</span>, <span
class="math inline">\(xy^i z \in A\)</span></p></li>
<li><p><span class="math inline">\(|xy| \leq p\)</span>.</p></li>
</ul>
<p><span><strong>Proof idea</strong></span>: In DFA, the only memory
available is in the states. Automata can only “remember” finitely far in
the past and finitely much information, because they can have only
finitely many states. If a computation path of a DFA visits the same
state more than once, the machine can’t tell the difference between the
first time and future times it visits this state. Thus, if a DFA accepts
one long string, then it must accept (infinitely) many similar
strings.</p>
<p><span><strong>Proof illustration</strong></span></p>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{ 0,1 \}^*\)</span> is <span
class="math inline">\(p = 5\)</span>.</p>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{ 0,1 \}^*\)</span> is <span
class="math inline">\(p = 2\)</span>.</p>
<p><span><strong>True or False</strong></span>: A pumping length for
<span class="math inline">\(A = \{ 0,1 \}^*\)</span> is <span
class="math inline">\(p = 105\)</span>.</p>
<p>Restating <span><strong>Pumping Lemma</strong></span>: If <span
class="math inline">\(L\)</span> is a regular language, then it has a
pumping length.</p>
<p><span><strong>Contrapositive</strong></span>: If <span
class="math inline">\(L\)</span> has no pumping length, then it is
nonregular.</p>
<p><span>The Pumping Lemma <span><em>cannot</em></span> be used to prove
that a language <span><em>is</em></span> regular.</span></p>
<p><span>The Pumping Lemma <span><strong>can</strong></span> be used to
prove that a language <span><em>is not</em></span> regular.</span></p>
<p><span><em>Extra practice</em></span>: Exercise 1.49 in the book.</p>
<p><span><strong>Proof strategy</strong></span>: To prove that a
language <span class="math inline">\(L\)</span> is
<span><strong>not</strong></span> regular,</p>
<ul>
<li><p>Consider an arbitrary positive integer <span
class="math inline">\(p\)</span></p></li>
<li><p>Prove that <span class="math inline">\(p\)</span> is not a
pumping length for <span class="math inline">\(L\)</span></p></li>
<li><p>Conclude that <span class="math inline">\(L\)</span> does not
have <span><em>any</em></span> pumping length, and therefore it is not
regular.</p></li>
</ul>
<p><span><strong>Negation</strong></span>: A positive integer <span
class="math inline">\(p\)</span> is <span><strong>not a pumping
length</strong></span> of a language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> iff <span
class="math display">\[\exists s \left(~  |s| \geq  p \wedge s \in L
\wedge \forall x \forall y \forall z  \left( ~\left( s = xyz \wedge
|y| &gt; 0 \wedge |xy| \leq p~ \right) \to \exists i  (  i \geq
0  \wedge xy^iz  \notin L ) \right) ~\right)\]</span></p>
<h2 class="unnumbered"
id="wednesday-proving-nonregularity-and-beyond">Wednesday: Proving
nonregularity, and beyond</h2>
<p><span><strong>Proof strategy</strong></span>: To prove that a
language <span class="math inline">\(L\)</span> is
<span><strong>not</strong></span> regular,</p>
<ul>
<li><p>Consider an arbitrary positive integer <span
class="math inline">\(p\)</span></p></li>
<li><p>Prove that <span class="math inline">\(p\)</span> is not a
pumping length for <span class="math inline">\(L\)</span>. A positive
integer <span class="math inline">\(p\)</span> is <span><strong>not a
pumping length</strong></span> of a language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> iff <span
class="math display">\[\exists s \left(~  |s| \geq  p \wedge s \in L
\wedge \forall x \forall y \forall z  \left( ~\left( s = xyz \wedge
    |y| &gt; 0 \wedge |xy| \leq p~ \right) \to \exists i  (  i \geq
0  \wedge xy^iz  \notin L ) \right) ~\right)\]</span>
<span><em>Informally:</em> </span></p></li>
<li><p>Conclude that <span class="math inline">\(L\)</span> does not
have <span><em>any</em></span> pumping length, and therefore it is not
regular.</p></li>
</ul>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{ 0^n 1^n \mid n  \geq 0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{w w^{\mathcal{R}} \mid w \in
\{0,1\}^*\}\)</span>. Remember that the reverse of a string <span
class="math inline">\(w\)</span> is denoted <span
class="math inline">\(w^\mathcal{R}\)</span> and means to write <span
class="math inline">\(w\)</span> in the opposite order, if <span
class="math inline">\(w = w_1 \cdots  w_n\)</span> then <span
class="math inline">\(w^\mathcal{R} = w_n \cdots  w_1\)</span>. Note:
<span class="math inline">\(\varepsilon^\mathcal{R} =
\varepsilon\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{0^j1^k  \mid j \geq k  \geq
0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><strong>Example</strong></span>: <span
class="math inline">\(\Sigma  =  \{0,1\}\)</span>, <span
class="math inline">\(L = \{0^n1^m0^n  \mid m,n  \geq 0\}\)</span>.</p>
<p>Fix <span class="math inline">\(p\)</span> an arbitrary positive
integer. List strings that are in <span class="math inline">\(L\)</span>
and have length greater than or equal to <span
class="math inline">\(p\)</span>:</p>
<p>Pick <span class="math inline">\(s =\)</span></p>
<p>Suppose <span class="math inline">\(s = xyz\)</span> with <span
class="math inline">\(|xy|  \leq  p\)</span> and <span
class="math inline">\(|y| &gt; 0\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>Then when <span class="math inline">\(i = \hspace{1in}\)</span>,
<span class="math inline">\(xy^i z  = \hspace{1in}\)</span></p>
<p><span><em>Extra practice</em></span>:</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;">Language</th>
<th style="text-align: center;"><span class="math inline">\(s \in
L\)</span></th>
<th style="text-align: center;"><span class="math inline">\(s \notin
L\)</span></th>
<th style="text-align: center;">Is the language regular or
nonregular?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{a^nb^n
\mid 0  \leq n  \leq 5 \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{b^n a^n
\mid  n  \geq 2\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  0 \leq m\leq n\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{a^m b^n
\mid  m \geq n+3,  n \geq 0\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{b^m a^n
\mid  m \geq 1, n \geq  3\}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{ w  \in
\{a,b\}^* \mid w = w^\mathcal{R} \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\{
ww^\mathcal{R} \mid w\in \{a,b\}^* \}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h2 class="unnumbered" id="friday-pushdown-automata">Friday: Pushdown
Automata</h2>
<p>Regular sets are not the end of the story</p>
<ul>
<li><p>Many nice / simple / important sets are not regular</p></li>
<li><p>Limitation of the finite-state automaton model: Can’t “count",
Can only remember finitely far into the past, Can’t backtrack, Must make
decisions in “real-time"</p></li>
<li><p>We know actual computers are more powerful than this
model...</p></li>
</ul>
<p>The <span><strong>next</strong></span> model of computation. Idea:
allow some memory of unbounded size. How?</p>
<ul>
<li><p>To generalize regular expressions: <span><strong>context-free
grammars</strong></span><br />
</p></li>
<li><p>To generalize NFA: <span><strong>Pushdown
automata</strong></span>, which is like an NFA with access to a stack:
Number of states is fixed, number of entries in stack is unbounded. At
each step (1) Transition to new state based on current state, letter
read, and top letter of stack, then (2) (Possibly) push or pop a letter
to (or from) top of stack. Accept a string iff there is some sequence of
states and some sequence of stack contents which helps the PDA processes
the entire input string and ends in an accepting state.</p></li>
</ul>
<p>Is there a PDA that recognizes the nonregular language <span
class="math inline">\(\{0^n1^n \mid n \geq 0 \}\)</span>?</p>
<p>The PDA with state diagram above can be informally described as:</p>
<blockquote>
<p>Read symbols from the input. As each 0 is read, push it onto the
stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If
the stack becomes empty and we are at the end of the input string,
accept the input. If the stack becomes empty and there are 1s left to
read, or if 1s are finished while the stack still contains 0s, or if any
0s appear in the string following 1s, reject the input.</p>
</blockquote>
<p>Trace a computation of this PDA on the input string <span
class="math inline">\(01\)</span>.</p>
<p><span><em>Extra practice</em></span>: Trace the computations of this
PDA on the input string <span class="math inline">\(011\)</span>.</p>
<p>A PDA recognizing the set <span class="math inline">\(\{ \hspace{1.5
in} \}\)</span> can be informally described as:</p>
<blockquote>
<p>Read symbols from the input. As each 0 is read, push it onto the
stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If
the stack becomes empty and there is exactly one 1 left to read, read
that 1 and accept the input. If the stack becomes empty and there are
either zero or more than one 1s left to read, or if the 1s are finished
while the stack still contains 0s, or if any 0s appear in the input
following 1s, reject the input.</p>
</blockquote>
<p>Modify the state diagram below to get a PDA that implements this
description:</p>
</body>
</html>
