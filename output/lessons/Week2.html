<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<p>In Computer Science, we operationalize “hardest” as “requires most
resources”, where resources might be memory, time, parallelism,
randomness, power, etc. To be able to compare “hardness” of problems, we
use a consistent description of problems</p>
<p><span><strong>Input</strong></span>: String</p>
<p><span><strong>Output</strong></span>: Yes/ No, where Yes means that
the input string matches the pattern or property described by the
problem.</p>
<p>So far: we saw that regular expressions are convenient ways of
describring patterns in strings. <span><strong>Finite
automata</strong></span> give a model of computation for processing
strings and and classifying them into Yes (accepted) or No (rejected).
We will see that each set of strings is described by a regular
expression if and only if there is a FA that recognizes it. Another way
of thinking about it: properties described by regular expressions
require exactly the computational power of these finite automata.</p>
<h2 class="unnumbered"
id="wednesday-finite-automaton-constructions">Wednesday: Finite
automaton constructions</h2>
<p><span><strong>Review</strong></span>: Formal definition of finite
automaton: <span class="math inline">\(M = (Q, \Sigma, \delta, q_0,
F)\)</span></p>
<div class="center">
<div class="multicols">
<p><span>2</span></p>
<ul>
<li><p>Finite set of states <span
class="math inline">\(Q\)</span></p></li>
<li><p>Alphabet <span class="math inline">\(\Sigma\)</span></p></li>
<li><p>Transition function <span
class="math inline">\(\delta\)</span></p></li>
<li><p>Start state <span class="math inline">\(q_0\)</span></p></li>
<li><p>Accept (final) states <span
class="math inline">\(F\)</span></p></li>
</ul>
</div>
</div>
<p>In the state diagram of <span class="math inline">\(M\)</span>, how
many outgoing arrows are there from each state?</p>
<p><span class="math inline">\(M = ( \{ q, r, s\}, \{a,b\}, \delta, q,
\{q\} )\)</span> where <span class="math inline">\(\delta\)</span> is
(rows labelled by states and columns labelled by symbols):</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(\delta\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(a\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(b\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The state diagram for <span class="math inline">\(M\)</span> is</p>
<p>Give two examples of strings that are accepted by <span
class="math inline">\(M\)</span> and two examples of strings that are
rejected by <span class="math inline">\(M\)</span>:</p>
<p><span class="math inline">\(L(M) =\)</span></p>
<p>A regular expression describing <span
class="math inline">\(L(M)\)</span> is</p>
<p>Let the alphabet be <span class="math inline">\(\Sigma_1 =
\{0,1\}\)</span>.</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \in \Sigma_1^* \mid w~\text{contains at most
two $1$&#39;s} \}\)</span> is</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \in \Sigma_1^* \mid w~\text{contains more than
two $1$&#39;s} \}\)</span> is</p>
<p><strong>Strategy</strong>: Add “labels" for states in the state
diagram, e.g. “have not seen any of desired pattern yet” or “sink
state”. Then, we can use the analysis of the roles of the states in the
state diagram to work towards a description of the language recognized
by the finite automaton.</p>
<p>A useful bit of terminology: the <span><strong>iterated transition
function</strong></span> of a finite automaton <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> is
defined recursively by <span class="math display">\[\delta^* (~(q,w)~)
=\begin{cases}
q  \qquad &amp;\text{if $q \in Q, w = \varepsilon$} \\
\delta( ~(q,a)~) \qquad &amp;\text{if $q \in Q$, $w = a \in \Sigma$ } \\
\delta(~(\delta^*(q,u), a) ~) \qquad &amp;\text{if $q \in Q$, $w = ua$
where $u \in  \Sigma^*$ and $a \in \Sigma$}
\end{cases}\]</span></p>
<p>Using this terminology, <span class="math inline">\(M\)</span>
accepts a string <span class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> if and only if <span
class="math inline">\(\delta^*( ~(q_0,w)~) \in F\)</span>.</p>
<p>Suppose <span class="math inline">\(A\)</span> is a language over an
alphabet <span class="math inline">\(\Sigma\)</span>. By definition,
this means <span class="math inline">\(A\)</span> is a subset of <span
class="math inline">\(\Sigma^*\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span> then there is another DFA, let’s
call it <span class="math inline">\(M&#39;\)</span>, such that <span
class="math inline">\(L(M&#39;) = \overline{A}\)</span>, the complement
of <span class="math inline">\(A\)</span>, defined as <span
class="math inline">\(\{ w \in \Sigma^* \mid w \notin A \}\)</span>.</p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Proof</strong></span>:</p>
<p>Application: Design a finite automaton that recognizes the language
of all strings over <span class="math inline">\(\{a,b\}\)</span> whose
length is not a multiple of <span class="math inline">\(3\)</span>.</p>
<p><span><strong>Note</strong></span>: On Friday, we’ll see a new kind
of finite automaton. It will be helpful to distinguish it from the
machines we’ve been talking about so we’ll use
<span><strong>Deterministic Finite Automaton</strong></span> (DFA) to
refer to the machines from Section 1.1.</p>
<h2 class="unnumbered" id="friday-nondeterministic-automata">Friday:
Nondeterministic automata</h2>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="2" style="text-align: left;"><span><strong>Nondeterministic
finite automaton</strong></span> (Sipser Page 53) Given as <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Finite set of states <span
class="math inline">\(Q\)</span></td>
<td style="text-align: left;">Can be labelled by any collection of
distinct names. Default: <span class="math inline">\(q0, q1,
\ldots\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Alphabet <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">Each input to the automaton is a string
over <span class="math inline">\(\Sigma\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;">Arrow labels <span
class="math inline">\(\Sigma_\varepsilon\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\Sigma_\varepsilon = \Sigma \cup \{
\varepsilon\}\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Arrows in the state diagram are labelled
either by symbols from <span class="math inline">\(\Sigma\)</span> or by
<span class="math inline">\(\varepsilon\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Transition function <span
class="math inline">\(\delta\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\delta: Q
\times \Sigma_{\varepsilon} \to \mathcal{P}(Q)\)</span> gives the
<span><strong>set of possible next states</strong></span> for a
transition</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">from the current state upon reading a
symbol or spontaneously moving.</td>
</tr>
<tr>
<td style="text-align: left;">Start state <span
class="math inline">\(q_0\)</span></td>
<td style="text-align: left;">Element of <span
class="math inline">\(Q\)</span>. Each computation of the machine starts
at the start state.</td>
</tr>
<tr>
<td style="text-align: left;">Accept (final) states <span
class="math inline">\(F\)</span></td>
<td style="text-align: left;"><span class="math inline">\(F
\subseteq  Q\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="2" style="text-align: left;"><span
class="math inline">\(M\)</span> accepts the input string <span
class="math inline">\(w \in \Sigma^*\)</span> if and only if
<span><strong>there is</strong></span> a computation of <span
class="math inline">\(M\)</span> on <span
class="math inline">\(w\)</span> that processes the whole string and
ends in an accept state.</td>
</tr>
</tbody>
</table>
</div>
<p>The formal definition of the NFA over <span
class="math inline">\(\{0,1\}\)</span> given by this state diagram
is:</p>
<p><img src="../../resources/machines/Lect4NFA1.png" style="width:2in"
alt="image" /></p>
<p>The language over <span class="math inline">\(\{0,1\}\)</span>
recognized by this NFA is:</p>
<p>Change the transition function to get a different NFA which accepts
the empty string (and potentially other strings too).</p>
<p>The state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span> is below. The formal definition
of this NFA is:</p>
<p><img src="../../resources/machines/Lect5NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>The language recognized by this NFA is:</p>
<h2 class="unnumbered" id="week-2-at-a-glance">Week 2 at a glance</h2>
<h3 class="unnumbered" id="textbook-reading-section-1.1-1.2">Textbook
reading: Section 1.1, 1.2</h3>
<p><span><em>For Wednesday</em></span>: Pages 41-43 (Figures 1.18, 1.19,
1.20) (examples of automata and languages).</p>
<p><span><em>For Friday</em></span>: Pages 48-50 (Figures 1.27, 1.29)
(introduction to nondeterminism).</p>
<p><span><em>For Week 3 Monday</em></span>: Pages 60-61 Theorem 1.47 and
Theorem 1.48 (closure proofs).</p>
<h3 class="unnumbered" id="make-sure-you-can">Make sure you can:</h3>
<ul>
<li><p>Use regular expressions and relate them to languages and
automata</p>
<ul>
<li><p>Write and debug regular expressions using correct syntax</p></li>
</ul></li>
<li><p>Use precise notation to formally define the state diagram of DFA,
NFA and use clear English to describe computations of DFA, NFA
informally.</p>
<ul>
<li><p>Design an automaton that recognizes a given language</p></li>
<li><p>Specify a general construction for DFA based on
parameters</p></li>
<li><p>Design general constructions for DFA</p></li>
<li><p>Motivate the use of nondeterminism</p></li>
<li><p>Trace the computation(s) of a nondeterministic finite
automaton</p></li>
</ul></li>
</ul>
<h3 class="unnumbered" id="todo">TODO:</h3>
<div class="list">
<p>#FinAid Assignment on Canvas
https://canvas.ucsd.edu/courses/51649/quizzes/158899</p>
<p>Review quizzes based on class material each day.</p>
<p>Homework assignment 1 due Thursday.</p>
</div>
</body>
</html>
