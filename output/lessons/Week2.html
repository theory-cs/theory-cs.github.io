<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h2 class="unnumbered" id="week-2-at-a-glance">Week 2 at a glance</h2>
<h3 class="unnumbered" id="textbook-reading-sections-1.1-1.2">Textbook
reading: Sections 1.1, 1.2</h3>
<p>Before Monday, read pages 41-43 (Figures 1.18, 1.19, 1.20) for
examples of automata and languages.</p>
<p>Before Wednesday, read pages 48-50 (Figures 1.27, 1.29) which
introduces nondeterminism.</p>
<p>Before Friday, read pages 45-46 (Theorem 1.25) that we’ll refer to as
a “closure proof".</p>
<p>For Week 3 Monday: Theorem 1.47 + 1.48, Theorem 1.39 “Proof Idea”,
Example 1.41, Example 1.56.</p>
<h3 class="unnumbered" id="we-will-be-learning-and-practicing-to">We
will be learning and practicing to:</h3>
<ul>
<li><p>Clearly and unambiguously communicate computational ideas using
appropriate formalism. Translate across levels of abstraction.</p>
<ul>
<li><p>Give examples of sets that are regular (and prove that they
are).</p>
<ul>
<li><p><span><strong>State the definition of the class of regular
languages</strong></span></p></li>
<li><p><span><strong>Give examples of regular languages, using each of
the three equivalent models of computation for proving
regularity.</strong></span></p></li>
</ul></li>
<li><p>Describe and use models of computation that don’t involve state
machines.</p>
<ul>
<li><p><span><strong>Given a DFA or NFA, find a regular expression that
describes its language.</strong></span></p></li>
<li><p><span><strong>Given a regular expression, find a DFA or NFA that
recognizes its language.</strong></span></p></li>
</ul></li>
<li><p>Use precise notation to formally define the state diagram of
finite automata.</p></li>
<li><p>Use clear English to describe computations of finite automata
informally.</p>
<ul>
<li><p><span><strong>Design an automaton that recognizes a given
language</strong></span></p></li>
<li><p><span><strong>Specify a general construction for DFA based on
parameters</strong></span></p></li>
<li><p><span><strong>Design general constructions for
DFA</strong></span></p></li>
<li><p><span><strong>Motivate the use of
nondeterminism</strong></span></p></li>
<li><p><span><strong>State the formal definition of
NFA</strong></span></p></li>
<li><p><span><strong>Trace the computation(s) of a NFA on a given string
using its state diagram</strong></span></p></li>
<li><p><span><strong>Determine if a given string is in the language
recognized by a NFA</strong></span></p></li>
<li><p><span><strong>Translate between a state diagram and a formal
definition of a NFA</strong></span></p></li>
</ul></li>
</ul></li>
</ul>
<h3 class="unnumbered" id="todo">TODO:</h3>
<div class="list">
<p>#FinAid Assignment on Canvas (complete as soon as possible) and read
syllabus on Canvas</p>
<p>Schedule your Test 1 Attempt 1, Test 2 Attempt 1, Test 1 Attempt 2,
and Test 2 Attempt 2 times at PrairieTest
(http://us.prairietest.com)</p>
<p>Homework 1 submitted via Gradescope (https://www.gradescope.com/),
due Tuesday 10/8/2024</p>
<p>Review Quiz 2 on PrairieLearn (http://us.prairielearn.com), complete
by Sunday 10/13/2024</p>
</div>
<h2 class="unnumbered"
id="monday-finite-automaton-constructions">Monday: Finite automaton
constructions</h2>
<p><span><strong>Review</strong></span>: Formal definition of DFA: <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span></p>
<div class="center">
<div class="multicols">
<p><span>2</span></p>
<ul>
<li><p>Finite set of states <span
class="math inline">\(Q\)</span></p></li>
<li><p>Alphabet <span class="math inline">\(\Sigma\)</span></p></li>
<li><p>Transition function <span
class="math inline">\(\delta\)</span></p></li>
<li><p>Start state <span class="math inline">\(q_0\)</span></p></li>
<li><p>Accept (final) states <span
class="math inline">\(F\)</span></p></li>
</ul>
</div>
</div>
<p>Quick check: In the state diagram of <span
class="math inline">\(M\)</span>, how many outgoing arrows are there
from each state?</p>
<p><span><strong>Note</strong></span>: We’ll see a new kind of finite
automaton. It will be helpful to distinguish it from the machines we’ve
been talking about so we’ll use <span><strong>Deterministic Finite
Automaton</strong></span> (DFA) to refer to the machines from Section
1.1.</p>
<p><span class="math inline">\(M = ( \{ q0, q1, q2\}, \{a,b\}, \delta,
q0, \{q0\} )\)</span> where <span class="math inline">\(\delta\)</span>
is (rows labelled by states and columns labelled by symbols):</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(\delta\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(a\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(b\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(q0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q1\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(q1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q2\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(q2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(q0\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The state diagram for <span class="math inline">\(M\)</span> is</p>
<p>Give two examples of strings that are accepted by <span
class="math inline">\(M\)</span> and two examples of strings that are
rejected by <span class="math inline">\(M\)</span>:</p>
<p>A regular expression describing <span
class="math inline">\(L(M)\)</span> is</p>
<p>A state diagram for a finite automaton recognizing <span
class="math display">\[\{w \mid w~\text{is a string over $\{a,b\}$ whose
length is not a multiple of $3$} \}\]</span></p>
<p>Extra example: Let <span class="math inline">\(n\)</span> be an
arbitrary positive integer. What is a formal definition for a finite
automaton recognizing <span class="math display">\[\{w \mid w~\text{is a
string over $\{0,1\}$ whose length is not a multiple of $n$}
\}?\]</span></p>
<p>Consider the alphabet <span class="math inline">\(\Sigma_1 =
\{0,1\}\)</span>.</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \mid w~\text{contains at most two $1$&#39;s}
\}\)</span> is</p>
<p>A state diagram for a finite automaton that recognizes <span
class="math inline">\(\{w \mid w~\text{contains more than two $1$&#39;s}
\}\)</span> is</p>
<p><strong>Strategy</strong>: Add “labels" for states in the state
diagram, e.g. “have not seen any of desired pattern yet” or “sink
state”. Then, we can use the analysis of the roles of the states in the
state diagram to work towards a description of the language recognized
by the finite automaton.</p>
<p>Or: decompose the language to a simpler one that we already know how
to recognize with a DFA or NFA.</p>
<p>Textbook Exercise 1.14: Suppose <span
class="math inline">\(A\)</span> is a language over an alphabet <span
class="math inline">\(\Sigma\)</span>. If there is a DFA <span
class="math inline">\(M\)</span> such that <span
class="math inline">\(L(M) = A\)</span> then there is another DFA, let’s
call it <span class="math inline">\(M&#39;\)</span>, such that <span
class="math inline">\(L(M&#39;) = \overline{A}\)</span>, the complement
of <span class="math inline">\(A\)</span>, defined as <span
class="math inline">\(\{ w \in \Sigma^* \mid w \notin A \}\)</span>.</p>
<p><span><strong>Proof idea</strong></span>:</p>
<p>A useful bit of terminology: the <span><strong>iterated transition
function</strong></span> of a finite automaton <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> is
defined recursively by <span class="math display">\[\delta^* (~(q,w)~)
=\begin{cases}
q  \qquad &amp;\text{if $q \in Q, w = \varepsilon$} \\
\delta( ~(q,a)~) \qquad &amp;\text{if $q \in Q$, $w = a \in \Sigma$ } \\
\delta(~(\delta^*(~(q,u)~), a) ~) \qquad &amp;\text{if $q \in Q$, $w =
ua$ where $u \in  \Sigma^*$ and $a \in \Sigma$}
\end{cases}\]</span></p>
<p>Using this terminology, <span class="math inline">\(M\)</span>
accepts a string <span class="math inline">\(w\)</span> over <span
class="math inline">\(\Sigma\)</span> if and only if <span
class="math inline">\(\delta^*( ~(q_0,w)~) \in F\)</span>.</p>
<p><span><strong>Proof</strong></span>:</p>
<h2 class="unnumbered"
id="wednesday-nondeterministic-automata">Wednesday: Nondeterministic
automata</h2>
<p>We saw that whenever a language is recognized by a DFA, its
complement is also recognized by some (other) DFA.</p>
<p>Another way to say this is that the collection of languages that are
each recognizable by a DFA is <span><strong>closed</strong></span> under
complementation.</p>
<div class="center">
<table>
<tbody>
<tr>
<td colspan="2" style="text-align: left;"><span><strong>Nondeterministic
finite automaton</strong></span> (Sipser Page 53) Given as <span
class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Finite set of states <span
class="math inline">\(Q\)</span></td>
<td style="text-align: left;">Can be labelled by any collection of
distinct names. Default: <span class="math inline">\(q0, q1,
\ldots\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Alphabet <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">Each input to the automaton is a string
over <span class="math inline">\(\Sigma\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;">Arrow labels <span
class="math inline">\(\Sigma_\varepsilon\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(\Sigma_\varepsilon = \Sigma \cup \{
\varepsilon\}\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Arrows in the state diagram are labelled
either by symbols from <span class="math inline">\(\Sigma\)</span> or by
<span class="math inline">\(\varepsilon\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Transition function <span
class="math inline">\(\delta\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\delta: Q
\times \Sigma_{\varepsilon} \to \mathcal{P}(Q)\)</span> gives the
<span><strong>set of possible next states</strong></span> for a
transition</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">from the current state upon reading a
symbol or spontaneously moving.</td>
</tr>
<tr>
<td style="text-align: left;">Start state <span
class="math inline">\(q_0\)</span></td>
<td style="text-align: left;">Element of <span
class="math inline">\(Q\)</span>. Each computation of the machine starts
at the start state.</td>
</tr>
<tr>
<td style="text-align: left;">Accept (final) states <span
class="math inline">\(F\)</span></td>
<td style="text-align: left;"><span class="math inline">\(F
\subseteq  Q\)</span>.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="2" style="text-align: left;"><span
class="math inline">\(M\)</span> accepts the input string <span
class="math inline">\(w \in \Sigma^*\)</span> if and only if
<span><strong>there is</strong></span> a computation of <span
class="math inline">\(M\)</span> on <span
class="math inline">\(w\)</span> that processes the whole string and
ends in an accept state.</td>
</tr>
</tbody>
</table>
</div>
<p>The formal definition of the NFA over <span
class="math inline">\(\{0,1\}\)</span> given by this state diagram
is:</p>
<p><img src="../../resources/machines/Lect4NFA1.png" style="width:2in"
alt="image" /></p>
<p>The language over <span class="math inline">\(\{0,1\}\)</span>
recognized by this NFA is:</p>
<p>Change the transition function to get a different NFA which accepts
the empty string (and potentially other strings too).</p>
<p>The state diagram of an NFA over <span
class="math inline">\(\{a,b\}\)</span> is below. The formal definition
of this NFA is:</p>
<p><img src="../../resources/machines/Lect5NFA1.png" style="width:2.5in"
alt="image" /></p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a NFA <span
class="math inline">\(N_1\)</span> such that <span
class="math inline">\(L(N_1) = A_1\)</span> and NFA <span
class="math inline">\(N_2\)</span> such that <span
class="math inline">\(L(N_2) = A_2\)</span>, then there is another NFA,
let’s call it <span class="math inline">\(N\)</span>, such that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span>.</p>
<p><span><strong>Proof idea</strong></span>: Use nondeterminism to
choose which of <span class="math inline">\(N_1\)</span>, <span
class="math inline">\(N_2\)</span> to run.</p>
<p><span><strong>Formal construction</strong></span>: Let <span
class="math inline">\(N_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)\)</span>
and <span class="math inline">\(N_2 = (Q_2, \Sigma, \delta_2,q_2,
F_2)\)</span> and assume <span class="math inline">\(Q_1 \cap Q_2 =
\emptyset\)</span> and that <span class="math inline">\(q_0 \notin Q_1
\cup Q_2\)</span>. Construct <span class="math inline">\(N = (Q, \Sigma,
\delta, q_0, F_1 \cup F_2)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(Q =\)</span></p></li>
<li><p><span class="math inline">\(\delta: Q \times \Sigma_\varepsilon
\to \mathcal{P}(Q)\)</span> is defined by, for <span
class="math inline">\(q \in Q\)</span> and <span class="math inline">\(x
\in \Sigma_{\varepsilon}\)</span>: <span
class="math display">\[\phantom{\delta((q,x))=\begin{cases}  \delta_1
((q,x)) &amp;\qquad\text{if } q\in Q_1 \\ \delta_2 ((q,x))
&amp;\qquad\text{if } q\in Q_2 \\ \{q1,q2\} &amp;\qquad\text{if } q =
q_0, x = \varepsilon \\ \emptyset\text{if } q= q_0, x \neq \varepsilon
\end{cases}}\]</span></p></li>
</ul>
<p><span><em>Proof of correctness would prove that <span
class="math inline">\(L(N) = A_1 \cup A_2\)</span> by considering an
arbitrary string accepted by <span class="math inline">\(N\)</span>,
tracing an accepting computation of <span
class="math inline">\(N\)</span> on it, and using that trace to prove
the string is in at least one of <span
class="math inline">\(A_1\)</span>, <span
class="math inline">\(A_2\)</span>; then, taking an arbitrary string in
<span class="math inline">\(A_1 \cup A_2\)</span> and proving that it is
accepted by <span class="math inline">\(N\)</span>. Details left for
extra practice.</em></span></p>
<h2 class="unnumbered" id="friday-automata-constructions">Friday:
Automata constructions</h2>
<p><span><strong>Review</strong></span>: The language recognized by the
NFA over <span class="math inline">\(\{a,b\}\)</span> with state
diagram</p>
<p>is:</p>
<p>So far, we know:</p>
<ul>
<li><p>The collection of languages that are each recognizable by a DFA
is <span><strong>closed</strong></span> under complementation.</p>
<p><span><em>Could we do the same construction with
NFA?</em></span></p></li>
<li><p>The collection of languages that are each recognizable by a NFA
is <span><strong>closed</strong></span> under union.</p>
<p><span><em>Could we do the same construction with
DFA?</em></span></p></li>
</ul>
<p>Happily, though, an analogous claim is true!</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cup A_2\)</span>. <span><em>Theorem
1.25 in Sipser, page 45</em></span></p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
<p><span><strong>Example</strong></span>: When <span
class="math inline">\(A_1 = \{w \mid w~\text{has an $a$ and ends in $b$}
\}\)</span> and <span class="math inline">\(A_2 = \{ w \mid w~\text{is
of even length} \}\)</span>.</p>
<p>Suppose <span class="math inline">\(A_1, A_2\)</span> are languages
over an alphabet <span class="math inline">\(\Sigma\)</span>.
<span><strong>Claim:</strong></span> if there is a DFA <span
class="math inline">\(M_1\)</span> such that <span
class="math inline">\(L(M_1) = A_1\)</span> and DFA <span
class="math inline">\(M_2\)</span> such that <span
class="math inline">\(L(M_2) = A_2\)</span>, then there is another DFA,
let’s call it <span class="math inline">\(M\)</span>, such that <span
class="math inline">\(L(M) = A_1 \cap A_2\)</span>. <span><em>Footnote
to Sipser Theorem 1.25, page 46</em></span></p>
<p><span><strong>Proof idea</strong></span>:</p>
<p><span><strong>Formal construction</strong></span>:</p>
</body>
</html>
