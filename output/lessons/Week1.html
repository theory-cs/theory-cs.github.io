<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week1</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="lets-get-started">Let’s get started</h1>
<p>We want you to be successful.</p>
<p>We will work together to build an environment in CSE 105 that
supports your learning in a way that respects your perspectives,
experiences, and identities (including race, ethnicity, heritage,
gender, sex, class, sexuality, religion, ability, age, educational
background, etc.).  Our goal is for you to engage with interesting and
challenging concepts and feel comfortable exploring, asking questions,
and thriving.</p>
<p>If you or someone you know is suffering from food and/or housing
insecurities there are UCSD resources here to help:</p>
<p>Basic Needs Office: <a
href="https://basicneeds.ucsd.edu/">https://basicneeds.ucsd.edu/</a></p>
<p>Triton Food Pantry (in the old Student Center) is free and anonymous,
and includes produce:</p>
<p><a
href="https://www.facebook.com/tritonfoodpantry/">https://www.facebook.com/tritonfoodpantry/</a></p>
<p>Mutual Aid UCSD: <a
href="https://mutualaiducsd.wordpress.com/">https://mutualaiducsd.wordpress.com/</a></p>
<p>Financial aid resources, the possibility of emergency grant funding,
and off-campus housing referral resources are available: see your
College Dean of Student Affairs.</p>
<p>If you find yourself in an uncomfortable situation, ask for help. We
are committed to upholding University policies regarding
nondiscrimination, sexual violence and sexual harassment. Here are some
campus contacts that could provide this help: Counseling and
Psychological Services (CAPS) at 858 534-3755 or <a
href="http://caps.ucsd.edu">http://caps.ucsd.edu</a>; OPHD at 858
534-8298 or ophd@ucsd.edu , <a
href="http://ophd.ucsd.edu">http://ophd.ucsd.edu</a>; CARE at Sexual
Assault Resource Center at 858 534-5793 or sarc@ucsd.edu , <a
href="http://care.ucsd.edu">http://care.ucsd.edu</a>.</p>
<p>Please reach out (minnes@ucsd.edu) if you need support with
extenuating circumstances affecting CSE 105.</p>
<h1 class="unnumbered" id="introductions">Introductions</h1>
<p>Class website: <a
href="https://canvas.ucsd.edu/courses/51649/">https://canvas.ucsd.edu/courses/51649/</a></p>
<p>Instructor: Prof. Mia Minnes <span><span>"Minnes" rhymes with
Guinness</span></span>, minnes@ucsd.edu, <a
href="http://cseweb.ucsd.edu/~minnes">http://cseweb.ucsd.edu/ minnes</a></p>
<p>Our team: One instructor + two TAs and eleven tutors + all of you</p>
<p>Fill in contact info for students around you, if you’d like:</p>
<p>Welcome to CSE 105: Introduction to Theory of Computation in Winter
2024!</p>
<h1 class="unnumbered" id="cse-105s-big-questions">CSE 105’s Big
Questions</h1>
<ul>
<li><p>What problems are computers capable of solving?</p></li>
<li><p>What resources are needed to solve a problem?</p></li>
<li><p>Are some problems harder than others?</p></li>
</ul>
<p>In this context, a <span><strong>problem</strong></span> is defined
as: “Making a decision or computing a value based on some input"</p>
<p>Consider the following problems:</p>
<ul>
<li><p>Find a file on your computer</p></li>
<li><p>Determine if your code will compile</p></li>
<li><p>Find a run-time error in your code</p></li>
<li><p>Certify that your system is un-hackable</p></li>
</ul>
<p>Which of these is hardest?</p>
<p>In Computer Science, we operationalize “hardest” as “requires most
resources”, where resources might be memory, time, parallelism,
randomness, power, etc.</p>
<p>To be able to compare “hardness” of problems, we use a consistent
description of problems</p>
<p><span><strong>Input</strong></span>: String</p>
<p><span><strong>Output</strong></span>: Yes/ No, where Yes means that
the input string matches the pattern or property described by the
problem.</p>
<h1 class="unnumbered" id="monday-terminology-and-notation">Monday:
Terminology and Notation</h1>
<p>The CSE 105 vocabulary and notation build on discrete math and
introduction to proofs classes. Some of the conventions may be a bit
different from what you saw before so we’ll draw your attention to
them.</p>
<p>For consistency, we will use the notation from this class’ textbook<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>These definitions are on pages 3, 4, 6, 13, 14, 53.</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: left;"><span><strong>Term</strong></span></td>
<td style="text-align: center;"><span><strong>Typical
symbol</strong></span></td>
<td style="text-align: left;"><span><strong>Meaning</strong></span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">or
<span><strong>Notation</strong></span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Alphabet</td>
<td style="text-align: center;"><span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\Gamma\)</span></td>
<td style="text-align: left;">A non-empty finite set</td>
</tr>
<tr>
<td style="text-align: left;">Symbol over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\sigma\)</span>, <span
class="math inline">\(b\)</span>, <span
class="math inline">\(x\)</span></td>
<td style="text-align: left;">An element of the alphabet <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr>
<td style="text-align: left;">String over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(u\)</span>,
<span class="math inline">\(v\)</span>, <span
class="math inline">\(w\)</span></td>
<td style="text-align: left;">A finite list of symbols from <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr>
<td style="text-align: left;">(The) empty string</td>
<td style="text-align: center;"><span
class="math inline">\(\varepsilon\)</span></td>
<td style="text-align: left;">The (only) string of length <span
class="math inline">\(0\)</span></td>
</tr>
<tr>
<td style="text-align: left;">The set of all strings over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\Sigma^*\)</span></td>
<td style="text-align: left;">The collection of all possible strings
formed from symbols from <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr>
<td style="text-align: left;">(Some) language over <span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(L\)</span></td>
<td style="text-align: left;">(Some) set of strings over <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr>
<td style="text-align: left;">(The) empty language</td>
<td style="text-align: center;"><span
class="math inline">\(\emptyset\)</span></td>
<td style="text-align: left;">The empty set, i.e. the set that has no
strings (and no other elements either)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">The power set of a set <span
class="math inline">\(X\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\mathcal{P}(X)\)</span></td>
<td style="text-align: left;">The set of all subsets of <span
class="math inline">\(X\)</span></td>
</tr>
<tr>
<td style="text-align: left;">(The set of) natural numbers</td>
<td style="text-align: center;"><span
class="math inline">\(\mathcal{N}\)</span></td>
<td style="text-align: left;">The set of positive integers</td>
</tr>
<tr>
<td style="text-align: left;">(Some) finite set</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">The empty set or a set whose distinct
elements can be counted by a natural number</td>
</tr>
<tr>
<td style="text-align: left;">(Some) infinite set</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">A set that is not finite.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Reverse of a string <span
class="math inline">\(w\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(w^\mathcal{R}\)</span></td>
<td style="text-align: left;">write <span
class="math inline">\(w\)</span> in the opposite order, if <span
class="math inline">\(w = w_1 \cdots  w_n\)</span> then <span
class="math inline">\(w^\mathcal{R} = w_n \cdots  w_1\)</span>. Note:
<span class="math inline">\(\varepsilon^\mathcal{R} =
\varepsilon\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Concatenating strings <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(xy\)</span></td>
<td style="text-align: left;">take <span class="math inline">\(x = x_1
\cdots x_m\)</span>, <span class="math inline">\(y=y_1 \cdots
y_n\)</span> and form <span class="math inline">\(xy = x_1 \cdots x_m
y_1 \cdots y_n\)</span></td>
</tr>
<tr>
<td style="text-align: left;">String <span
class="math inline">\(z\)</span> is a substring of string <span
class="math inline">\(w\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">there are strings <span
class="math inline">\(u,v\)</span> such that <span
class="math inline">\(w = uzv\)</span></td>
</tr>
<tr>
<td style="text-align: left;">String <span
class="math inline">\(x\)</span> is a prefix of string <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">there is a string <span
class="math inline">\(z\)</span> such that <span class="math inline">\(y
= xz\)</span></td>
</tr>
<tr>
<td style="text-align: left;">String <span
class="math inline">\(x\)</span> is a proper prefix of string <span
class="math inline">\(y\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(x\)</span> is
a prefix of <span class="math inline">\(y\)</span> and <span
class="math inline">\(x \neq y\)</span></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Shortlex order, also known as string order
over alphabet <span class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Order strings over <span
class="math inline">\(\Sigma\)</span> first by length and then according
to the dictionary order, assuming symbols in <span
class="math inline">\(\Sigma\)</span> have an ordering</td>
</tr>
</tbody>
</table>
</div>
<p>Write out in words the meaning of the symbols below:</p>
<p><span class="math display">\[\{ a, b, c\}\]</span></p>
<p><span class="math display">\[| \{a, b, a \} | = 2\]</span></p>
<p><span class="math display">\[| aba | = 3\]</span></p>
<p><span><em>Circle the correct choice</em></span>:</p>
<p>A <span><strong>string</strong></span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is <u>  an element of <span
class="math inline">\(\Sigma^*\)</span>    OR    a subset of <span
class="math inline">\(\Sigma^*\)</span></u>.</p>
<p>A <span><strong>language</strong></span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is <u>  an element of <span
class="math inline">\(\Sigma^*\)</span>    OR    a subset of <span
class="math inline">\(\Sigma^*\)</span></u>.</p>
<p>With <span class="math inline">\(\Sigma_1 = \{0,1\}\)</span> and
<span class="math inline">\(\Sigma_2 =
\{a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\}\)</span> and
<span class="math inline">\(\Gamma = \{0,1,x,y,z\}\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon \in \Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a string over <span
class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a language over <span
class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span
class="math inline">\(\varepsilon\)</span> is a prefix of some string
over <span class="math inline">\(\Sigma_1\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: There is a string over <span
class="math inline">\(\Sigma_1\)</span> that is a proper prefix of <span
class="math inline">\(\varepsilon\)</span></p>
<p>The first five strings over <span
class="math inline">\(\Sigma_1\)</span> in string order, using the
ordering <span class="math inline">\(0 &lt;  1\)</span>:</p>
<p>The first five strings over <span
class="math inline">\(\Sigma_2\)</span> in string order, using the usual
alphabetical ordering for single letters:</p>
<h2 class="unnumbered" id="week-1-wednesday">Week 1 Wednesday</h2>
<p>Our motivation in studying sets of strings is that they can be used
to encode problems. To calibrate how difficult a problem is to solve, we
describe how complicated the set of strings that encodes it is. How do
we define sets of strings?</p>
<p>How would you describe the language that has no elements at all?</p>
<p>How would you describe the language that has all strings over <span
class="math inline">\(\{0,1\}\)</span> as its elements?</p>
<p>**This definition was in the pre-class reading**
<span><strong>Definition 1.52</strong></span>: A <span><strong>regular
expression</strong></span> over alphabet <span
class="math inline">\(\Sigma\)</span> is a syntactic expression that can
describe a language over <span class="math inline">\(\Sigma\)</span>.
The collection of all regular expressions over <span
class="math inline">\(\Sigma\)</span> is defined recursively:</p>
<ul>
<li><p><span><em>Basis steps of recursive definition</em></span></p>
<blockquote>
<p><span class="math inline">\(a\)</span> is a regular expression, for
<span class="math inline">\(a \in \Sigma\)</span></p>
<p><span class="math inline">\(\varepsilon\)</span> is a regular
expression</p>
<p><span class="math inline">\(\emptyset\)</span> is a regular
expression</p>
</blockquote></li>
<li><p><span><em>Recursive steps of recursive definition</em></span></p>
<blockquote>
<p><span class="math inline">\((R_1 \cup R_2)\)</span> is a regular
expression when <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions</p>
<p><span class="math inline">\((R_1 \circ R_2)\)</span> is a regular
expression when <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions</p>
<p><span class="math inline">\((R_1^*)\)</span> is a regular expression
when <span class="math inline">\(R_1\)</span> is a regular
expression</p>
</blockquote></li>
</ul>
<p>The <span><em>semantics</em></span> (or meaning) of the syntactic
regular expression is the <span><strong>language described by the
regular expression</strong></span>. The function that assigns a language
to a regular expression over <span class="math inline">\(\Sigma\)</span>
is defined recursively, using familiar set operations:</p>
<ul>
<li><p><span><em>Basis steps of recursive definition</em></span></p>
<blockquote>
<p>The language described by <span class="math inline">\(a\)</span>, for
<span class="math inline">\(a \in \Sigma\)</span>, is <span
class="math inline">\(\{a\}\)</span> and we write <span
class="math inline">\(L(a) = \{a\}\)</span></p>
<p>The language described by <span
class="math inline">\(\varepsilon\)</span> is <span
class="math inline">\(\{\varepsilon\}\)</span> and we write <span
class="math inline">\(L(\varepsilon) = \{ \varepsilon\}\)</span></p>
<p>The language described by <span
class="math inline">\(\emptyset\)</span> is <span
class="math inline">\(\{\}\)</span> and we write <span
class="math inline">\(L(\emptyset) = \emptyset\)</span>.</p>
</blockquote></li>
<li><p><span><em>Recursive steps of recursive definition</em></span></p>
<blockquote>
<p>When <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions, the language
described by the regular expression <span class="math inline">\((R_1
\cup R_2)\)</span> is the union of the languages described by <span
class="math inline">\(R_1\)</span> and <span
class="math inline">\(R_2\)</span>, and we write <span
class="math display">\[L(~(R_1 \cup R_2)~) = L(R_1) \cup L(R_2) = \{ w
\mid w \in L(R_1) \lor w \in L(R_2)\}\]</span></p>
<p>When <span class="math inline">\(R_1\)</span>, <span
class="math inline">\(R_2\)</span> are regular expressions, the language
described by the regular expression <span class="math inline">\((R_1
\circ R_2)\)</span> is the concatenation of the languages described by
<span class="math inline">\(R_1\)</span> and <span
class="math inline">\(R_2\)</span>, and we write <span
class="math display">\[L(~(R_1 \circ R_2)~) = L(R_1) \circ L(R_2) = \{
uv \mid u \in L(R_1) \land v \in L(R_2)\}\]</span></p>
<p>When <span class="math inline">\(R_1\)</span> is a regular
expression, the language described by the regular expression <span
class="math inline">\((R_1^*)\)</span> is the <span><strong>Kleene
star</strong></span> of the language described by <span
class="math inline">\(R_1\)</span> and we write <span
class="math display">\[L(~(R_1^*)~) = (~L(R_1)~)^* = \{ w_1 \cdots w_k
\mid k \geq 0 \textrm{ and each } w_i \in L(R_1)\}\]</span></p>
</blockquote></li>
</ul>
<p>For the following examples assume the alphabet is <span
class="math inline">\(\Sigma_1 =  \{0,1\}\)</span>:</p>
<p>The language described by the regular expression <span
class="math inline">\(0\)</span> is <span class="math inline">\(L(0) =
\{ 0 \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(1\)</span> is <span class="math inline">\(L(1)  =
\{ 1 \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(\varepsilon\)</span> is <span
class="math inline">\(L(\varepsilon) = \{ \varepsilon  \}\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(\emptyset\)</span> is <span
class="math inline">\(L(\emptyset) = \emptyset\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\((\Sigma_1 \Sigma_1 \Sigma_1)^*\)</span> is <span
class="math inline">\(L(~(\Sigma_1 \Sigma_1 \Sigma_1)^*~) =\)</span></p>
<p>The language described by the regular expression <span
class="math inline">\(1^+\)</span> is <span
class="math inline">\(L(~(1^+)~) = L(1^* \circ 1) =\)</span></p>
<p><span><em>Shorthand and conventions</em></span> (Sipser pages
63-65)</p>
<div class="center">
<table>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td colspan="2" style="text-align: left;">Assuming <span
class="math inline">\(\Sigma\)</span> is the alphabet, we use the
following conventions</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(\Sigma\)</span></td>
<td style="text-align: left;">regular expression describing language
consisting of all strings of length <span
class="math inline">\(1\)</span> over <span
class="math inline">\(\Sigma\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><span class="math inline">\(*\)</span>
then <span class="math inline">\(\circ\)</span> then <span
class="math inline">\(\cup\)</span></td>
<td style="text-align: left;">precedence order, unless parentheses are
used to change it</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(R_1R_2\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R_1  \circ R_2\)</span> (concatenation symbol is
implicit)</td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(R^+\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R^* \circ R\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><span
class="math inline">\(R^k\)</span></td>
<td style="text-align: left;">shorthand for <span
class="math inline">\(R\)</span> concatenated with itself <span
class="math inline">\(k\)</span> times, where <span
class="math inline">\(k\)</span> is a (specific) natural number</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><span><strong>Caution: many programming languages that support
regular expressions build in functionality that is more powerful than
the “pure” definition of regular expressions given here.</strong>
</span></p>
<p>Regular expressions are everywhere (once you start looking for
them).</p>
<p>Software tools and languages often have built-in support for regular
expressions to describe <span><strong>patterns</strong></span> that we
want to match (e.g. Excel/ Sheets, grep, Perl, python, Java, Ruby).</p>
<p>Under the hood, the first phase of
<span><strong>compilers</strong></span> is to transform the strings we
write in code to tokens (keywords, operators, identifiers, literals).
Compilers use regular expressions to describe the sets of strings that
can be used for each token type.</p>
<p>Next time: we’ll start to see how to build machines that decide
whether strings match the pattern described by a regular expression.</p>
<p><span><em>Extra examples for practice:</em></span></p>
<p>Which regular expression(s) below describe a language that includes
the string <span class="math inline">\(a\)</span> as an element?</p>
<p><span class="math inline">\(a^* b^*\)</span></p>
<p><span class="math inline">\(a(ba)^* b\)</span></p>
<p><span class="math inline">\(a^* \cup b^*\)</span></p>
<p><span class="math inline">\((aaa)^*\)</span></p>
<p><span class="math inline">\((\varepsilon \cup a) b\)</span></p>
<h2 class="unnumbered" id="week-1-friday">Week 1 Friday</h2>
<p><span><strong>Review</strong></span>: Determine whether each
statement below about regular expressions over the alphabet <span
class="math inline">\(\{a,b,c\}\)</span> is true or false:</p>
<p>True or False: <span class="math inline">\(ab  \in L(~ (a \cup
b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(ba \in L( ~ a^* b^*
~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(a \cup
b \cup c)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon  \in L(~ (a
\cup b)^*  ~)\)</span></p>
<p>True or False: <span class="math inline">\(\varepsilon \in L( ~ aa^*
\cup bb^* ~)\)</span></p>
<p>**This definition was in the pre-class reading** A finite automaton
(FA) is specified by <span class="math inline">\(M = (Q, \Sigma, \delta,
q_0, F)\)</span>. This <span class="math inline">\(5\)</span>-tuple is
called the <span><strong>formal definition</strong></span> of the FA.
The FA can also be represented by its state diagram: with nodes for the
state, labelled edges specifying the transition function, and
decorations on nodes denoting the start and accept states.</p>
<blockquote>
<p>Finite set of states <span class="math inline">\(Q\)</span> can be
labelled by any collection of distinct names. Often we use default state
labels <span class="math inline">\(q0, q1, \ldots\)</span></p>
</blockquote>
<blockquote>
<p>The alphabet <span class="math inline">\(\Sigma\)</span> determines
the possible inputs to the automaton. Each input to the automaton is a
string over <span class="math inline">\(\Sigma\)</span>, and the
automaton “processes” the input one symbol (or character) at a time.</p>
</blockquote>
<blockquote>
<p>The transition function <span class="math inline">\(\delta\)</span>
gives the next state of the automaton based on the current state of the
machine and on the next input symbol.</p>
</blockquote>
<blockquote>
<p>The start state <span class="math inline">\(q_0\)</span> is an
element of <span class="math inline">\(Q\)</span>. Each computation of
the machine starts at the start state.</p>
</blockquote>
<blockquote>
<p>The accept (final) states <span class="math inline">\(F\)</span> form
a subset of the states of the automaton, <span class="math inline">\(F
\subseteq  Q\)</span>. These states are used to flag if the machine
accepts or rejects an input string.</p>
</blockquote>
<blockquote>
<p>The computation of a machine on an input string is a sequence of
states in the machine, starting with the start state, determined by
transitions of the machine as it reads successive input symbols.</p>
</blockquote>
<blockquote>
<p>The finite automaton <span class="math inline">\(M\)</span> accepts
the given input string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in an accept
state. <span class="math inline">\(M\)</span> rejects the given input
string exactly when the computation of <span
class="math inline">\(M\)</span> on the input string ends in a nonaccept
state, that is, a state that is not in <span
class="math inline">\(F\)</span>.</p>
</blockquote>
<blockquote>
<p>The language of <span class="math inline">\(M\)</span>, <span
class="math inline">\(L(M)\)</span>, is defined as the set of all
strings that are each accepted by the machine <span
class="math inline">\(M\)</span>. Each string that is rejected by <span
class="math inline">\(M\)</span> is not in <span
class="math inline">\(L(M)\)</span>. The language of <span
class="math inline">\(M\)</span> is also called the language recognized
by <span class="math inline">\(M\)</span>.</p>
</blockquote>
<p>What is <span><strong>finite</strong></span> about all finite
automata? (Select all that apply)</p>
<ul>
<li><p>The size of the machine (number of states, number of
arrows)</p></li>
<li><p>The length of each computation of the machine</p></li>
<li><p>The number of strings that are accepted by the machine</p></li>
</ul>
<figure>
<img src="../../resources/machines/Lect2DFA1.png" style="width:3in" />
</figure>
<p>The formal definition of this FA is</p>
<p>Classify each string <span class="math inline">\(a, aa, ab, ba, bb,
\varepsilon\)</span> as accepted by the FA or rejected by the FA.</p>
<p><span><em>Why are these the only two options?</em></span></p>
<p>The language recognized by this automaton is</p>
<figure>
<img src="../../resources/machines/Lect2DFA2.png" style="width:3in" />
</figure>
<p>The language recognized by this automaton is</p>
<figure>
<img src="../../resources/machines/Lect2DFA3.png" style="width:3in" />
</figure>
<p>The language recognized by this automaton is</p>
<h2 class="unnumbered" id="week-1-at-a-glance">Week 1 at a glance</h2>
<h3 class="unnumbered"
id="textbook-reading-chapter-0-sections-1.3-1.1">Textbook reading:
Chapter 0, Sections 1.3, 1.1</h3>
<p><span><em>For Monday</em></span>: Class syllabus
https://canvas.ucsd.edu/courses/45073.</p>
<p><span><em>For Wednesday</em></span>: Example 1.51 and Definition 1.52
(definition of regular expressions) on page 64.
<span><em>Notice</em></span>: we are jumping to Section 1.3 and then
will come back to Section 1.1 on Friday.</p>
<p><span><em>For Friday</em></span>: Figure 1.4 and Definition 1.5
(definition of finite automata) on pages 34-35. The definition of the
union, concatenation, and star operations for languages is given as
Definition 1.23 on page 44 and a useful example is Example 1.24.</p>
<p><span><em>For Week 2 Wednesday</em></span>: Pages 41-43 (Figures
1.18, 1.19, 1.20) (examples of automata and languages).
<span><em>Notice</em></span>: Week 2 Monday is a UCSD Holiday in
observance of Martin Luther King Jr. day so there is no CSE 105
class.</p>
<p><span><em>Textbook references: Within a chapter, each item is
numbered consecutively. Figure 1.22 is the twenty-second numbered item
in chapter one; it comes right after Example 1.21 and right before
Definition 1.23.</em></span></p>
<h3 class="unnumbered" id="make-sure-you-can">Make sure you can:</h3>
<ul>
<li><p>Distinguish between alphabet, language, sets, and
strings</p></li>
<li><p>Translate a decision problem to a set of strings coding the
problem</p></li>
<li><p>Use regular expressions and relate them to languages and
automata</p>
<ul>
<li><p>Write and debug regular expressions using correct syntax</p></li>
<li><p>Determine if a given string is in the language described by a
regular expression</p></li>
</ul></li>
<li><p>Use precise notation to formally define the state diagram of
finite automata and use clear English to describe computations of finite
automata informally.</p>
<ul>
<li><p>State the formal definition of (deterministic) finite
automata</p></li>
<li><p>Trace the computation of a finite automaton on a given string
using its state diagram</p></li>
<li><p>Translate between a state diagram and a formal
definition</p></li>
<li><p>Determine if a given string is in the language described by a
finite automaton</p></li>
</ul></li>
</ul>
<h3 class="unnumbered" id="todo">TODO:</h3>
<div class="list">
<p>#FinAid Assignment on Canvas
https://canvas.ucsd.edu/courses/51649/quizzes/158899</p>
<p>Review quizzes based on class material each day.</p>
<p>Homework assignment 1 due next week.</p>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Page references are to the 3rd edition of Sipser’s
Introduction to the Theory of Computation, available through various
sources for approximately $30. You may be able to opt in to purchase a
digital copy through Canvas. Copies of the book are also available for
those who can’t access the book to borrow from the course instructor,
while supplies last (minnes@ucsd.edu)<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
